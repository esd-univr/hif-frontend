%{
    
/// @file verilog.lex
/// @brief
/// @copyright (c) 2024 Electronic Systems Design (ESD) Lab @ UniVR
/// This file is distributed under the BSD 2-Clause License.
/// See LICENSE.md for details.

#include <cassert>
#include <iostream>
#include <cstdlib>
#include <cmath>
#include <map>
#include <vector>
#include <string>
#include <list>
#include <cstring>
#include <algorithm>
#include <functional>
#include <cctype>
#include <locale>

// HIF library
#include <hif/hif.hpp>

#include "verilog2hif/parse_line.hpp"
#include "verilog2hif/support.hpp"
#include "verilog2hif/verilog_parser.hpp"

// Generated by Bison.
#include "verilog_parser.hpp"

// Print tokens recognized by the lexer
#define LEXER_VERBOSE_MODE

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wheader-hygiene"
#pragma clang diagnostic ignored "-Wmissing-noreturn"
#pragma clang diagnostic ignored "-Wdocumentation"
#pragma clang diagnostic ignored "-Wmissing-prototypes"
#pragma clang diagnostic ignored "-Wunused-function"
#elif defined __GNUC__
#pragma GCC diagnostic ignored "-Wzero-as-null-pointer-constant"
#pragma GCC diagnostic ignored "-Wunused-function"
#endif
using namespace hif;

#if (defined _MSC_VER)
#pragma warning(disable:4102)
#pragma warning(disable:4267)

int yylex_destroy(){ return 0; }

int fake( int i )
{
    return _isatty( i );
}

#undef isatty
#define isatty fake
#endif

// Support to split paths. Needed by expand_macro() method
#if (defined _MSC_VER)

std::string _getPath( const std::string & path )
{
    char * dir = static_cast<char*>(malloc(sizeof(char) * path.size() +1 ));
    dir[ path.size() ] = '\0';
    if ( _splitpath_s(
             path.c_str(),
             /*drive*/ nullptr, 0,
             dir, path.size(),
             /*fname*/ nullptr, 0,
             /*ext*/ nullptr, 0
             ) != 0 )
    {
        // error
        free( dir );
        return "";
    }
    std::string ret = dir;
    free( dir );
    return ret;
}
#else
#include <libgen.h>

std::string _getPath( const std::string & path )
{
    char * c = hif::application_utils::hif_strdup(path.c_str());
    std::string d = dirname( c );
    free(c);
    return d;
}
#endif

// Needed by expand_macro() function
extern Verilog2hifParseLine * parse_line_ptr;
extern VerilogParser * parserInstance;     // defined in verilogParser.cc


/*K: sux, but seems required...*/
#if (defined _MSC_VER)
    int yylineno = 1;
#endif

namespace
{
    // see start conditions "LCOMMENT/COMMENT"
    int comment_caller;

    // see start condition "MACRO_EXPANSION"
    int macro_expansion_paren_count = 0;
    std::string macro_expansion_call = "";

    bool isStandardInclude(const std::string & inc)
    {
        if (! VerilogParser::isVerilogAms()) return false;

        if (inc == "disciplines.vams"
            || inc == "constants.vams"
            || inc == "driver_access.vams"
            || inc == "disciplines.h"
            || inc == "discipline.h" // Questa accepts also this...
            || inc == "constants.h"
            || inc == "driver_access.h"
            )
            return true;

        return false;
    }


    struct _macro_t
    {
        _macro_t();
        ~_macro_t();
        /* move semantics */
        _macro_t(const _macro_t & m );
        _macro_t & operator = (const _macro_t & m );

        char * value;
        char * expanded_value;
        std::string name;
    };

    _macro_t::_macro_t():
    value(nullptr),
    expanded_value(nullptr),
    name()
    {
        // do nothing
    }

    _macro_t::~_macro_t()
    {
        free(value);
        free(expanded_value);
    }

    /* move semantics */
    _macro_t::_macro_t(const _macro_t & m ):
    value( m.value ),
    expanded_value( m.expanded_value ),
    name(m.name)
    {
        const_cast<_macro_t *>(&m)->value = nullptr;
        const_cast<_macro_t *>(&m)->expanded_value = nullptr;
    }

    _macro_t & _macro_t::operator = (const _macro_t & m )
    {
        if ( &m == this ) return *this;

        value = const_cast<_macro_t *>(&m)->value;
        expanded_value = const_cast<_macro_t *>(&m)->expanded_value;
        name = m.name;
        const_cast<_macro_t *>(&m)->value = nullptr;
        const_cast<_macro_t *>(&m)->expanded_value = nullptr;

        return *this;
    }


    struct _buffer_t
    {
        _buffer_t();

        /* move semantics */
        _buffer_t( const _buffer_t & b);

        ~_buffer_t();

        std::string filename;
        FILE * file;
        int line;
        int column;
        YY_BUFFER_STATE buffer;
        std::string basedir;

    private:

        _buffer_t & operator = (const _buffer_t & );
    };

    _buffer_t::_buffer_t():
    filename(),
    file(nullptr),
    line( 1 ),
    column( 1 ),
    buffer(nullptr),
    basedir()
    {}

    /* move semantics */
    _buffer_t::_buffer_t( const _buffer_t & b):
    filename( b.filename ),
    file( b.file ),
    line( b.line  ),
    column( b.column ),
    buffer( b.buffer),
    basedir( b.basedir )
    {
        const_cast<_buffer_t *>(&b)->file = nullptr;
        const_cast<_buffer_t *>(&b)->buffer = nullptr;
    }

    _buffer_t::~_buffer_t()
    {
        if (file) fclose(file);
    }


    typedef std::map< std::string, _macro_t > DefineMap_t;
    typedef std::list< _buffer_t  > BufferStack_t;

    static DefineMap_t defines;
    static BufferStack_t buffers;

    std::string get_basedir( std::string basedir )
    {
        std::size_t e = basedir.rfind("/");
        if ( e != std::string::npos )
            basedir = basedir.substr( 0, e );
        else
            basedir = "";

        return basedir;
    }

    // trim from start
    static std::string &string_ltrim(std::string &s)
    {
        s.erase(s.begin(), std::find_if(s.begin(), s.end(),
                        [](const char c){return !std::isspace(c);}));
        return s;
    }

    // trim from end
    static std::string &string_rtrim(std::string &s)
    {
        s.erase(std::find_if(s.rbegin(), s.rend(),
                        [](const char c){return !std::isspace(c);}).base(), s.end());
        return s;
    }

    // trim from both ends
    static std::string &string_trim(std::string &s)
    {
        return string_ltrim(string_rtrim(s));
    }

    std::list<std::string> &string_split(const std::string &s, const char delim, std::list<std::string> &elems)
    {
        int parens = 0;
        std::string item;
        std::stringstream ss(s);

        while (ss.good())
        {
            char c;
            ss >> c;
            if (!ss.good()) break;

            if (c == delim && parens == 0)
            {
                // eol:
                elems.push_back(string_trim(item));
                item = "";
                continue;
            }

            if (c == '(')
            {
                ++parens;
            }
            else if (c == ')')
            {
                --parens;
            }

            item += c;
        }
        // pushing last elem:
        elems.push_back(string_trim(item));
        return elems;
    }

    std::list<std::string> string_split(const std::string &s, char delim)
    {
        std::list<std::string> elems;
        string_split(s, delim, elems);
        return elems;
    }

    bool checkReplace(std::string pre, std::string post)
    {
        if (pre.empty() && post.empty()) return true;

        if (pre.empty())
        {
            return !isalpha(post.at(0)) && !isdigit(post.at(0));
        }

        if (post.empty())
            return !isalpha(pre.at(0)) && !isdigit(pre.at(0));

        return !isalpha(pre.at(0))
                && !isalpha(post.at(0))
                && !isdigit(pre.at(0))
                && !isdigit(post.at(0));
    }

    bool replaceAll( std::string &s, const std::string &search, const std::string &replace )
    {
        bool found = false;

        for( size_t pos = 0; ; pos += replace.length() )
        {
            // Locate the substring to be replaced
            pos = s.find( search, pos );
            if( pos == std::string::npos ) break;

            std::string pre;    // prefix
            std::string post;   // suffix

            if (pos > 0)
                pre = s.at(pos - 1);

            if (pos + search.length() < s.length() )
                post = s.at(pos + search.length());

            if ( checkReplace(pre, post) )
            {
                found = true;

                // Replace by erasing and inserting
                s.erase( pos, search.length() );
                s.insert( pos, replace );
            }
        }

        if (!found)
        {
            std::string msg = std::string("Formal parameter ") + search + std::string(" not found");
            messageError(msg, nullptr, nullptr);
        }

        return found;
    }

    void push_buffer( const char * fname )
    {
        std::string filename( fname );
        if ( filename[ 0 ] != '/' && buffers.back().basedir != "")
          filename = buffers.back().basedir + "/" + filename;
        FILE * file = fopen( filename.c_str(), "r" );
        if ( file == nullptr ) yyerror((std::string("File not found: ") + filename).c_str());

        if ( buffers.size() == 1 )
        {
            buffers.back().buffer = YY_CURRENT_BUFFER;
        }

        buffers.back().line = yylineno;
        buffers.back().column = yycolumno;
        buffers.back().filename = yyfilename;
        if (parse_line_ptr->isVerbose())
        {
            yymessage( (std::string("Stop parsing: ")+buffers.back().filename).c_str());
        }
        yylineno = 1;
        yycolumno = 1;
        yyfilename = filename;
        if (parse_line_ptr->isVerbose())
        {
            yymessage( (std::string("Start parsing: ")+filename).c_str());
        }

        YY_BUFFER_STATE buf = yy_create_buffer(file, YY_BUF_SIZE);
        yyin = file;
        yy_switch_to_buffer( buf );


        _buffer_t b;
        b.file = file;
        b.filename = filename;
        b.buffer = buf;
        b.line = 1;
        b.column = 1;
        b.basedir = get_basedir( filename );

        buffers.push_back( b );
    }

    bool pop_buffer()
    {
        if ( buffers.empty() ) return true;
        yy_delete_buffer( YY_CURRENT_BUFFER );
        if (parse_line_ptr->isVerbose())
        {
            yymessage( (std::string("End parsing: ") + buffers.back().filename).c_str() );
        }
        yylineno = buffers.back().line;
        yycolumno = buffers.back().column;
        yyfilename = buffers.back().filename;
        buffers.pop_back();
        if ( buffers.empty() ) return true;

        yylineno = buffers.back().line;
        yycolumno = buffers.back().column;
        yyfilename = buffers.back().filename;
        yyin = buffers.back().file;
        if (parse_line_ptr->isVerbose())
        {
            yymessage( (std::string("Restart parsing: ") + buffers.back().filename).c_str() );
        }

        yy_switch_to_buffer( buffers.back().buffer );

        return false;
    }

    void define_macro( const std::string & macroname, const std::string & macrodef )
    {
        _macro_t m;
        std::string tmp = macrodef;

        if (!tmp.empty() && tmp.at(tmp.size()-1) == '\n')
        {
            tmp = tmp.substr(0, tmp.size() -1);
        }

        m.value = hif::application_utils::hif_strdup( tmp.c_str() );
        m.name = macroname;
        if (parse_line_ptr->isVerbose())
        {
            yymessage( (std::string("Defined macro: ")+ m.name + " with value: " + m.value).c_str());
        }
        defines[ macroname ] = m;
    }

    void undef_macro( const char * macroname )
    {
        DefineMap_t::iterator i = defines.find( macroname );
        if ( i == defines.end() ) return;
        defines.erase( i );
    }

    bool ifdef_macro( const char * macroname )
    {
        return defines.find( macroname ) != defines.end();
    }

    void resetall_macro()
    {
        defines.clear();
    }

    void expand_macro( const char * m )
    {
        std::string macroname( m );
        DefineMap_t::iterator i = defines.find( macroname );
        FILE * file = nullptr;
        if ( i == defines.end() )
        {
            yydebug((std::string("Macro not found. Definition expected in standard library: ")
                     + macroname).c_str());

            file = hif::application_utils::hif_fmemopen( const_cast<char*>(m),
                                 static_cast<int>(strlen(m)), "r",
                                 _getPath(parse_line_ptr->getOutputFile()).c_str() );
        }
        else
        {
            file = hif::application_utils::hif_fmemopen( i->second.value,
                                 static_cast<int>(strlen(i->second.value)), "r",
                                 _getPath(parse_line_ptr->getOutputFile()).c_str() );
        }

        // Like push_buffer:

        if ( buffers.size() == 1 )
        {
          buffers.back().buffer = YY_CURRENT_BUFFER;
        }

        buffers.back().line = yylineno;

        if (parse_line_ptr->isVerbose())
        {
            yymessage( (std::string("Stop parsing: ")+buffers.back().filename).c_str());
            yymessage( (std::string("Start parsing: ")+macroname).c_str());
        }

        yyin = file;
        YY_BUFFER_STATE buf = yy_create_buffer(file, YY_BUF_SIZE);
        yy_switch_to_buffer( buf );

        _buffer_t b;
        b.file = file;
        b.filename = macroname;
        b.buffer = buf;
        b.line = yylineno;
        b.basedir = buffers.back().basedir;
        buffers.push_back( b );
    }

    std::string macro_substitute_parameters(
            std::list<std::string> &formalParameterList,
            std::list<std::string> &actualParameterList,
            std::string macroBody)
    {
        //
        //  macroBody  =  (FORMAL_PARAM1, FORMAL_PARAM2, ...) MACRO_BODY
        //

        macroBody = string_trim(macroBody);
        size_t indexParen = macroBody.find(')');

        macroBody = macroBody.substr(indexParen + 1);
        macroBody = string_trim(macroBody);

        std::list<std::string>::iterator itActual = actualParameterList.begin();
        std::list<std::string>::iterator itFormal = formalParameterList.begin();

        messageAssert(actualParameterList.size() == formalParameterList.size(),
                      "Formal parameters do not match actual parameters in macro definition", nullptr, nullptr);

        for (; itActual != actualParameterList.end(); ++itActual, ++itFormal)
        {
            std::string actualParam = *itActual;
            std::string formalParam = *itFormal;

            replaceAll(macroBody, formalParam, actualParam);
        }

        return macroBody;
    }

    std::list<std::string> extract_actual_parameters(std::string actualParameters)
    {
        //
        //  actualParameters  = ACTUAL_PARAM1, ACTUAL_PARAM2, ...
        //

        std::list<std::string> actualParameterList;
        actualParameterList = string_split(actualParameters, ',');

        return actualParameterList;
    }

    std::list<std::string> extract_formal_parameters(std::string formalParameters)
    {
        //
        //  formalParameters  = (FORMAL_PARAM1, FORMAL_PARAM2) MACRO_BODY
        //
        std::list<std::string> formalParameterList;
        formalParameters = string_trim(formalParameters);
        size_t indexParen = formalParameters.find(')');

        formalParameters = formalParameters.substr(1, indexParen - 1);
        formalParameters = string_trim(formalParameters);

        formalParameterList = string_split(formalParameters, ',');

        return formalParameterList;
    }

    void expand_parametric_macro( std::string mCall )
    {
        //
        //  mCall  =  'MACRO_NAME ( ACTUAL_PARAM1, ACTUAL_PARAM2, .. )
        //

        std::string macroName;
        std::string formalParametersString;
        std::list<std::string> formalParametersList;
        std::list<std::string> actualParametersList;
        size_t indexOfFirstParen = mCall.find('(', 0);

        // remove the first character ( ' )
        mCall = mCall.substr(1, mCall.length() - 1);
        // get the define's name
        macroName = mCall.substr(0, indexOfFirstParen - 1);
        // get the formal parameters string (removing the parenthesis at the end)
        formalParametersString = mCall.substr(indexOfFirstParen);
        formalParametersString = formalParametersString.substr(0, formalParametersString.length()-1);
        formalParametersString = string_trim(formalParametersString);

        (*debugStream) << " -- MACRO: Expanding parametric macro '" << macroName << "'" << std::endl;

        // search for macro definition
        DefineMap_t::iterator i = defines.find( macroName );
        messageAssert( i != defines.end(), "Macro definition not found", nullptr, nullptr );

        // Get list of formal parameters.
        // We extract it from the macro's body.
        formalParametersList = extract_formal_parameters(i->second.value);
        actualParametersList = extract_actual_parameters(formalParametersString);

        // expand the macro
        std::string expandedMacro = macro_substitute_parameters(
                                   formalParametersList,
                                   actualParametersList,
                                   i->second.value);

        (*debugStream) << " -- MACRO: '" << macroName << "' expanded to ---"<< std::endl;
        (*debugStream) << std::string(80, '-') << std::endl;
        (*debugStream) << expandedMacro  << std::endl;
        (*debugStream) << std::string(80, '-') << std::endl;

        i->second.expanded_value = hif::application_utils::hif_strdup( expandedMacro.c_str() );

        // continue parsing
        FILE * file = hif::application_utils::hif_fmemopen( i->second.expanded_value,
                                    static_cast<int>(strlen(i->second.expanded_value)), "r",
                                    _getPath(parse_line_ptr->getOutputFile()).c_str() );

        // Like push_buffer:
        if ( buffers.size() == 1 )
        {
            buffers.back().buffer = YY_CURRENT_BUFFER;
        }
        buffers.back().line = yylineno;

        if (parse_line_ptr->isVerbose())
        {
            yymessage( (std::string("Stop parsing: ")+buffers.back().filename).c_str());
            yymessage( (std::string("Start parsing: ")+macroName).c_str());
        }

        yyin = file;
        YY_BUFFER_STATE buf = yy_create_buffer(file, YY_BUF_SIZE);
        yy_switch_to_buffer( buf );

        _buffer_t b;
        b.file = file;
        b.filename = macroName;
        b.buffer = buf;
        b.line = yylineno;
        b.basedir = buffers.back().basedir;
        buffers.push_back( b );
    }

    std::string tmpMacroName;
    std::string tmpMacroBody;
    std::string includename;

    bool isMultiLineMacro = false;
    unsigned int ifcond = 0;

} // unnamed namespace

bool init_buffer( const char * fname );
bool init_buffer( const char * fname )
{
    resetall_macro();
    FILE * file = fopen( fname, "r" );

    if ( file == nullptr ) return false;

    yyin = file;

    yymessage( (std::string("Parsing file: ")+fname).c_str());

    yylineno = 1;
    yycolumno = 1;

    _buffer_t b;
    b.file = file;
    b.filename = fname;
    b.buffer = nullptr; // no buf now...
    b.line = 1;
    b.column = 1;
    b.basedir = get_basedir( b.filename );
    buffers.push_back( b );

    return true;
}

// Defined in verilog_parser_extension
void parse_timescale(std::string ts);

/*
 *  TOKENS
 * ------------------------------------------------------------------------------ */

#define YYLMAX                          1024
#define MVL_LG_MC                       20

// Size of token tables
#define VERILOG_TOKENS_TABLE_LEN        (sizeof(verilog_tokens) / sizeof(el_mc))
#define VERILOG_AMS_TOKENS_TABLE_LEN    (sizeof(verilog_ams_tokens) / sizeof(el_mc))


typedef struct
{
    char nom[MVL_LG_MC];
    int kval;
} el_mc;

/*
 *  VERILOG reserved keywords
 */
static el_mc verilog_tokens []=
{
    {"PATHPULSE$",     K_pathpulse},
    {"always",         K_always},
    {"and",            K_and},
    {"assign",         K_assign},
    {"automatic",      K_automatic},
    {"begin",          K_begin},
    {"buf",            K_buf},
    {"bufif0",         K_bufif0},
    {"bufif1",         K_bufif1},
    {"case",           K_case},
    {"casex",          K_casex},
    {"casez",          K_casez},
    {"cell",           K_cell},
    {"cmos",           K_cmos},
    {"config",         K_config},
    {"deassign",       K_deassign},
    {"default",        K_default},
    {"defparam",       K_defparam},
    {"design",         K_design},
    {"disable",        K_disable},
    {"edge",           K_edge},
    {"else",           K_else},
    {"end",            K_end},
    {"endcase",        K_endcase},
    {"endconfig",      K_endconfig},
    {"endfunction",    K_endfunction},
    {"endgenerate",    K_endgenerate},
    {"endmodule",      K_endmodule},
    {"endprimitive",   K_endprimitive},
    {"endspecify",     K_endspecify},
    {"endtable",       K_endtable},
    {"endtask",        K_endtask},
    {"event",          K_event},
    {"for",            K_for},
    {"force",          K_force},
    {"forever",        K_forever},
    {"fork",           K_fork},
    {"function",       K_function},
    {"generate",       K_generate},
    {"genvar",         K_genvar},
    {"highz0",         K_highz0},
    {"highz1",         K_highz1},
    {"if",             K_if},
    {"ifnone",         K_ifnone},
    //{"-incdir",        K_incdir},
    {"include",        K_include},
    {"initial",        K_initial},
    {"inout",          K_inout},
    {"input",          K_input},
    {"instance",       K_instance},
    {"integer",        K_integer},
    {"join",           K_join},
    {"large",          K_large},
    {"liblist",        K_liblist},
    {"library",        K_library},
    {"localparam",     K_localparam},
    {"macromodule",    K_macromodule},
    {"medium",         K_medium},
    {"module",         K_module},
    {"nand",           K_nand},
    {"negedge",        K_negedge},
    {"nmos",           K_nmos},
    {"nor",            K_nor},
    {"noshowcancelled",    K_noshowcancelled},
    {"not",            K_not},
    {"notif0",         K_notif0},
    {"notif1",         K_notif1},
    {"or",             K_or},
    {"output",         K_output},
    {"parameter",      K_parameter},
    {"pmos",           K_pmos},
    {"posedge",        K_posedge},
    {"primitive",      K_primitive},
    {"pull0",          K_pull0},
    {"pull1",          K_pull1},
    {"pulldown",       K_pulldown},
    {"pullup",         K_pullup},
    {"pulsestyle_onevent",     K_pulsestyle_onevent},
    {"pulsestyle_ondetect",    K_pulsestyle_ondetect},
    {"rcmos",          K_rcmos},
    {"real",           K_real},
    {"realtime",       K_realtime},
    {"reg",            K_reg},
    {"release",        K_release},
    {"repeat",         K_repeat},
    {"rnmos",          K_rnmos},
    {"rpmos",          K_rpmos},
    {"rtran",          K_rtran},
    {"rtranif0",       K_rtranif0},
    {"rtranif1",       K_rtranif1},
    {"scalared",       K_scalared},
    {"showcancelled",  K_showcancelled},
    {"signed",         K_signed},
    {"small",          K_small},
    {"specify",        K_specify},
    {"specparam",      K_specparam},
    {"strong0",        K_strong0},
    {"strong1",        K_strong1},
    {"supply0",        K_supply0},
    {"supply1",        K_supply1},
    {"table",          K_table},
    {"task",           K_task},
    {"time",           K_time},
    {"tran",           K_tran},
    {"tranif0",        K_tranif0},
    {"tranif1",        K_tranif1},
    {"tri",            K_tri},
    {"tri0",           K_tri0},
    {"tri1",           K_tri1},
    {"triand",         K_triand},
    {"trior",          K_trior},
    {"trireg",         K_trireg},
    {"unsigned",       K_unsigned},
    {"use",            K_use},
    {"uwire",          K_uwire},
    {"vectored",       K_vectored},
    {"wait",           K_wait},
    {"wand",           K_wand},
    {"weak0",          K_weak0},
    {"weak1",          K_weak1},
    {"while",          K_while},
    {"wire",           K_wire},
    {"wor",            K_wor},
    {"xnor",           K_xnor},
    {"xor",            K_xor}
};

static el_mc verilog_ams_tokens []=
{
    {"above",          K_above},
    {"abs",            K_abs},
    {"absdelay",       K_absdelay},
    {"absdelta",       K_absdelta},
    {"abstol",         K_abstol},
    {"access",         K_access},
    {"acos",           K_acos},
    {"acosh",          K_acosh},
    {"ac_stim",        K_ac_stim},
    {"aliasparam",     K_aliasparam},
    {"analog",         K_analog},
    {"analysis",       K_analysis},
    {"asin",           K_asin},
    {"asinh",          K_asinh},
    {"atan",           K_atan},
    {"atan2",          K_atan2},
    {"atanh",          K_atanh},
    {"branch",         K_branch},
    {"ceil",           K_ceil},
    {"connect",        K_connect},
    {"connectmodule",  K_connectmodule},
    {"connectrules",   K_connectrules},
    {"continuos",      K_continuous},
    {"cos",            K_cos},
    {"cosh",           K_cosh},
    {"cross",          K_cross},
    {"ddt",            K_ddt},
    {"ddt_nature",     K_ddt_nature},
    {"ddx",            K_ddx},
    {"discipline",     K_discipline},
    {"discrete",       K_discrete},
    {"domain",         K_domain},
    {"driver_update",  K_driver_update},
    {"endconnectrules",    K_endconnectrules},
    {"enddiscipline",      K_enddiscipline},
    {"endnature",      K_endnature},
    {"endparamset",    K_endparamset},
    {"exclude",        K_exclude},
    {"exp",            K_exp},
    {"final_step",     K_final_step},
    {"flicker_noise",  K_flicker_noise},
    {"floor",          K_floor},
    {"flow",           K_flow},
    {"from",           K_from},
    {"ground",         K_ground},
    {"hypot",          K_hypot},
    {"idt",            K_idt},
    {"idtmod",         K_idtmod},
    {"idt_nature",     K_idt_nature},
    {"inf",            K_inf},
    {"initial_step",   K_initial_step},
    {"laplace_nd",     K_laplace_nd},
    {"laplace_np",     K_laplace_np},
    {"laplace_zd",     K_laplace_zd},
    {"laplace_zp",     K_laplace_zp},
    {"last_crossing",  K_last_crossing},
    {"limexp",         K_limexp},
    {"ln",             K_ln},
    {"log",            K_log},
    {"max",            K_max},
    {"merge",          K_merged},
    {"min",            K_min},
    {"nature",         K_nature},
    {"net_resolution", K_net_resolution},
    {"noise_table",    K_noise_table},
    {"paramset",       K_paramset},
    {"potential",      K_potential},
    {"pow",            K_pow},
    {"resolveto",      K_resolveto},
    {"sin",            K_sin},
    {"sinh",           K_sinh},
    {"slew",           K_slew},
    {"split",          K_split},
    {"sqrt",           K_sqrt},
    {"string",         K_string},
    {"tan",            K_tan},
    {"tanh",           K_tanh},
    {"timer",          K_timer},
    {"transition",     K_transition},
    {"units",          K_units},
    {"white_noise",    K_white_noise},
    {"wreal",          K_wreal},
    {"zi_nd",          K_zi_nd},
    {"zi_np",          K_zi_np},
    {"zi_zd",          K_zi_zd},
    {"zi_zp",          K_zi_zp}
};

typedef int compare_function_type(const void *, const void *);

///
/// @param s    source-file string ( {letter}(_?{letter_or_digit})* )
/// @return -1 if is not a VERILOG keyword, VERILOG lexer token otherwise
///
static int getVerilogToken(char * s)
{
    el_mc *pt;

    // VERILOG is case-sensitive
    void * bs = bsearch(s, static_cast<void *>(verilog_tokens), VERILOG_TOKENS_TABLE_LEN,
            sizeof(el_mc), reinterpret_cast<compare_function_type *>(strcmp));

    pt = static_cast<el_mc *>( bs );

    return pt == nullptr ? -1 : pt->kval;
}

///
/// @param s    source-file string ( {letter}(_?{letter_or_digit_or_special})* )
/// @return -1 if is not a VERILOG-AMS keyword, VERILOG-AMS lexer token otherwise
///
static int getVerilogAmsToken(char * s)
{
    int verilogStd = getVerilogToken(s);
    if (verilogStd != -1) return verilogStd;

    el_mc *pt;

    // VERILOG AMS is case-sensitive
    void * bs = bsearch(s, static_cast<void *>(verilog_ams_tokens), VERILOG_AMS_TOKENS_TABLE_LEN,
            sizeof(el_mc), reinterpret_cast<compare_function_type *>(strcmp));

    pt = static_cast<el_mc *>( bs );

    return pt == nullptr ? -1 : pt->kval;
}

%}


/*
 *  DEFINITIONS SECTION
 * ------------------------------------------------------------------------------ */

/* Inclusive Start Conditions */
%s SKIP_TO_EOL
%s DEF
%s UNDEF
%s IFDEFNAME
%s LINENUM
%s LINEFILENAME
%s UDPTABLE

/* Exclusive Start Conditions */
%x INCL
%x DEFBODY
%x IFNDEFNAME
%x MACRO_SKIP
%x CCOMMENT
%x LCOMMENT
%x CSTRING
%x PPTIMESCALE
%x PPDEFAULT_NETTYPE
%x MACRO_EXPANSION

/* %option yylineno */
%option never-interactive

/* Name definitions */
W [ \t\b\f\r]+

%%

 /*
  *  RULES SECTION
  * ---------------------------------------------------------------------------------------- */

<<EOF>>                                 {
    if (pop_buffer()) return 0;
    BEGIN(INITIAL);
    /*BEGIN(SKIP_TO_EOL);*/
}

  <SKIP_TO_EOL>.*$                        { BEGIN(INITIAL); }

\`include                               { BEGIN(INCL); }
<INCL>[ \t\"]*                          { }
<INCL>[^ \"\t\n]+                       { includename=yytext; }
<INCL>\".*$                             {
    if (isStandardInclude(includename))
    {
        /* temporarily disabled
        yylval.text = hif::application_utils::hif_strdup(includename.c_str());
        return STD_LIB_INCLUDE;
        */
    }
    else
    {
        push_buffer( includename.c_str() );
    }
    BEGIN(INITIAL);
}

 /*
  *  Comments management
  * ---------------------------------------------------------------------------------------- */

<MACRO_SKIP,INITIAL>"//".*                                  {
    /* C++ style comments start with / / and run to the end of the
       current line. These are very easy to handle. */
    comment_caller=YY_START;
    BEGIN(LCOMMENT);
}

<LCOMMENT>[^\n]                         { }
<LCOMMENT>\n                            { ++yylineno; yycolumno = 1; BEGIN(comment_caller); };


<MACRO_SKIP,INITIAL>"/*"                                    {
    /* The contents of C-style comments are ignored, like white space. */
    comment_caller=YY_START;
    BEGIN(CCOMMENT);
}

<CCOMMENT>"*/"                          { BEGIN(comment_caller); }
<CCOMMENT>[^\n]                         { }
<CCOMMENT>\n                            { ++yylineno; yycolumno = 1; };


 /*
  *  Macros and ifdef directives management
  * ---------------------------------------------------------------------------------------- */

<DEF,UNDEF,IFDEFNAME,LINENUM,LINEFILENAME>[ \t]*          {}


\`define                                { BEGIN(DEF); }

<DEF>[a-zA-Z_][a-zA-Z0-9_]*+             {
    tmpMacroName = yytext;
    tmpMacroBody = "";
    isMultiLineMacro = false;
    BEGIN(DEFBODY);
}

<DEFBODY>"\n"                    {

    if (!isMultiLineMacro)
    {
        define_macro( tmpMacroName, tmpMacroBody);
        BEGIN(INITIAL);
    }
    ++yylineno;
}

<DEFBODY>.*                     {
    std::string s(yytext);
    s = string_rtrim(s);

    // skip C-style comments
    size_t commentSlashIndex = s.find("//");
    if (commentSlashIndex != std::string::npos)
    {
        s = s.substr(0, commentSlashIndex);
    }

    // remove spaces at the end of line
    s = string_rtrim(s);

    // if the line ends with back-slash the macro is splitted on multiple lines
    if (s.length() > 1 && s.at(s.length()-1) == '\\')
    {
        tmpMacroBody += s.substr(0, s.length() - 2);
        isMultiLineMacro = true;
    }
    else
    {
        tmpMacroBody += s;
        define_macro( tmpMacroName, tmpMacroBody);
        BEGIN(INITIAL);
    }
}


\`undef                                 { BEGIN(UNDEF); }
<UNDEF>[a-zA-Z_][a-zA-Z0-9_]*+          { undef_macro( yytext ); BEGIN(SKIP_TO_EOL); }

\`ifdef                                 { ifcond = 1; BEGIN(IFDEFNAME); }
<IFDEFNAME>[^ \t\n\r\f]+                { if ( ifdef_macro( yytext) ) BEGIN(INITIAL); else BEGIN(MACRO_SKIP); }
\`ifndef                                { ++ifcond; BEGIN(IFNDEFNAME); }
<IFNDEFNAME>[^ \t\n\r\f]+               { if ( ! ifdef_macro( yytext) ) BEGIN(INITIAL); else BEGIN(MACRO_SKIP); }
\`else                                  { ifcond = 1; BEGIN(MACRO_SKIP); }
\`endif                                 { ifcond = 0; }

<MACRO_SKIP>\`ifdef                     { ++ifcond; }
<MACRO_SKIP>\`ifndef                    { ++ifcond; }
<MACRO_SKIP>\`else                      { if ( ifcond == 1 ) BEGIN(INITIAL); }
<MACRO_SKIP>\`elsif                     { if ( ifcond == 1 ) BEGIN(IFDEFNAME); }
<MACRO_SKIP>\`endif                     { if ( (--ifcond) == 0 ) BEGIN(INITIAL); }
<MACRO_SKIP>[^\n]                       {}
<MACRO_SKIP>\n                          { ++yylineno; yycolumno = 1; }

\`resetall                              { resetall_macro(); }

\`line                                  { BEGIN(LINENUM); }
<LINENUM>[^ \t\n\f\r]+                  { yylineno = atoi( yytext ); BEGIN(LINEFILENAME); }
<LINEFILENAME>[^ \t\n\f\r]+             { yymessage( (std::string("Parsing file:") + yytext).c_str() ); BEGIN(SKIP_TO_EOL);}

\`timescale{W}*(1|10|100){W}*(s|ms|us|ns|ps|fs){W}*"/"{W}*(1|10|100){W}*(s|ms|us|ns|ps|fs) {
    parse_timescale(yytext);
    BEGIN(INITIAL);
}

\`unconnected_drive[ \t]+(pull1|pull0)  { yywarning( "Skipping unsupported directive: `unconnected_drive"); }
\`nounconnected_drive                   { yywarning( "Skipping unsupported directive: `nounconnected_drive"); }
\`pragma                                { yywarning( "Skipping unsupported directive: `pragma"); BEGIN(SKIP_TO_EOL); }
\`begin_keywords                        { yywarning( "Skipping unsupported directive: `begin_keywords"); BEGIN(SKIP_TO_EOL); }
\`end_keywords                          { /* nothing to do */ }
\`celldefine                            { yyerror("Unsupported directive: `celldefine"); }
\`endcelldefine                         { yyerror("Unsupported directive: `endcelldefine"); }
\`default_nettype                       { yyerror("Unsupported directive: `default_nettype"); }

\`[a-zA-Z][a-zA-Z0-9_]*                 {
    expand_macro( yytext+1 );
}

\`[a-zA-Z][a-zA-Z0-9_]*("(")       {
    macro_expansion_paren_count = 1;
    macro_expansion_call = yytext;

    BEGIN(MACRO_EXPANSION);
}

<MACRO_EXPANSION>"("               {

    // Count parenthesis in the actual parameters part
    // of the macro call
    macro_expansion_call.append(yytext);
    macro_expansion_paren_count++;
}

<MACRO_EXPANSION>")"               {

    // Count parenthesis in the actual parameters part
    // of the macro call
    macro_expansion_call.append(yytext);
    macro_expansion_paren_count--;

    if (macro_expansion_paren_count == 0)
    {
        expand_parametric_macro( macro_expansion_call );
        macro_expansion_paren_count = 0;
        macro_expansion_call = "";
        BEGIN(INITIAL);
    }
}

<MACRO_EXPANSION>[^\n]                {
    yycolumno += strlen(yytext);
    // collect actual parameters of the macro call
    macro_expansion_call.append(yytext);
}

<MACRO_EXPANSION>\n                   {
    yycolumno = 1;
    ++yylineno;
    macro_expansion_call.append("\n");
}

[ \t\b\f\r]                             { ; }
\n                                      { ++yylineno; yycolumno = 1; }

 /*
  *  Parenthesis
  * ---------------------------------------------------------------------------------------- */

"("                                     { yycolumno++; return K_LPAREN; }
")"                                     { yycolumno++; return K_RPAREN; }
"["                                     { yycolumno++; return K_LBRACKET; }
"]"                                     { yycolumno++; return K_RBRACKET; }
"{"                                     { yycolumno++; return K_LBRACE; }
"}"                                     { yycolumno++; return K_RBRACE; }

 /*
  *  Operators
  * ---------------------------------------------------------------------------------------- */

">"                                     { yycolumno++; return K_GT; }
"<"                                     { yycolumno++; return K_LT; }
"|"                                     { yycolumno++; return K_BAR; }
"&"                                     { yycolumno++; return K_AMPERSAND; }
"%"                                     { yycolumno++; return K_PERC; }
"*"                                     { yycolumno++; return K_STAR; }
"+"                                     { yycolumno++; return K_PLUS; }
"-"                                     { yycolumno++; return K_MINUS; }
"^"                                     { yycolumno++; return K_CAP; }
"@"                                     { yycolumno++; return K_AT; }
"/"                                     { yycolumno++; return K_SLASH; }
"?"                                     { yycolumno++; return K_QUEST; }
":"                                     { yycolumno++; return K_COLON; }
";"                                     { yycolumno++; return K_SEMICOLON; }
"="                                     { yycolumno++; return K_EQ; }
","                                     { yycolumno++; return K_COMMA; }
"."                                     { yycolumno++; return K_DOT; }
"#"                                     { yycolumno++; return K_SHARP; }
"~"                                     { yycolumno++; return K_TILDE; }
"!"                                     { yycolumno++; return K_EXCL; }
"'"                                     { yycolumno++; return K_QUOTE; }

"(*"                                    { yycolumno += 2; return K_PSTAR; }
"*)"                                    { yycolumno += 2; return K_STARP; }
"<<<"                                   { yycolumno += 3; return K_LSS; }
"<<"                                    { yycolumno += 2; return K_LS; }
">>>"                                   { yycolumno += 3; return K_RSS; }
">>"                                    { yycolumno += 2; return K_RS; }
"<="                                    { yycolumno += 2; return K_LE; }
"<+"                                    { yycolumno += 2; return K_CONTRIB; }
">="                                    { yycolumno += 2; return K_GE; }
"=>"                                    { yycolumno += 2; return K_EG; }
"*>"                                    { yycolumno += 2; return K_SG; }
"=="                                    { yycolumno += 2; return K_EQEQ; }
"!=="                                   { yycolumno += 3; return K_CNE; }
"!="                                    { yycolumno += 2; return K_NE; }
"==="                                   { yycolumno += 3; return K_CEQ; }
"||"                                    { yycolumno += 2; return K_LOR; }
"&&&"                                   { yycolumno += 3; return K_TAND; }
"&&"                                    { yycolumno += 2; return K_LAND; }
"~|"                                    { yycolumno += 2; return K_NOR; }
"~^"                                    { yycolumno += 2; return K_NXOR; }
"^~"                                    { yycolumno += 2; return K_NXOR; }
"~&"                                    { yycolumno += 2; return K_NAND; }
"->"                                    { yycolumno += 2; return K_TRIGGER; }
"+:"                                    { yycolumno += 2; return K_PO_POS; }
"-:"                                    { yycolumno += 2; return K_PO_NEG; }
"@*"                                    { yycolumno += 2; return K_ATSTAR; }
"**"                                    { yycolumno += 2; return K_POW; }

"("{W}*"*"{W}*")"                             {
    /* Watch out for the tricky case of (*). Cannot parse this as "(*"
       and ")", but since I know that this is really ( * ), replace it
       with "*" and return that. */
    // return '*';
    return K_PSTARP;
}


L?\"(\\.|[^\"])*\"                      {
    std::string s = yytext;
    s = s.substr(1, s.size() -2);
    yylval.text = hif::application_utils::hif_strdup(s.c_str());
    return STRING;
}

 /*
  *  UDP tables management
  * ---------------------------------------------------------------------------------------- */

<UDPTABLE>\(\?0\)                       { return '_'; }
<UDPTABLE>\(\?1\)                       { return '+'; }
<UDPTABLE>\(\?[xX]\)                    { return '%'; }
<UDPTABLE>\(\?\?\)                      { return '*'; }
<UDPTABLE>\(01\)                        { return 'r'; }
<UDPTABLE>\(0[xX]\)                     { return 'Q'; }
<UDPTABLE>\(b[xX]\)                     { return 'q'; }
<UDPTABLE>\(b0\)                        { return 'f'; /* b0 is 10|00, but only 10 is meaningful */ }
<UDPTABLE>\(b1\)                        { return 'r'; /* b1 is 11|01, but only 01 is meaningful */ }
<UDPTABLE>\(0\?\)                       { return 'P'; }
<UDPTABLE>\(10\)                        { return 'f'; }
<UDPTABLE>\(1[xX]\)                     { return 'M'; }
<UDPTABLE>\(1\?\)                       { return 'N'; }
<UDPTABLE>\([xX]0\)                     { return 'F'; }
<UDPTABLE>\([xX]1\)                     { return 'R'; }
<UDPTABLE>\([xX]\?\)                    { return 'B'; }
<UDPTABLE>[bB]                          { return 'b'; }
<UDPTABLE>[lL]                          { return 'l'; /* IVL extension */ }
<UDPTABLE>[hH]                          { return 'h'; /* IVL extension */ }
<UDPTABLE>[fF]                          { return 'f'; }
<UDPTABLE>[rR]                          { return 'r'; }
<UDPTABLE>[xX]                          { return 'x'; }
<UDPTABLE>[nN]                          { return 'n'; }
<UDPTABLE>[pP]                          { return 'p'; }
<UDPTABLE>[01\?\*\-]                    { return yytext[0]; }

 /*
  *  Keywords and identifiers
  * ---------------------------------------------------------------------------------------- */

[a-zA-Z_][a-zA-Z0-9$_]*                 {

    int rc = -1;

    yycolumno += static_cast<int>(strlen(yytext));

    if ( VerilogParser::isVerilogAms() )
        rc = getVerilogAmsToken( yytext );
    else
        rc = getVerilogToken( yytext );

    if (rc == -1)
    {
#ifdef LEXER_VERBOSE_MODE
    (*debugStream) << "IDENTIFIER: " << yytext << std::endl;
#endif
        yylval.text = hif::application_utils::hif_strdup(yytext);
        return IDENTIFIER;
    }

#ifdef LEXER_VERBOSE_MODE
    (*debugStream) << "KEYWORD: " << yytext << std::endl;
#endif
    yylval.text = nullptr;

    yylval.Keyword_data.line = yylineno;
    yylval.Keyword_data.column = yycolumno;

    return rc;
}


\\[^ \t\b\f\r\n]+   {
    ++yylineno;
    yycolumno += static_cast<int>(strlen(yytext));

    yylval.text = yytext;

#ifdef LEXER_VERBOSE_MODE
    (*debugStream) << "IDENTIFIER: " << yytext << std::endl;
#endif

    return IDENTIFIER;
}

\$([a-zA-Z0-9$_]+)  {

    yycolumno += static_cast<int>(strlen(yytext));

    /*
     * reserved keywords starting with $
     */
    if (strcmp(yytext, "$setuphold") == 0)    return K_Ssetuphold;
    if (strcmp(yytext, "$attribute") == 0)    return K_Sattribute;
    if (strcmp(yytext, "$hold") == 0)         return K_Shold;
    if (strcmp(yytext, "$period") == 0)       return K_Speriod;
    if (strcmp(yytext, "$recovery") == 0)     return K_Srecovery;
    if (strcmp(yytext, "$recrem") == 0)       return K_Srecrem;
    if (strcmp(yytext, "$setup") == 0)        return K_Ssetup;
    if (strcmp(yytext, "$width") == 0)        return K_Swidth;
    if (strcmp(yytext, "$nochange") == 0)     return K_Snochange;
    if (strcmp(yytext, "$fullskew") == 0)     return K_Sfullskew;
    if (strcmp(yytext, "$timeskew") == 0)     return K_Stimeskew;
    if (strcmp(yytext, "$skew") == 0)         return K_Sskew;
    if (strcmp(yytext, "$removal") == 0)      return K_Sremoval;

    yylval.text = hif::application_utils::hif_strdup( yytext);

#ifdef LEXER_VERBOSE_MODE
    (*debugStream) << "SYSTEM_IDENTIFIER: " << yylval.text << std::endl;
#endif

    return SYSTEM_IDENTIFIER;
}

 /*
  *  Numbers
  * ---------------------------------------------------------------------------------------- */

\'[sS]?[dD][ \t]*[0-9xzXZ_\?]*   {

    /* unsized decimal: es 'd12 */

    std::string num(yytext);

    if (num.at(1) == 's' || num.at(1) == 'S')
     yylval.number.sign = true;
    else
     yylval.number.sign = false;

    // Skip the first charactes
    num = num.substr( yylval.number.sign ? 3 : 2 );
    num = string_trim(num);

    // Remove underscores
    num.erase(std::remove(num.begin(), num.end(), '_'), num.end());

    // Replace all occurrences of ? with the dont't care symbol
    std::replace(num.begin(), num.end(), '?', '-');

    yylval.number.type = 'd';
    yylval.number.value = hif::application_utils::hif_strdup(num.c_str());

    #ifdef LEXER_VERBOSE_MODE
    (*debugStream) << "BASED_NUMBER: " << yylval.number.value << std::endl;
    #endif

    yycolumno += static_cast<int>(strlen(yytext));

    return BASED_NUMBER;
}

\'[sS]?[bB][ \t]*[0-1xzXZ_\?]+  {

    /*unsized binary: es 'b1x   */

    std::string num(yytext);

    if (num.at(1) == 's' || num.at(1) == 'S')
        yylval.number.sign = true;
    else
        yylval.number.sign = false;

    // Skip the first charactes
    num = num.substr( yylval.number.sign ? 3 : 2 );
    num = string_trim(num);

    // Remove underscores
    num.erase(std::remove(num.begin(), num.end(), '_'), num.end());

    // Replace all occurrences of ? with the dont't care symbol
    std::replace(num.begin(), num.end(), '?', '-');

    yylval.number.type = 'b';
    yylval.number.value = hif::application_utils::hif_strdup(num.c_str());

#ifdef LEXER_VERBOSE_MODE
    (*debugStream) << "BASED_NUMBER: " << yylval.number.value << std::endl;
#endif

    yycolumno += static_cast<int>(strlen(yytext));

    return BASED_NUMBER;
}

\'[sS]?[oO][ \t]*[0-7xzXZ_\?]+  {

    /* unsized octal: es 'o67 */

    std::string num(yytext);

    if (num.at(1) == 's' || num.at(1) == 'S')
        yylval.number.sign = true;
    else
        yylval.number.sign = false;

    // Skip the first charactes
    num = num.substr( yylval.number.sign ? 3 : 2 );
    num = string_trim(num);

    // Remove underscores
    num.erase(std::remove(num.begin(), num.end(), '_'), num.end());

    // Replace all occurrences of ? with the dont't care symbol
    std::replace(num.begin(), num.end(), '?', '-');

    yylval.number.type = 'o';
    yylval.number.value = hif::application_utils::hif_strdup(num.c_str());

#ifdef LEXER_VERBOSE_MODE
    (*debugStream) << "BASED_NUMBER: " << yylval.number.value << std::endl;
#endif

    yycolumno += static_cast<int>(strlen(yytext));

    return BASED_NUMBER;
}

\'[sS]?[hH][ \t]*[0-9a-fA-FxzXZ_\?]+ {

    /*unsized hex: es 'hb5 */

    std::string num(yytext);

    if (num.at(1) == 's' || num.at(1) == 'S')
        yylval.number.sign = true;
    else
        yylval.number.sign = false;

    // Skip the first charactes
    num = num.substr( yylval.number.sign ? 3 : 2 );
    num = string_trim(num);

    // Remove underscores
    num.erase(std::remove(num.begin(), num.end(), '_'), num.end());

    // Replace all occurrences of ? with the dont't care symbol
    std::replace(num.begin(), num.end(), '?', '-');

    yylval.number.type = 'h';
    yylval.number.value = hif::application_utils::hif_strdup(num.c_str());

#ifdef LEXER_VERBOSE_MODE
    (*debugStream) << "BASED_NUMBER: " << yylval.number.value << std::endl;
#endif

    yycolumno += static_cast<int>(strlen(yytext));

    return BASED_NUMBER;
}

[0-9][0-9_]*    {

    std::string num(yytext);

    // Remove underscores
    num.erase(std::remove(num.begin(), num.end(), '_'), num.end());

    // Set informations about the token
    yylval.number.value = hif::application_utils::hif_strdup(num.c_str());
    yylval.number.sign = false;
    yylval.number.type = 'd';

#ifdef LEXER_VERBOSE_MODE
    (*debugStream) << "DEC_NUMBER: " << yylval.number.value << std::endl;
#endif

    yycolumno += static_cast<int>(strlen(yytext));

    return DEC_NUMBER;
}




[0-9][0-9_]*\.[0-9][0-9_]*([Ee][+-]?[0-9][0-9_]*)?  {

    std::string num(yytext);

    // Remove underscores
    num.erase(std::remove(num.begin(), num.end(), '_'), num.end());

    size_t e_index = num.find("e");
    if (e_index == std::string::npos)
        e_index = num.find("E");

    if (e_index == std::string::npos)
    {
        yylval.realNum.e = false;
        yylval.realNum.value = hif::application_utils::hif_strdup(num.c_str());
        yylval.realNum.exp = nullptr;
    }
    else
    {
        std::string mantissa = num.substr(0, e_index);
        std::string exponent = num.substr(e_index + 1);

        yylval.realNum.e = true;
        yylval.realNum.value = hif::application_utils::hif_strdup(mantissa.c_str());
        yylval.realNum.exp = hif::application_utils::hif_strdup(exponent.c_str());
    }

#ifdef LEXER_VERBOSE_MODE
    if (yylval.realNum.e)
        (*debugStream) << "REAL_TIME: " << yylval.realNum.value << "e" << yylval.realNum.exp << std::endl;
    else
        (*debugStream) << "REAL_TIME: " << yylval.realNum.value << std::endl;
#endif

    yycolumno += static_cast<int>(strlen(yytext));

    return REALTIME;
}

[0-9][0-9_]*(\.[0-9][0-9_]*)?[TGMKkmunpfa] {

    std::string num(yytext);

    yycolumno += static_cast<int>(strlen(yytext));

    yylval.realNum.value = hif::application_utils::hif_strdup(num.substr(0, num.size() - 1).c_str());
    yylval.realNum.e = true;

    char c = num[num.size() - 1];
    switch (c)
    {
        case 'T': yylval.realNum.exp = hif::application_utils::hif_strdup("12"); break;
        case 'G': yylval.realNum.exp = hif::application_utils::hif_strdup("9"); break;
        case 'M': yylval.realNum.exp = hif::application_utils::hif_strdup("6"); break;
        case 'K':
        case 'k': yylval.realNum.exp = hif::application_utils::hif_strdup("3"); break;
        case 'm': yylval.realNum.exp = hif::application_utils::hif_strdup("-3"); break;
        case 'u': yylval.realNum.exp = hif::application_utils::hif_strdup("-6"); break;
        case 'n': yylval.realNum.exp = hif::application_utils::hif_strdup("-9"); break;
        case 'p': yylval.realNum.exp = hif::application_utils::hif_strdup("-12"); break;
        case 'f': yylval.realNum.exp = hif::application_utils::hif_strdup("-15"); break;
        case 'a': yylval.realNum.exp = hif::application_utils::hif_strdup("-18"); break;
        default: messageError("Bad case reached", nullptr, nullptr);
    }

#ifdef LEXER_VERBOSE_MODE
        (*debugStream) << "REAL_TIME: " << yylval.realNum.value << "e" << yylval.realNum.exp << std::endl;
#endif

    return REALTIME;
}

[0-9][0-9_]*[Ee][+-]?[0-9][0-9_]* {

    std::string num(yytext);

    // Remove underscores
    num.erase(std::remove(num.begin(), num.end(), '_'), num.end());

    size_t e_index = num.find("e");
    if (e_index == std::string::npos)
        e_index = num.find("E");

    if (e_index == std::string::npos)
    {
        yylval.realNum.value = hif::application_utils::hif_strdup(num.c_str());
        yylval.realNum.e = false;
    }
    else
    {
        std::string mantissa = num.substr(0, e_index);
        std::string exponent = num.substr(e_index + 1);

        yylval.realNum.value = hif::application_utils::hif_strdup(mantissa.c_str());
        yylval.realNum.e = true;
        yylval.realNum.exp = hif::application_utils::hif_strdup(exponent.c_str());
    }

#ifdef LEXER_VERBOSE_MODE
    if (yylval.realNum.e)
        (*debugStream) << "REAL_TIME: " << yylval.realNum.value << "e" << yylval.realNum.exp << std::endl;
    else
        (*debugStream) << "REAL_TIME: " << yylval.realNum.value << std::endl;
#endif

    yycolumno += static_cast<int>(strlen(yytext));

    return REALTIME;
}



%%

/*

1?\'[bB][01] {
        // TODO
        return SCALAR_CONSTANT;
}


 */

/*
 * The UDP state table needs some slightly different treatment by the
 * lexer. The level characters are normally accepted as other things,
 * so the parser needs to switch my mode when it believes in needs to.
 */
void lex_start_table()
{
    BEGIN(UDPTABLE);
}

void lex_end_table()
{
    BEGIN(INITIAL);
}


int yywrap()
{
    return 1;
}


extern FILE*vl_input;
void reset_lexor()
{

}

#ifdef YY_NUM_RULES
#endif
#ifdef REJECT
#endif
#ifdef INT8_MAX
#endif
#ifdef YY_FLEX_MAJOR_VERSION
#endif
#ifdef INT16_MAX
#endif
#ifdef yy_new_buffer
#endif
#ifdef INT8_MIN
#endif
#ifdef YY_LESS_LINENO
#endif
#ifdef INT16_MIN
#endif
#ifdef yyless
#endif
#ifdef FLEX_BETA
#endif
#ifdef yy_set_bol
#endif
#ifdef YYTABLES_NAME
#endif
#ifdef FLEXINT_H
#endif
#ifdef FLEX_SCANNER
#endif
#ifdef YY_STRUCT_YY_BUFFER_STATE
#endif
#ifdef YY_TYPEDEF_YY_BUFFER_STATE
#endif
#ifdef INT32_MIN
#endif
#ifdef YY_DECL_IS_OURS
#endif
#ifdef UINT32_MAX
#endif
#ifdef yy_set_interactive
#endif
#ifdef YY_STATE_BUF_SIZE
#endif
#ifdef YYSTATE
#endif
#ifdef YY_FLEX_MINOR_VERSION
#endif
#ifdef INT32_MAX
#endif
#ifdef YY_START_STACK_INCR
#endif
#ifdef YY_FLUSH_BUFFER
#endif
#ifdef UINT8_MAX
#endif
#ifdef UINT16_MAX
#endif
#ifdef unput
#endif
#ifdef YY_TYPEDEF_YY_SIZE_T
#endif
#ifdef INT32_MIN
#endif
#ifdef YY_DECL_IS_OURS
#endif
#ifdef UINT32_MAX
#endif
#ifdef yy_set_interactive
#endif
#ifdef YY_STATE_BUF_SIZE
#endif
#ifdef YYSTATE
#endif
#ifdef YY_FLEX_MINOR_VERSION
#endif
#ifdef INT32_MAX
#endif
#ifdef YY_START_STACK_INCR
#endif
#ifdef YY_FLUSH_BUFFER
#endif
#ifdef UINT8_MAX
#endif
#ifdef UINT16_MAX
#endif
#ifdef unput
#endif
#ifdef YY_TYPEDEF_YY_SIZE_T
#endif
#ifdef YY_INT_ALIGNED
#endif
