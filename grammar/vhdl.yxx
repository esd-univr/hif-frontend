/// @file vhdl.yxx
/// @brief
/// Copyright (c) 2024-2025, Electronic Systems Design (ESD) Group,
/// Univeristy of Verona.
/// This file is distributed under the BSD 2-Clause License.
/// See LICENSE.md for details.

%{
#include <iostream>
#include <string.h>

#include <hif/hif.hpp>

// Currently Windows porting of flex does not support headers generation.
// Therefore we have to manually export interesting symbols:
//#include <vhdlLexer.hpp>
extern int yylex();
#include "vhdl2hif/vhdl_support.hpp"
#include "vhdl2hif/vhdl_parser_struct.hpp"
#include "vhdl2hif/vhdl_parser.hpp"

// bison
#define YYENABLE_NLS 0
#define YYLTYPE_IS_TRIVIAL 0
#define YYERROR_VERBOSE 0
// #define YYMAXDEPTH 10000 // default value
// #define YYINITDEPTH 200 // default value

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wmissing-noreturn"
#pragma clang diagnostic ignored "-Wdocumentation"
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wmissing-variable-declarations"
#pragma clang diagnostic ignored "-Wreserved-id-macro"
#pragma clang diagnostic ignored "-Wunused-macros"
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wimplicit-fallthrough"
#pragma clang diagnostic ignored "-Wdeprecated-register"
#pragma clang diagnostic ignored "-Wunreachable-code-break"
#endif

#ifdef __clang__
#pragma GCC diagnostic ignored "-Wconversion"
#pragma GCC diagnostic ignored "-Wstrict-overflow"
#pragma GCC diagnostic ignored "-Wold-style-cast"
#pragma GCC diagnostic ignored "-Wswitch-default"
#pragma GCC diagnostic ignored "-Wzero-as-null-pointer-constant"
#pragma GCC diagnostic ignored "-Wsign-conversion"
#elif defined __GNUC__
#pragma GCC diagnostic ignored "-Wconversion"
#pragma GCC diagnostic ignored "-Wstrict-overflow"
#pragma GCC diagnostic ignored "-Wold-style-cast"
#pragma GCC diagnostic ignored "-Wswitch-default"
#pragma GCC diagnostic ignored "-Wzero-as-null-pointer-constant"
// not mingw
#ifndef _MSC_VER
#pragma GCC diagnostic ignored "-Wsign-conversion"
#pragma GCC diagnostic ignored "-Wlogical-op"
#endif
#else
#pragma warning(disable:4244)
#pragma warning(disable:4127)
#pragma warning(disable:4065)
#pragma warning(disable:4702)
#endif

using namespace hif;

// global variables
bool std_unsigned = 0;
NameTable * name_table = nullptr;
VhdlParser * parserInstance = nullptr;
hif::HifFactory * hif_factory = nullptr;

#define RULE_BREAK_MACRO if (parserInstance->isParseOnly()) break;

%}

%union
{
    char character;
    char* value;
    bool flag;

    keyword_data_t                              Keyword_data;
    identifier_data_t                           Identifier_data;
    concurrent_statement_t *                    concurrent_statement_struct;
    primary_unit_t *                            primary_unit_struct;
    secondary_unit_t *                          secondary_unit_struct;
    library_unit_t *                            library_unit_struct;
    context_item_t *                            context_item_struct;
    binding_indication_t *                      binding_indication_struct;
    architecture_body_t *                       architecture_body_struct;
    constraint_t *                              constraint_struct;
    block_declarative_item_t *                  block_declarative_item_struct;
    block_header_t *                            block_header_struct;
    interface_declaration_t *                   interface_declaration_struct;
    entity_declarative_item_t *                 entity_declarative_item_struct;
    entity_aspect_t *                           entity_aspect_struct;
    configuration_item_t *                      configuration_item_struct;
    component_configuration_t *                 component_configuration_struct;
    component_specification_t *                 component_specification_struct;
    instantiation_list_t *                      instantiation_list_struct;
    block_specification_t *                     block_specification_struct;
    block_configuration_t *                     block_configuration_struct;
    subtype_indication_t *                      subtype_indication_struct;

    // ** PSL **
    vunit_item_t *                              vunit_item_struct;
    assert_directive_t *                        assert_directive_struct;
    verification_directive_t *                  verification_directive_struct;

    std::list<entity_declarative_item_t*> *     entity_declarative_item_struct_list;
    std::list<concurrent_statement_t*> *        concurrent_statement_struct_list;
    std::list<context_item_t*> *                context_item_struct_list;
    std::list<block_declarative_item_t*> *      block_declarative_item_struct_list;
    std::list<interface_declaration_t*> *       interface_declaration_struct_list;
    std::list<configuration_item_t*> *          configuration_item_struct_list;
    // ** PSL **
    std::list<vunit_item_t*> *                  vunit_item_struct_list;

    std::map<hif::Instance*, binding_indication_t*> * component_configuration_map;

    hif::Operator                               hif_operator;
    hif::RangeDirection                        hif_range_direction;
    hif::PortDirection                           hif_port_direction;

    hif::Action *                               action_object;
    hif::Aggregate *                            aggregate_object;
    hif::AggregateAlt *                         aggregatealt_object;
    hif::Alias *                                alias_object;
    hif::Array *                                array_object;
    hif::Assign *                               assign_object;
    hif::Cast *                                 cast_object;
    hif::CompositeType *                        compositetype_object;
    hif::ConstValue *                           constvalue_object;
    hif::Contents *                             contents_object;
    hif::Declaration *                          decl_object;
    hif::DataDeclaration *                      datadecl_object;
    hif::DesignUnit *                           designunit_object;
    hif::Enum *                                 enum_object;
    hif::EnumValue *                            enumvalue_object;
    hif::Expression *                           expression_object;
    hif::Break *                                break_object;
    hif::For *                                  for_object;
    hif::FunctionCall *                         fcall_object;
    hif::FieldReference *                       fieldref_object;
    hif::Generate *                             generate_object;
    hif::Identifier *                           identifier_object;
    hif::IntValue *                             intval_object;
    hif::Instance *                             instance_object;
    hif::Member *                               member_object;
    hif::LibraryDef *                           librarydef_object;
    hif::Object *                               object_object;
    hif::ProcedureCall *                        pcall_object;
    hif::PortAssign *                           portassign_object;
    hif::Range *                                range_object;
    hif::Record *                               record_object;
    hif::Return *                               return_object;
    hif::Scope *                                scope_object;
    hif::Signal *                               signal_object;
    hif::StateTable *                           st_object;
    hif::SubProgram *                           subprogram_object;
    hif::Switch *                               switch_object;
    hif::SwitchAlt *                            switchalt_object;
    hif::TypeDef *                              typedef_object;
    hif::Type *                                 type_object;
    hif::Value *                                value_object;
    hif::View *                                 view_object;
    hif::ViewReference *                        viewref_object;
    hif::Wait *                                 wait_object;
    hif::When *                                 when_object;
    hif::WithAlt *                              withalt_object;

    hif::BList<hif::Action> *                   action_list;
    hif::BList<hif::AggregateAlt> *             aggregatealt_list;
    hif::BList<hif::Assign> *                   assign_list;
    hif::BList<hif::IfAlt> *                    casealt_list;
    hif::BList<hif::Declaration> *              decl_list;
    hif::BList<hif::DataDeclaration> *          datadecl_list;
    hif::BList<hif::Field> *                    field_list;
    hif::BList<hif::FieldReference> *           fieldref_list;
    hif::BList<hif::EnumValue> *                enumvalue_list;
    hif::BList<hif::Library> *                  library_list;
    hif::BList<hif::Identifier> *               identifier_list;
    hif::BList<hif::LibraryDef> *               librarydef_list;
    hif::BList<hif::Object> *                   object_list;
    hif::BList<hif::Parameter> *                param_list;
    hif::BList<hif::PortAssign> *               portassign_list;
    hif::BList<hif::Port> *                     port_list;
    hif::BList<hif::PPAssign> *                 ppassign_list;
    hif::BList<hif::ParameterAssign> *          passign_list;
    hif::BList<hif::Range> *                    range_list;
    hif::BList<hif::Scope> *                    scope_list;
    hif::BList<hif::Signal> *                   signal_list;
    hif::BList<hif::SwitchAlt> *                switchalt_list;
    hif::BList<hif::TPAssign> *                 tpassign_list;
    hif::BList<hif::Value> *                    value_list;
    hif::BList<hif::WithAlt> *                  withalt_list;
    hif::BList<hif::When> *                     when_list;
}

/* -----------------------------------------------------------------------
 *  PSL TOKENS
 * ----------------------------------------------------------------------- */

// FL invariance operators
%right t_ALWAYS
%right t_NEVER
%right t_G
// OBE occurence operators
%left t_A
%left t_E
%left t_AX
%left t_AG
%left t_AF
%left t_EG
%left t_EF
%left t_EX
// boolean implication operators ( -> , <-> )
%right t_BOOLEAN_IMPLICATION
%right t_DOUBLE_BOOLEAN_IMPLICATION
// sequence implication operators
%right t_SEQUENCE_IMPLICATION
%right t_DOUBLE_SEQUENCE_IMPLICATION
// FL bounding operators
%right t_U
%right t_W
%right t_UNTIL
%right t_UNTIL_EXCL
%right t_UNTIL_EXCL_UNDERSCORE
%right t_UNTIL_UNDERSCORE
%right t_BEFORE
%right t_BEFORE_EXCL
%right t_BEFORE_UNDERSCORE
%right t_BEFORE_EXCL_UNDERSCORE
// FL occurence operators
%right t_X_EXCL
%right t_X
%right t_F
%right t_NEXT
%right t_NEXT_EXCL
%right t_NEXT_A
%right t_NEXT_A_EXCL
%right t_NEXT_E
%right t_NEXT_E_EXCL
%right t_NEXT_EVENT
%right t_NEXT_EVENT_EXCL
%right t_NEXT_EVENT_A
%right t_NEXT_EVENT_A_EXCL
%right t_NEXT_EVENT_E
%right t_NEXT_EVENT_E_EXCL
%right t_EVENTUALLY_EXCL
// FL termination operators
%left t_ASYNC_ABORT
%left t_SYNC_ABORT
%left t_ABORT
// Sequence AND operators
%left t_DOUBLE_AND
// Sequence within operator
%left t_WITHIN
// SERE repetition operators
//%left t_SERE_CONSECUTIVE_PLUS
// cloking operator
%left t_AT
// union operator
%left t_UNION

%token<Keyword_data>
t_NONTRANSITIVE
t_VUNIT
t_VPKG
t_VPROP
t_VMODE
t_INHERIT
t_PROPERTY
t_PREV
t_CONST
t_MUTABLE
t_SEQUENCE
t_HDLTYPE
t_CLOCK
t_ASSUME
t_RESTRICT
t_RESTRICT_EXCL
t_COVER
t_FAIRNESS
t_OVERRIDE
t_STRONG
t_FORALL
t_BOOLEAN
t_BIT
t_BITVECTOR
t_NUMERIC
t_STRING
t_DEFAULT
t_FREE
t_STABLE
t_ROSE
t_FELL
t_ENDED
t_INF
t_ISUNKNOWN
t_COUNTONES
t_ONEHOT
t_ONEHOT0
t_NONDET
t_NONDET_VECTOR

%token t_DOUBLE_OPEN_BRACKETS
%token t_DOUBLE_CLOSE_BRACKETS

/*
%right t_BOOLEAN_IMPLICATION            "->"
%right t_DOUBLE_BOOLEAN_IMPLICATION     "<->"
%right t_SEQUENCE_IMPLICATION           "|->"
%right t_DOUBLE_SEQUENCE_IMPLICATION    "|=>"
%left t_DOUBLE_AND                     "&&"
%token t_DOUBLE_OPEN_BRACKETS           "[["
%token t_DOUBLE_CLOSE_BRACKETS          "]]"
 */

/* -----------------------------------------------------------------------
 *  VHDL TOKENS
 * ----------------------------------------------------------------------- */

%nonassoc LOW
%nonassoc MEDIUM1
%nonassoc MEDIUM2
%nonassoc MEDIUM3
%nonassoc HIGH
%nonassoc<Keyword_data> t_ELSE_LOWER
%nonassoc<Keyword_data> t_ELSE
%nonassoc<Keyword_data> t_ELSIF
%nonassoc<Keyword_data> t_ELSIF_SUP
%nonassoc<Keyword_data> t_END

%token<Keyword_data>
t_ACCESS
t_AFTER
t_ALIAS
t_ALL
t_ARCHITECTURE
t_ARRAY
t_ASSERT
t_ATTRIBUTE
t_BEGIN
t_BLOCK
t_BODY
t_BUFFER
t_BUS
t_CASE
t_COMPONENT
t_CONFIGURATION
t_CONSTANT
t_DISCONNECT
t_DOWNTO
t_ENTITY
t_EXIT
t_FILE
t_FOR
t_FUNCTION
t_GENERATE
t_GENERIC
t_GROUP
t_GUARDED
t_IF
t_IMPURE
t_IN
t_INERTIAL
t_INOUT
t_IS
t_LABEL
t_LIBRARY
t_LINKAGE
t_LITERAL
t_LOOP
t_MAP
t_NAND
t_NEW
t_NOR
t_NULL
t_OF
t_ON
t_OPEN
t_OTHERS
t_OUT
t_PACKAGE
t_PORT
t_POSTPONED
t_PROCEDURE
t_PROCESS
t_PROTECTED
t_PURE
t_RANGE
t_RECORD
t_REGISTER
t_REJECT
t_REPORT
t_RETURN
t_ROL
t_ROR
t_SELECT
t_SEVERITY
t_SHARED
t_SIGNAL
t_SUBTYPE
t_THEN
t_TO
t_TRANSPORT
t_TYPE
t_UNAFFECTED
t_UNITS
t_USE
t_VARIABLE
t_WAIT
t_WHEN
t_WHILE
t_WITH

//%right t_UNTIL
//%right t_NEXT

/* VHDL binary operators */
%left t_AND t_OR t_XOR t_XNOR
//%nonassoc t_NAND t_NOR
%nonassoc t_EQSym t_NESym t_LTSym t_LESym t_GTSym t_GESym
%nonassoc t_SLL t_SRL t_SLA t_SRA t_ROL t_ROR
%left t_Plus t_Minus t_Ampersand
%left t_Star t_Slash t_MOD t_REM
%left t_DoubleStar t_ABS
%right t_NOT

/* misc syms */
%token t_Apostrophe
%token t_LeftParen
%token t_RightParen
%token t_LeftBracket
%token t_RightBracket
%token t_LeftBrace
%token t_RightBrace
%token t_Comma
%token t_VarAsgn
%left t_Colon
%left t_Semicolon

%nonassoc t_Arrow
%left t_Bar
%right t_Dot
%token t_Excl

%right NOT_PREC
/* -----------------------------------------------------------------------
 *  END VHDL TOKENS
 * ----------------------------------------------------------------------- */


/* Object representation of tokens */
%token<Identifier_data>                             t_Identifier
%token<Identifier_data>                             t_StringLit
%token<Identifier_data>                             t_BitStringLit
%token<Identifier_data>                             t_OctStringLit
%token<Identifier_data>                             t_HexStringLit
%token<Identifier_data>                             t_BasedLit
%token<value>                                       t_AbstractLit
%token<Identifier_data>                             t_CharacterLit

/* type of non-terminal symbols */
%type<flag>                                         t_IN_opt
%type<value_object>                                 abstract_literal
%type<value_object>                                 actual_designator
%type<portassign_list>                              actual_parameter_part
%type<value_object>                                 actual_part
%type<hif_operator>                                 adding_operator
%type<aggregate_object>                             aggregate
%type<alias_object>                                 alias_declaration
%type<identifier_object>                            alias_designator
%type<value_object>                                 allocator
%type<block_declarative_item_struct_list>           architecture_declarative_part
%type<array_object>                                 array_type_definition
%type<pcall_object>                                 assertion
%type<action_object>                                assertion_statement
%type<st_object>                                    concurrent_assertion_statement
%type<portassign_object>                            association_element
%type<portassign_list>                              association_list
%type<value_object>                                 attribute_name
%type<intval_object>                                based_literal
%type<value_object>                                 bit_string_literal
%type<block_configuration_struct>                   block_configuration
%type<block_configuration_struct>                   block_configuration_opt
%type<block_declarative_item_struct>                block_declarative_item
%type<block_declarative_item_struct_list>           block_declarative_item_list
%type<block_declarative_item_struct_list>           block_declarative_item_list_opt
%type<block_header_struct>                          block_header
%type<decl_list>                                    block_header_generic_part
%type<port_list>                                    block_header_port_part
%type<block_specification_struct>                   block_specification
%type<switch_object>                                case_statement
%type<switchalt_object>                             case_statement_alternative
%type<switchalt_list>                               case_statement_alternative_list
%type<value_object>                                 character_literal
%type<value_object>                                 choice
%type<value_list>                                   choices
%type<designunit_object>                            component_declaration
%type<component_configuration_struct>               component_configuration
%type<instance_object>                              component_instantiation_statement
%type<component_specification_struct>               component_specification
%type<type_object>                                  composite_type_definition
%type<assign_list>                                  concurrent_signal_assignment_statement
%type<value_object>                                 condition_clause condition_clause_opt
%type<assign_list>                                  conditional_signal_assignment
%type<assign_list>                                  conditional_waveforms
%type<when_object>                                  conditional_waveforms_when_else_list
%type<configuration_item_struct>                    configuration_item
%type<component_configuration_struct>               configuration_specification
%type<decl_list>                                    configuration_declarative_item
%type<decl_list>                                    constant_declaration
%type<array_object>                                 constrained_array_definition
%type<context_item_struct>                          context_item
%type<context_item_struct_list>                     context_clause
%type<value_object>                                 decimal_literal
//%type<scope_list>                                   design_file
%type<scope_list>                                   design_unit
%type<identifier_object>                            designator designator_opt
%type<hif_range_direction>                          direction
%type<value_object>                                 discrete_range
%type<aggregatealt_object>                          element_association
%type<aggregatealt_list>                            element_association_list
%type<field_list>                                   element_declaration
%type<field_list>                                   element_declaration_list
%type<type_object>                                  element_subtype_definition
%type<entity_aspect_struct>                         entity_aspect
%type<designunit_object>                            entity_declaration
%type<view_object>                                  entity_header
%type<value_object>                                 expression
%type<value_object>                                 expression_opt
%type<value_object>                                 expression_paren_opt
%type<enumvalue_object>                             enumeration_literal
%type<enumvalue_list>                               enumeration_literal_list
%type<enumvalue_list>                               enumeration_type_definition
%type<break_object>                                 exit_statement
%type<value_object>                                 factor
%type<decl_list>                                    file_declaration
%type<value_object>                                 file_logical_name
%type<value_object>                                 file_open_information
%type<type_object>                                  floating_or_integer_type_definition
%type<value_object>                                 formal_part
%type<typedef_object>                               full_type_declaration
%type<value_object>                                 function_call
%type<tpassign_list>                                generic_map_aspect
%type<tpassign_list>                                generic_map_aspect_opt
%type<generate_object>                              generate_statement
%type<decl_list>                                    generic_clause generic_clause_opt
%type<generate_object>                              generation_scheme
%type<value_object>                                 identifier
%type<identifier_object>                            identifier_colon_opt
%type<identifier_object>                            identifier_opt
%type<identifier_list>                              identifier_list
%type<range_list>                                   index_constraint
%type<range_list>                                   index_constraint_list
%type<range_object>                                 index_subtype_definition
%type<range_list>                                   index_subtype_definition_list
%type<action_object>                                if_statement
%type<casealt_list>                                 if_statement_elseif_list
%type<value_object>                                 index_specification
%type<instantiation_list_struct>                    instantiation_list
%type<viewref_object>                               instantiated_unit
%type<port_list>                                    interface_constant_declaration
%type<decl_list>                                    interface_file_declaration
%type<port_list>                                    interface_signal_declaration
%type<port_list>                                    interface_variable_declaration
%type<action_object>                                iteration_scheme
%type<action_object>                                iteration_scheme_opt
%type<library_list>                                 library_clause
%type<value_object>                                 literal
%type<identifier_object>                            logical_name
%type<identifier_list>                              logical_name_list
%type<action_object>                                loop_statement
%type<hif_port_direction>                           mode
%type<hif_port_direction>                           mode_opt
%type<hif_operator>                                 multiplying_operator
%type<value_object>                                 name
%type<value_object>                                 name_internal_simple
%type<value_list>                                   name_list
%type<action_object>                                next_statement
%type<action_object>                                null_statement
%type<value_object>                                 numeric_literal
%type<librarydef_object>                            package_body
%type<librarydef_object>                            package_declaration
%type<decl_list>                                    package_body_declarative_item
%type<decl_list>                                    package_body_declarative_part
%type<decl_list>                                    package_declarative_item
%type<decl_list>                                    package_declarative_part
%type<for_object>                                   parameter_specification
%type<type_object>                                  physical_type_definition
%type<port_list>                                    port_clause port_clause_opt
%type<port_list>                                    port_list
%type<portassign_list>                              port_map_aspect
%type<portassign_list>                              port_map_aspect_opt
%type<value_object>                                 primary
%type<pcall_object>                                 procedure_call
%type<pcall_object>                                 procedure_call_statement
%type<decl_list>                                    process_declarative_item
%type<decl_list>                                    process_declarative_part
%type<st_object>                                    process_statement
%type<action_list>                                  process_statement_part
%type<cast_object>                                  qualified_expression
%type<range_object>                                 range hdl_psl_range
%type<range_object>                                 range_constraint
%type<record_object>                                record_type_definition
%type<value_object>                                 relation
%type<hif_operator>                                 relational_operator
%type<action_object>                                report_statement
%type<return_object>                                return_statement
%type<type_object>                                  scalar_type_definition
%type<fieldref_object>                              selected_name
%type<fieldref_list>                                selected_name_list
%type<assign_object>                                selected_signal_assignment
%type<withalt_list>                                 selected_waveforms
%type<withalt_object>                               selected_waveforms_when
%type<value_list>                                   sensitivity_clause sensitivity_clause_opt
%type<value_list>                                   sensitivity_list
%type<value_list>                                   sensitivity_list_paren_opt
%type<action_list>                                  sequence_of_statements
%type<action_list>                                  sequential_statement
%type<value_object>                                 shift_expression
%type<hif_operator>                                 shift_operator
%type<hif_operator>                                 sign
%type<assign_list>                                  signal_assignment_statement
%type<decl_list>                                    signal_declaration
%type<value_object>                                 simple_expression
%type<value_object>                                 simple_expression_support
%type<value_object>                                 string_literal operator_symbol
%type<decl_object>                                  subprogram_body
%type<decl_object>                                  subprogram_declaration
%type<decl_list>                                    subprogram_declarative_item
%type<decl_list>                                    subprogram_declarative_part
%type<subprogram_object>                            subprogram_specification
%type<action_list>                                  subprogram_statement_part
%type<typedef_object>                               subtype_declaration
%type<value_object>                                 suffix
%type<value_object>                                 target
%type<value_object>                                 term
%type<value_object>                                 timeout_clause timeout_clause_opt
%type<typedef_object>                               type_declaration
%type<type_object>                                  type_definition
%type<type_object>                                  file_type_definition
%type<array_object>                                 unconstrained_array_definition
%type<library_list>                                 use_clause
%type<library_list>                                 use_clause_list
%type<assign_object>                                variable_assignment_statement
%type<decl_list>                                    variable_declaration
%type<action_object>                                wait_statement
%type<assign_list>                                  waveform
%type<assign_list>                                  waveform_element_list
%type<assign_object>                                waveform_element

/* structs */
%type<architecture_body_struct>                     architecture_body
%type<binding_indication_struct>                    binding_indication
%type<binding_indication_struct>                    binding_indication_semicolon_opt
%type<view_object>                                  block_statement
%type<concurrent_statement_struct>                  concurrent_statement
%type<concurrent_statement_struct_list>             concurrent_statement_list
%type<configuration_item_struct_list>               configuration_item_list
%type<constraint_struct>                            constraint
%type<entity_declarative_item_struct>               entity_declarative_item
%type<entity_declarative_item_struct_list>          entity_declarative_part
%type<interface_declaration_struct_list>            formal_parameter_list
%type<interface_declaration_struct_list>            formal_parameter_list_paren_opt
%type<interface_declaration_struct_list>            generic_list
%type<interface_declaration_struct>                 interface_declaration
%type<interface_declaration_struct>                 interface_element
%type<interface_declaration_struct_list>            interface_list
%type<library_unit_struct>                          library_unit
%type<primary_unit_struct>                          primary_unit
%type<secondary_unit_struct>                        secondary_unit
%type<subtype_indication_struct>                    subtype_indication subtype_indication_ext
%type<subtype_indication_struct>                    subtype_indication_colon_opt


// PSL non-terminal symbols
%type<hif_operator>                                 and_or_property_op
%type<hif_operator>                                 AND_OP OR_OP

%type<block_declarative_item_struct>                HDL_DECL
%type<concurrent_statement_struct>                  HDL_STMT
%type<action_list>                                  HDL_SEQ_STMT
%type<type_object>                                  HDL_VARIABLE_TYPE
%type<value_object>                                 hdl_or_psl_expression

%type<assert_directive_struct>                      assert_directive
%type<viewref_object>                               binding_spec
%type<value_object>                                 built_in_function_call
%type<value_object>                                 clock_expression
%type<viewref_object>                               context_spec
%type<viewref_object>                               hdl_module_name
%type<range_object>                                 index_range
%type<value_object>                                 low_bound high_bound
%type<verification_directive_struct>                psl_directive
%type<range_object>                                 range_psl
%type<value_object>                                 string
%type<value_object>                                 value_range value
%type<value_list>                                   value_range_list
%type<value_list>                                   value_set
%type<verification_directive_struct>                verification_directive

%type<value_object>                                 property fl_property
%type<value_object>                                 actual_parameter
%type<value_list>                                   actual_parameter_list
%type<vunit_item_struct>                            vunit_item
%type<vunit_item_struct_list>                       vunit_item_list
%type<value_object>                                 sequence
%type<value_object>                                 sequence_instance

%verbose

%parse-param {VhdlParser * parser}

%initial-action
{
    hif_factory = new hif::HifFactory();
    parserInstance = parser;
}
%%

/*
 * Start rule for VHDL-only
 * --------------------------------------------------------------------- */
//start:
//design_file
//{
//    yydebug("start : design_file.");
//    delete parserInstance;
//    delete hif_factory;
//};


/*
 * Start rule for VHDL and PSL
 * --------------------------------------------------------------------- */
start:
design_psl_mixed_file
{
    yydebug("start : design_psl_mixed_file.");
    delete hif_factory;
};


design_psl_mixed_file:
design_psl_mixed_item
{
    yydebug("design_psl_mixed_file: design_psl_mixed_item");
}
| design_psl_mixed_file design_psl_mixed_item
{
    yydebug("design_psl_mixed_file: design_psl_mixed_file design_psl_mixed_item");
};

design_psl_mixed_item:
design_unit
{
    yydebug("design_psl_mixed_item: design_unit");
    parserInstance->setGlobalScope(true);
}
| verification_unit
{
    yydebug("design_psl_mixed_item: verification_unit");
    parserInstance->setGlobalScope(true);
    parserInstance->setContextVhdl();
};


/* **************************************************************************************************** */
/* STANDARD RULES from 1076-2002 (In alphabetical order)
/* **************************************************************************************************** */

abstract_literal:
decimal_literal
{
    yydebug("abstract_literal: decimal_literal.");
    RULE_BREAK_MACRO $$ = $1;
}
| based_literal
{
    yydebug("abstract_literal: based_literal.");
    RULE_BREAK_MACRO $$ = $1;
};

access_type_definition:
t_ACCESS subtype_indication
{
    yydebug("access_type_definition: t_ACCESS subtype_indication.");
    yyerror("access_type_definition: t_ACCESS subtype_indication is not supported.");
};

actual_designator:
discrete_range
{
    yydebug("actual_designator: discrete_range.");
    RULE_BREAK_MACRO $$ = $1;
}
// Removed: a name is part of an expression
//| name
| t_OPEN
{
    yydebug("actual_designator: t_OPEN.");
    RULE_BREAK_MACRO $$ = nullptr;
};

actual_parameter_part:
/*parameter_*/ association_list
{
    yydebug("actual_parameter_part: association_list.");
    RULE_BREAK_MACRO $$ = $1;
};


/* actual_designator is an expression, so name ( actual designator ) is just a subcase */
actual_part:
actual_designator
{
    yydebug("actual_part: actual_designator");
    RULE_BREAK_MACRO $$ = $1;
}
/*
    function_name t_LeftParen actual_designator t_RightParen
    type_mark t_LeftParen actual_designator t_RightParen
*/
/*
| name t_LeftParen actual_designator t_RightParen
{
    yydebug("actual_part: name t_LeftParen actual_designator t_RightParen.");
    yyerror("actual_part: name t_LeftParen actual_designator t_RightParen.");
}
*/
;


adding_operator:
t_Plus
{
    yydebug("adding_operator: t_Plus.");
    RULE_BREAK_MACRO $$ = op_plus;
}
| t_Minus
{
    yydebug("adding_operator: t_Minus.");
    RULE_BREAK_MACRO $$ = op_minus;
}
| t_Ampersand
{
    yydebug("adding_operator: t_Ampersand.");
    RULE_BREAK_MACRO $$ = op_concat;
};


aggregate:
t_LeftParen element_association_list t_RightParen
{
    yydebug("aggregate: t_LeftParen element_association_list t_RightParen.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_Aggregate( $2 );
};

alias_declaration:
t_ALIAS alias_designator subtype_indication_colon_opt t_IS name signature_opt t_Semicolon
{
    yydebug("alias_declaration: t_ALIAS alias_designator subtype_indication_colon_opt "
            "t_IS name signature_opt t_Semicolon.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_AliasDeclaration( $2, $3, $5 );
};

alias_designator:
identifier
{
    yydebug("alias_designator: identifier.");
    RULE_BREAK_MACRO
    Identifier * ret = dynamic_cast< Identifier* >( $1 );
    assert( ret != nullptr );
    $$ = ret;
}
| character_literal
{
    yydebug("alias_designator: character_literal.");
    yyerror("alias_designator: character_literal is not supported.");
}
| operator_symbol
{
    yydebug("alias_designator: operator_symbol.");
    yyerror("alias_designator: operator_symbol is not supported.");
};

allocator:
t_NEW subtype_indication
{
    yydebug("allocator: t_NEW subtype_indication.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_Allocator($2);
}
| t_NEW qualified_expression
{
    yydebug("allocator: t_NEW qualified_expression.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_Allocator($2);
};

architecture_body:
t_ARCHITECTURE /*2*/ identifier t_OF /*4 entity_*/ name t_IS
/*6*/ architecture_declarative_part
t_BEGIN
/*8*/ concurrent_statement_list
t_END t_ARCHITECTURE_opt /*11 architecture_*/ identifier_opt t_Semicolon
{
    yydebug("t_ARCHITECTURE identifier t_OF name t_IS architecture_declarative_part "
            "t_BEGIN concurrent_statement_list t_END t_ARCHITECTURE_opt "
            "identifier t_Semicolon.");

    RULE_BREAK_MACRO
    parserInstance->setCurrentBlockCodeInfo($1);
    $$ = parserInstance->parse_ArchitectureBody($2, $4, $6, $8);
    delete $11;
};


architecture_declarative_part:
block_declarative_item_list
{
    yydebug("architecture_declarative_part: block_declarative_item_list.");
    RULE_BREAK_MACRO $$ = $1;
};

array_type_definition:
unconstrained_array_definition
{
    yydebug("array_type_definition: unconstrained_array_definition.");
    RULE_BREAK_MACRO $$ = $1;
}
| constrained_array_definition
{
    yydebug("array_type_definition: constrained_array_definition.");
    RULE_BREAK_MACRO $$ = $1;
};

assertion:
//t_ASSERT /* condition */ expression t_REPORT /* expression */ string_literal t_SEVERITY expression %prec HIGH
//{
//    yydebug("assertion: t_ASSERT /* condition */ expression t_REPORT expression t_SEVERITY expression.");
//    yywarning("Assertions are not supported. Skipping them.");
//    delete $2;
//    delete $4;
//    delete $6;
//    $$ = nullptr;
//}
//| t_ASSERT /* condition */ expression t_REPORT /* expression */ string_literal %prec MEDIUM2
//{
//    yydebug("assertion: t_ASSERT /* condition */ expression t_REPORT expression.");
//    yywarning("Assertions are not supported. Skipping them.");
//    delete $2;
//    delete $4;
//    $$ = nullptr;
//}
//| t_ASSERT /* condition */ expression t_SEVERITY expression %prec MEDIUM1
//{
//    yydebug("assertion: t_ASSERT /* condition */ expression t_SEVERITY expression.");
//    yywarning("Assertions are not supported. Skipping them.");
//    delete $2;
//    delete $4;
//    $$ = nullptr;
//}
//| t_ASSERT /* condition */ expression %prec LOW
//{
//    yydebug("assertion: t_ASSERT condition.");
//    yywarning("Assertions are not supported. Skipping them.");
//    delete $2;
//    $$ = nullptr;
//};
//
// *** From PSL-grammar ***
// NOTE: assert_directive includes the ending semicolon, so to undo this modification you
// have also to fix the rule 'assertion_statement'.
//
//
assert_directive
{
    yydebug("assertion: assert_directive.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_Assertion( $1 );
};


assertion_statement:
// See NOTE at rule 'assertion'
//assertion t_Semicolon
assertion
{
    yydebug("assertion_statement: assertion");
    RULE_BREAK_MACRO $$ = $1;
};

association_element:
formal_part t_Arrow actual_part
{
    yydebug("association_element: formal_part t_Arrow actual_part.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_AssociationElement( $1, $3 );
}
| actual_part
{
    yydebug("association_element: actual_part.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_AssociationElement( $1 );
};


association_list:
association_list t_Comma association_element
{
    yydebug("association_list: association_list t_Comma association_element.");
    RULE_BREAK_MACRO
    $$ = $1;
    $$->push_back( $3 );
}
| association_element
{
    yydebug("association_list: association_element.");
    RULE_BREAK_MACRO
    $$ = new BList<PortAssign>();
    $$->push_back( $1 );
};

attribute_declaration:
t_ATTRIBUTE identifier t_Colon name t_Semicolon
{
    yydebug("attribute_declaration: t_ATTRIBUTE identifier t_Colon name t_Semicolon.");
    yywarning("Attribute declarations are skipped.");
    delete $2;
    delete $4;
};

//attribute_designator:
///*attribute_*/ identifier
//{
//    yydebug("attribute_designator: identifier.");
//    $$ = $1;
//};




attribute_name:
name t_Apostrophe identifier
{
    yydebug("attribute_name: name t_Apostrophe identifier.");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AttributeName( $1, $3 );
    parserInstance->setCodeInfo( $$ );
}
| name t_Apostrophe identifier t_LeftParen expression t_RightParen
{
    yydebug("attribute_name: name t_Apostrophe identifier.");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AttributeName( $1, $3, $5 );
    parserInstance->setCodeInfo( $$ );
}
//
// @NOTSTANDARD : The lexer recognizes "range" as a token
// Added a specific production to handle this case
//
| name t_Apostrophe t_RANGE
{
    yydebug("attribute_name: name t_Apostrophe t_RANGE.");
    RULE_BREAK_MACRO
    Identifier * range_id = new Identifier();
    range_id->setName( "range" );
    $$ = parserInstance->parse_AttributeName( $1, range_id );
};


attribute_specification:
t_ATTRIBUTE identifier t_OF entity_specification t_IS expression t_Semicolon
{
    yydebug("attribute_specification: t_ATTRIBUTE identifier t_OF entity_specification t_IS expression t_Semicolon.");
    yywarning("Attribute specifications are skipped.");
    delete $2;
    //delete $4;
    delete $6;
};

/* @TODO Check if this is useful.
base ::= integer

base_specifier ::= B | O | X

based_integer:
extended_digit { [ underline ] extended_digit }

*/



based_literal:
/* base # based_integer [ . based_integer ] # [ exponent ]
 */
t_BasedLit
{
    yydebug("based_literal: t_BasedLit.");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_BasedLiteral( $1.name );
    free( $1.name );
};

/* WARNING: defined in the standard, but useless.
basic_character:
t_CharacterLit
{
// basic_graphic_character | format_effector
    yydebug("basic_character: t_CharacterLit.");
    $$ = character_literal_to_value( $1.name )
    parserInstance->setCodeInfo( $$ );
    free( $1.name );
};
*/


/* @TODO Check usefulness.
basic_graphic_character:
upper_case_letter | digit | special_character| space_character

basic_identifier: letter { [ underline ] letter_or_digit }
*/

binding_indication:
/* empty */
{
    yydebug("binding_indication: empty.");
    RULE_BREAK_MACRO $$ = nullptr;
}
| t_USE entity_aspect generic_map_aspect port_map_aspect
{
    yydebug("binding_indication: t_USE entity_aspect generic_map_aspect port_map_aspect.");
    yyerror("binding_indication: t_USE entity_aspect generic_map_aspect port_map_aspect.");
}
| t_USE entity_aspect generic_map_aspect
{
    yydebug("binding_indication: t_USE entity_aspect generic_map_aspect.");
    yyerror("binding_indication: t_USE entity_aspect generic_map_aspect.");
}
| t_USE entity_aspect port_map_aspect
{
    yydebug("binding_indication: t_USE entity_aspect port_map_aspect.");
    yyerror("binding_indication: t_USE entity_aspect port_map_aspect is not supported.");
}
| t_USE entity_aspect
{
    yydebug("binding_indication: t_USE entity_aspect.");
    RULE_BREAK_MACRO
    $$ = new binding_indication_t();
    $$->entity_aspect = *$2;
    delete $2;
}
| generic_map_aspect port_map_aspect
{
    yydebug("binding_indication: generic_map_aspect port_map_aspect.");
    yyerror("binding_indication: generic_map_aspect port_map_aspect is not supported.");
//    $$ = new binding_indication_t();
//    $$->generic_map_aspect = $1;
//    $$->port_map_aspect = $2;
}
| generic_map_aspect
{
    yydebug("binding_indication: generic_map_aspect.");
    yyerror("binding_indication: generic_map_aspect is not supported.");
//    $$ = new binding_indication_t();
//    $$->generic_map_aspect = $1;
}
| port_map_aspect
{
    yydebug("binding_indication: port_map_aspect.");
    yyerror("binding_indication: port_map_aspect is not supported.");
//    $$ = new binding_indication_t();
//    $$->port_map_aspect = $1;
};

binding_indication_semicolon_opt:
/*empty*/
{
    yydebug("binding_indication_semicolon_opt: empty.");
    yyerror("binding_indication_semicolon_opt: empty is not supported.");
}
| binding_indication t_Semicolon
{
    yydebug("binding_indication_semicolon_opt: binding_indication t_Semicolon.");
    RULE_BREAK_MACRO $$ = $1;
};


bit_string_literal:
/*base_specifier " [ bit_value ] "*/
t_BitStringLit
{
    yydebug("bit_string_literal: t_BitStringLit.");

    RULE_BREAK_MACRO $$ = parserInstance->parse_BitStringLiteral( $1 );
    
    std::string name( $1.name );
    std::string::size_type i;

    while ( (i = name.find( '"' )) != std::string::npos )
        name.erase( i, 1 );

    while ( (i = name.find( 'B' )) != std::string::npos )
        name.erase( i, 1 );

    while ( (i = name.find( 'b' )) != std::string::npos )
        name.erase( i, 1 );

    // FROM STANDARD :
    // "An underline character inserted between adjacent digits
    // of a bit string literal does not affect the value of this literal."
    while ( (i = name.find( '_' )) != std::string::npos )
        name.erase( i, 1 );

    $$ = new BitvectorValue( name );
    parserInstance->setCodeInfo( $$ );
    free( $1.name );
}
| t_OctStringLit
{
    yydebug("bit_string_literal: t_OctStringLit.");
    RULE_BREAK_MACRO
    $$ = new BitvectorValue( toBits( $1.name, 8 ) );
    parserInstance->setCodeInfo( $$ );
    free( $1.name );
}
| t_HexStringLit
{
    yydebug("bit_string_literal: t_HexStringLit.");
    RULE_BREAK_MACRO
    $$ = new BitvectorValue( toBits( $1.name, 16 ) );
    parserInstance->setCodeInfo( $$ );
    free( $1.name );
};


/* @TODO check its usefulness.
bit_value ::= extended_digit { [ underline ] extended_digit }
*/


block_configuration:
t_FOR block_specification use_clause_list configuration_item_list t_END t_FOR t_Semicolon
{
    yydebug("block_configuration: t_FOR block_specification use_clause_list configuration_item_list t_END t_FOR t_Semicolon.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_BlockConfiguration( $2, $3, $4 );
};

block_configuration_opt:
/* empty */
{
    yydebug("block_configuration_opt: empty.");
    RULE_BREAK_MACRO $$ = nullptr;
}
| block_configuration
{
    yydebug("block_configuration_opt: block_configuration.");
    RULE_BREAK_MACRO $$ = $1;
};


block_declarative_item:
subprogram_declaration
{
    yydebug("block_declarative_item: subprogram_declaration.");
    RULE_BREAK_MACRO
    $$ = new block_declarative_item_t();
    $$->declarations = new BList<Declaration>();
    $$->declarations->push_back( $1 );
}
| subprogram_body
{
    yydebug("block_declarative_item: subprogram_body.");
    RULE_BREAK_MACRO
    $$ = new block_declarative_item_t();
    $$->declarations = new BList<Declaration>();
    $$->declarations->push_back( $1 );
}
| type_declaration
{
    yydebug("block_declarative_item: type_declaration.");
    RULE_BREAK_MACRO
    $$ = new block_declarative_item_t();
    $$->declarations = new BList<Declaration>();
    $$->declarations->push_back( $1 );
}
| subtype_declaration
{
    yydebug("block_declarative_item: subtype_declaration.");
    RULE_BREAK_MACRO
    $$ = new block_declarative_item_t();
    $$->declarations = new BList<Declaration>();
    $$->declarations->push_back( $1 );
}
| constant_declaration
{
    yydebug("block_declarative_item: constant_declaration.");
    RULE_BREAK_MACRO
    $$ = new block_declarative_item_t();
    $$->declarations = $1;
}
| signal_declaration
{
    yydebug("block_declarative_item: signal_declaration.");
    RULE_BREAK_MACRO
    $$ = new block_declarative_item_t();
    $$->declarations = $1;
}
| /* shared_*/ variable_declaration
{
    yydebug("block_declarative_item: variable_declaration.");
    RULE_BREAK_MACRO
    $$ = new block_declarative_item_t();
    $$->declarations = $1;
}
| file_declaration
{
    yydebug("block_declarative_item: file_declaration.");
    yyerror("block_declarative_item: file_declaration is not supported.");
}
| alias_declaration
{
    yydebug("block_declarative_item: alias_declaration.");
    RULE_BREAK_MACRO
    $$ = new block_declarative_item_t();
    $$->declarations = new BList<Declaration>();
    $$->declarations->push_back( $1 );
}
| component_declaration
{
    yydebug("block_declarative_item: component_declaration.");
    RULE_BREAK_MACRO
    $$ = new block_declarative_item_t();
    $$->component_declaration = $1;
}
| attribute_declaration
{
    yydebug("block_declarative_item: attribute_declaration.");
    RULE_BREAK_MACRO
    $$ = new block_declarative_item_t();
    $$->isSkipped = true;
}
| attribute_specification
{
    yydebug("block_declarative_item: attribute_specification.");
    RULE_BREAK_MACRO
    $$ = new block_declarative_item_t();
    $$->isSkipped = true;
}
| configuration_specification
{
    yydebug("block_declarative_item: configuration_specification.");
    RULE_BREAK_MACRO
    $$ = new block_declarative_item_t();
    $$->configuration_specification = $1;
}
| disconnection_specification
{
    yydebug("block_declarative_item: disconnection_specification.");
    yyerror("block_declarative_item: disconnection_specification is not supported.");
}
| use_clause
{
    yydebug("block_declarative_item: use_clause.");
    RULE_BREAK_MACRO
    $$ = new block_declarative_item_t();
    $$->use_clause = $1;
}
| group_template_declaration
{
    yydebug("block_declarative_item: group_template_declaration.");
    yyerror("block_declarative_item: group_template_declaration is not supported.");
}
| group_declaration
{
    yydebug("block_declarative_item: group_declaration.");
    yyerror("block_declarative_item: group_declaration is nto supported.");
};


block_declarative_item_list:
/* empty */
{
    yydebug("block_declarative_item_list: empty.");
    RULE_BREAK_MACRO $$ = new std::list<block_declarative_item_t*>();
}
| block_declarative_item_list block_declarative_item
{
    yydebug("block_declarative_item_list: block_declarative_item_list block_declarative_item.");
    RULE_BREAK_MACRO
    $$ = $1;
    $$->push_back( $2 );
};


block_header:
block_header_generic_part block_header_port_part
{
    yydebug("block_header: block_header_generic_part block_header_port_part.");
    RULE_BREAK_MACRO
    $$ = new block_header_t();
    $$->block_header_generic_part = $1;
    $$->block_header_port_part = $2;
};


block_header_generic_part:
/* empty */
{
    yydebug("block_header_generic_part: empty.");
    RULE_BREAK_MACRO $$ = nullptr;
}
| generic_clause generic_map_aspect t_Semicolon %prec HIGH
{
    yydebug("block_header_generic_part: generic_clause generic_map_aspect.");
    yyerror("block_header_generic_part: generic_clause generic_map_aspect is not supported.");
}
| generic_clause %prec LOW
{
    yydebug("block_header_generic_part: generic_clause is not supported.");
    RULE_BREAK_MACRO $$ = $1;
};

block_header_port_part:
/* empty */
{
    yydebug("block_header_port_part: empty.");
    RULE_BREAK_MACRO $$ = nullptr;
}
| port_clause port_map_aspect t_Semicolon
{
    yydebug("block_header_port_part: port_clause port_map_aspect t_Semicolon.");
    yyerror("block_header_port_part: port_clause port_map_aspect is not supported.");
}
| port_clause
{
    yydebug("block_header_port_part: port_clause.");
    RULE_BREAK_MACRO $$ = $1;
};


block_specification:
/*generate_statement_ */ identifier t_LeftParen index_specification t_RightParen %prec HIGH
{
   yydebug("block_specification: identifier t_LeftParen index_specification t_RightParen.");
   yyerror("block_specification: identifier t_LeftParen index_specification t_RightParen is not supported.");
}
// | /* architecture_ */ name %prec LOW
| /* architecture_ */ identifier %prec LOW
{
    yydebug("block_specification: /* architecture_ */ identifier.");
    RULE_BREAK_MACRO

    $$ = new block_specification_t();
    Identifier * arch_name = dynamic_cast<Identifier*>( $1 );
    if ( arch_name == nullptr )
    {
        yyerror("block_specification: /* architecture_ */ identifier. Invalid architecture name");
    }

    $$->block_name = arch_name;
}
/*Duplicated into name: */
/*
| label
{
    // block_statement_ | generate_statement_
    yydebug("block_specification: label.");
    $$ = $1;
} */
;


block_statement:
/* block_ */ identifier t_Colon t_BLOCK
expression_paren_opt t_IS_opt
block_header block_declarative_item_list
t_BEGIN
concurrent_statement_list
t_END t_BLOCK /* block_ */ identifier_opt t_Semicolon
{
    yydebug("block_statement: identifier t_Colon t_BLOCK expression_paren_opt t_IS_opt block_header "
            "block_declarative_item_list t_BEGIN concurrent_statement_list t_END t_BLOCK identifier_opt t_Semicolon.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_BlockStatement( $1, $4, $6, $7, $9 );
};


case_statement:
t_CASE /*3*/ expression t_IS
/*5*/ case_statement_alternative_list
t_END t_CASE /*8 case_*/ identifier_opt t_Semicolon
{
    yydebug("case_statement: /*case_*/ t_CASE expression t_IS case_statement_alternative_list t_END t_CASE /* case_*/ identifier_opt t_Semicolon.");
    RULE_BREAK_MACRO
    parserInstance->setCurrentBlockCodeInfo( $1 );
    $$ = parserInstance->parse_CaseStatement($2, $4);
    delete $7;
};

case_statement_alternative:
t_WHEN choices t_Arrow sequence_of_statements
{
    yydebug("case_statement_alternative: t_WHEN choices t_Arrow sequence_of_statements.");
    parserInstance->setCurrentBlockCodeInfo( $1 );
    RULE_BREAK_MACRO $$ = parserInstance->parse_CaseStatementAlternative( $2, $4 );
};


case_statement_alternative_list:
case_statement_alternative_list case_statement_alternative
{
    yydebug("case_statement_alternative_list: case_statement_alternative_list case_statement_alternative.");
    RULE_BREAK_MACRO
    $$ = $1;
    $$->push_back( $2 );
}
| case_statement_alternative
{
    yydebug("case_statement_alternative_list: case_statement_alternative.");
    RULE_BREAK_MACRO
    $$ = new BList<SwitchAlt>();
    $$->push_back( $1 );
};



character_literal:
t_CharacterLit
{
    yydebug("character_literal: t_CharacterLit.");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_CharacterLiteral( $1.name );
    free( $1.name );
};


choice:
discrete_range
{
    yydebug("choice: discrete_range.");
    RULE_BREAK_MACRO $$ = $1;
}
| t_OTHERS
{
    yydebug("choice: t_OTHERS.");
    RULE_BREAK_MACRO
    $$ = new Identifier( "HIF_OTHERS" );
    parserInstance->setCodeInfo( $$ );
};

choices:
choice
{
    yydebug("choices: choice.");
    RULE_BREAK_MACRO
    $$ = new BList<Value>();
    $$->push_back( $1 );
}
| choices t_Bar choice
{
    yydebug("choices: choices t_Bar choice.");
    RULE_BREAK_MACRO
    $$ = $1;
    $$->push_back( $3 );
};



component_configuration:
t_FOR component_specification
binding_indication_semicolon_opt
block_configuration_opt
t_END t_FOR t_Semicolon
{
    yydebug("component_configuration: t_FOR component_specification "
            "binding_indication_semicolon_opt block_configuration_opt "
            "t_END t_FOR t_Semicolon.");

    RULE_BREAK_MACRO $$ = parserInstance->parse_ComponentConfiguration( $2, $3, $4 );
};

component_declaration:
t_COMPONENT identifier t_IS_opt
/*local_*/ generic_clause_opt
/*local_*/ port_clause_opt
t_END t_COMPONENT /*component_*/ identifier_opt t_Semicolon
{
    yydebug("t_COMPONENT identifier t_IS_opt generic_clause_opt port_clause_opt "
            "t_END t_COMPONENT identifier_opt t_Semicolon.");

    RULE_BREAK_MACRO
    parserInstance->setCurrentBlockCodeInfo($1);
    $$ = parserInstance->parse_ComponentDeclaration( $2, $4, $5 );

    delete $8;
};

component_instantiation_statement:
/*instantiation_*/ identifier t_Colon
instantiated_unit
generic_map_aspect_opt
port_map_aspect_opt t_Semicolon
{
    yydebug( "component_instantiation_statement: identifier t_Colon instantiated_unit generic_map_aspect_opt "
             "port_map_aspect_opt t_Semicolon." );

    RULE_BREAK_MACRO
    parserInstance->setCurrentBlockCodeInfo($3);
    $$ = parserInstance->parse_ComponentInstantiationStatement( $1, $3, $4, $5 );
};

component_specification:
instantiation_list t_Colon /*component_*/ name
{
    yydebug("component_specification: instantiation_list t_Colon name.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ComponentSpecification( $1, $3 );
};


composite_type_definition:
array_type_definition
{
    yydebug("composite_type_definition: array_type_definition.");
    RULE_BREAK_MACRO $$ = $1;
}
| record_type_definition
{
    yydebug("composite_type_definition: record_type_definition.");
    RULE_BREAK_MACRO $$ = $1;
};


concurrent_assertion_statement:
/* t_POSTPONED_opt */ assertion
{
    yydebug("concurrent_assertion_statement: t_POSTPONED_opt assertion t_Semicolon.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ConcurrentAssertionStatement($1);
};

concurrent_procedure_call_statement:
/* t_POSTPONED_opt */ procedure_call t_Semicolon
{
    yydebug("concurrent_procedure_call_statement: t_POSTPONED_opt procedure_call t_Semicolon.");
    yyerror("concurrent_procedure_call_statement: t_POSTPONED_opt procedure_call t_Semicolon is not supported.");
};


concurrent_signal_assignment_statement:
/* t_POSTPONED_opt */ conditional_signal_assignment
{
    yydebug("concurrent_signal_assignment_statement: /* t_POSTPONED_opt */ conditional_signal_assignment.");
    RULE_BREAK_MACRO $$ = $1;
}
| /* t_POSTPONED_opt */ selected_signal_assignment
{
    yydebug("concurrent_signal_assignment_statement: /* t_POSTPONED_opt */  selected_signal_assignment.");
    RULE_BREAK_MACRO
    $$ = new BList<Assign>();
    $$->push_back($1);
}
| identifier t_Colon /* t_POSTPONED_opt */ conditional_signal_assignment
{
    yydebug("concurrent_signal_assignment_statement: identifier t_Colon /* t_POSTPONED_opt */  conditional_signal_assignment.");
    RULE_BREAK_MACRO
    $$ = $3;
    delete $1;
}
| identifier t_Colon /* t_POSTPONED_opt */ selected_signal_assignment
{
    yydebug("concurrent_signal_assignment_statement: identifier t_Colon /* t_POSTPONED_opt */  selected_signal_assignment.");
    RULE_BREAK_MACRO
    $$ = new BList<Assign>();
    $$->push_back($3);
    delete $1;
};

concurrent_statement:
block_statement
{
    yydebug("concurrent_statement: block_statement.");
    RULE_BREAK_MACRO

    $$ = new concurrent_statement_t();
    $$->block = $1;
}
| process_statement
{
    yydebug("concurrent_statement: process_statement.");
    RULE_BREAK_MACRO

    $$ = new concurrent_statement_t();
    $$->process = $1;
}
| concurrent_procedure_call_statement
{
    yydebug("concurrent_statement: concurrent_procedure_call_statement.");
    yyerror("concurrent_statement: concurrent_procedure_call_statement is not supported.");
}
| concurrent_assertion_statement
{
    yydebug("concurrent_statement: concurrent_assertion_statement.");
    RULE_BREAK_MACRO

    $$ = new concurrent_statement_t();
    $$->process = $1;
}
| concurrent_signal_assignment_statement
{
    yydebug("concurrent_statement: concurrent_signal_assignment_statement.");
    RULE_BREAK_MACRO

    $$ = new concurrent_statement_t();
    $$->signal_assignment = $1;
}
| component_instantiation_statement
{
    yydebug("concurrent_statement: component_instantiation_statement.");
    RULE_BREAK_MACRO

    $$ = new concurrent_statement_t();
    $$->component_instantiation = $1;
}
| generate_statement
{
    yydebug("concurrent_statement: generate_statement.");
    RULE_BREAK_MACRO

    $$ = new concurrent_statement_t();
    $$->generate = $1;
};

concurrent_statement_list:
/* empty */
{
    yydebug("concurrent_statement_list: empty.");
    RULE_BREAK_MACRO $$ = new std::list<concurrent_statement_t*>();
}
| concurrent_statement_list concurrent_statement
{
    yydebug("concurrent_statement_list: concurrent_statement_list concurrent_statement.");
    RULE_BREAK_MACRO

    $$ = $1;
    $$->push_back( $2 );
};


//condition:
///*boolean_*/ expression
//{
//    yydebug("condition: expression.");
//    $$ = $1;
//};


condition_clause:
t_UNTIL /* condition */ expression
{
    yydebug("condition_clause: t_UNTIL condition.");
    RULE_BREAK_MACRO $$ = $2;
};

condition_clause_opt:
/* empty */
{
    yydebug("condition_clause_opt: empty.");
    RULE_BREAK_MACRO $$ = nullptr;
}
| condition_clause
{
    yydebug("condition_clause_opt: condition_clause.");
    RULE_BREAK_MACRO $$ = $1;
};


conditional_signal_assignment:
target t_LESym options conditional_waveforms t_Semicolon
{
    yydebug("conditional_signal_assignment: target t_LESym options conditional_waveforms t_Semicolon.");
    RULE_BREAK_MACRO
    parserInstance->setCurrentBlockCodeInfo($1);
    $$ = parserInstance->parse_ConditionalSignalAssignment( $1, $4 );
};


conditional_waveforms:
conditional_waveforms_when_else_list waveform
{
    yydebug("conditional_waveforms: conditional_waveforms_when_else_list waveform");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_ConditionalWaveforms( $1, $2, nullptr );
}
| conditional_waveforms_when_else_list waveform t_WHEN /* condition */ expression
{
    yydebug("conditional_waveforms: conditional_waveforms_when_else_list waveform t_WHEN /* condition */ expression %prec HIGH");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ConditionalWaveforms( $1, $2, $4 );
};


conditional_waveforms_when_else_list:
/* empty */
{
    yydebug("conditional_waveforms_when_else_list: empty");
    RULE_BREAK_MACRO
    $$ = new When();
    parserInstance->setCurrentBlockCodeInfo($$);
}
| conditional_waveforms_when_else_list waveform t_WHEN /* condition */ expression t_ELSE
{
   yydebug("conditional_waveforms_when_else_list: conditional_waveforms_when_else_list waveform t_WHEN /* condition */ expression t_ELSE");
   RULE_BREAK_MACRO
   $$ = parserInstance->parse_ConditionalWaveformsWhen($1, $2, $4);
};


configuration_declaration:
t_CONFIGURATION identifier t_OF /*entity_*/ name t_IS
configuration_declarative_part
block_configuration
t_END t_CONFIGURATION_opt /*configuration_*/ identifier_opt t_Semicolon
{
    yydebug("t_CONFIGURATION identifier t_OF name t_IS configuration_declarative_part "
            "block_configuration t_END t_CONFIGURATION_opt identifier_opt t_Semicolon");
    RULE_BREAK_MACRO

    parserInstance->parse_ConfigurationDeclaration( $2, $4, $7 );
    delete $10;
};



configuration_declarative_item:
use_clause
{
    yydebug("configuration_declarative_item: use_clause.");
    RULE_BREAK_MACRO $$ = reinterpret_cast< BList<Declaration>* >($1);
}
| attribute_specification
{
    yydebug("configuration_declarative_item: attribute_specification.");
    yyerror("configuration_declarative_item: attribute_specification is not supported.");
}
| group_declaration
{
    yydebug("configuration_declarative_item: group_declaration.");
    yyerror("configuration_declarative_item: group_declaration is not supported.");
};



configuration_declarative_part:
/* empty */
{
    yydebug("configuration_declarative_part: empty.");
}
| configuration_declarative_part configuration_declarative_item
{
    yydebug("configuration_declarative_part: configuration_declarative_part configuration_declarative_item.");
    yyerror("configuration_declarative_part: configuration_declarative_part configuration_declarative_item is not supported.");
};


configuration_item:
block_configuration
{
    yydebug("configuration_item: block_configuration.");
    RULE_BREAK_MACRO

    $$ = new configuration_item_t();
    $$->block_configuration = $1;
}
| component_configuration
{
    yydebug("configuration_item: component_configuration.");
    RULE_BREAK_MACRO

    $$ = new configuration_item_t();
    $$->component_configuration = $1;
};



configuration_item_list:
/* empty */
{
    yydebug("configuration_item_list: empty.");
    RULE_BREAK_MACRO $$ = new std::list<configuration_item_t*>();
}
| configuration_item_list configuration_item
{
    yydebug("configuration_item_list: configuration_item_list configuration_item.");
    RULE_BREAK_MACRO

    $$ = $1;
    $$->push_back( $2 );
};



configuration_specification:
t_FOR component_specification binding_indication t_Semicolon
{
    yydebug("configuration_specification: t_FOR component_specification binding_indication t_Semicolon.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ConfigurationSpecification( $2, $3 );
};



constant_declaration:
t_CONSTANT identifier_list t_Colon subtype_indication t_VarAsgn expression t_Semicolon %prec HIGH
{
    yydebug("constant_declaration: t_CONSTANT identifier_list t_Colon subtype_indication "
            "t_VarAsgn expression t_Semicolon.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ConstantDeclaration( $2, $4, $6 );
}
| t_CONSTANT identifier_list t_Colon subtype_indication t_Semicolon %prec LOW
{
    yydebug("constant_declaration: t_CONSTANT identifier_list t_Colon subtype_indication t_Semicolon.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ConstantDeclaration( $2, $4, nullptr );
};



constrained_array_definition:
t_ARRAY index_constraint t_OF /*element_*/ subtype_indication
{
    yydebug("constrained_array_definition: t_ARRAY index_constraint t_OF subtype_indication.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ConstrainedArrayDefinition( $2, $4 );
};


constraint:
range_constraint
{
    yydebug("constraint: range_constraint.");
    RULE_BREAK_MACRO

    $$ = new constraint_t();
    $$->range_constraint = $1;
}
| index_constraint
{
    yydebug("constraint: index_constraint.");
    RULE_BREAK_MACRO

    $$ = new constraint_t();
    $$->index_constraint = $1;
};


context_clause:
/*empty*/
{
    yydebug("context_clause: empty.");
    RULE_BREAK_MACRO $$ = new std::list<context_item_t*>();
}
| context_clause context_item
{
    yydebug("context_clause: context_clause context_item.");
    RULE_BREAK_MACRO

    $$ = $1;
    $$->push_back( $2 );
};


context_item:
library_clause
{
    yydebug("context_item: library_clause.");
    RULE_BREAK_MACRO

    $$ = new context_item_t();
    $$->library_clause = $1;
    parserInstance->addLibrary( $1 );
}
| use_clause
{
    yydebug("context_item: use_clause.");
    RULE_BREAK_MACRO

    $$ = new context_item_t();
    $$->use_clause = $1;
    parserInstance->addLibrary( $1 );
};


decimal_literal:
/*integer [ . integer ] [ exponent ]*/
t_AbstractLit
{
    yydebug("decimal_literal: t_AbstractLit.");
    RULE_BREAK_MACRO $$ = parserInstance->parser_DecimalLiteral( $1 );
};


/* WARNING: defined by the standard, but useless! */
//declaration:
//type_declaration
//| subtype_declaration
//| object_declaration
//| interface_declaration
//| alias_declaration
//| attribute_declaration
//| component_declaration
//| group_template_declaration
//| group_declaration
//| entity_declaration
//| configuration_declaration
//| subprogram_declaration
//| package_declaration
//| primary_unit
//| architecture_body




delay_mechanism:
t_TRANSPORT
{
    yydebug("delay_mechanism: t_TRANSPORT.");
    yyerror("delay_mechanism: t_TRANSPORT is not supported.");
}
| delay_mechanism_reject_time_expression_opt t_INERTIAL
{
    yydebug("delay_mechanism: delay_mechanism_reject_time_expression_opt t_INERTIAL.");
    yyerror("delay_mechanism: delay_mechanism_reject_time_expression_opt t_INERTIAL is not supported.");
};



delay_mechanism_reject_time_expression_opt:
/* empty */
{
    yydebug("delay_mechanism_reject_time_expression_opt: empty.");
}
| t_REJECT /*time_ */ expression
{
    yydebug("delay_mechanism_reject_time_expression_opt: t_REJECT expression.");
    yydebug("delay_mechanism_reject_time_expression_opt: t_REJECT expression is not supported.");
};


//design_file:
//design_file design_unit
//{
//    yydebug("design_file: design_file design_unit.");
//}
//| design_unit
//{
//    yydebug("design_file: design_unit.");
//};


design_unit:
context_clause library_unit
{
    yydebug("design_unit: context_clause library_unit.");
    RULE_BREAK_MACRO parserInstance->parse_DesignUnit( $1, $2 );
};


designator:
identifier
{
    yydebug("designator: identifier.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_Designator( $1 );
}
| operator_symbol
{
    yydebug("designator: operator_symbol.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_Designator( $1 );
};

designator_opt:
/* empty */
{
    yydebug("designator_opt: empty.");
    RULE_BREAK_MACRO $$ = nullptr;
}
| designator
{
    yydebug("designator_opt: designator.");
    RULE_BREAK_MACRO $$ = $1;
};

direction:
t_TO
{
    yydebug("direction: t_TO.");
    RULE_BREAK_MACRO $$ = dir_upto;
}
| t_DOWNTO
{
    yydebug("direction: t_DOWNTO.");
    RULE_BREAK_MACRO $$ = dir_downto;
};



disconnection_specification:
t_DISCONNECT guarded_signal_specification t_AFTER /*time_*/ expression t_Semicolon
{
    yydebug("disconnection_specification: t_DISCONNECT guarded_signal_specification "
            "t_AFTER expression t_Semicolon.");
    yyerror("disconnection_specification: t_DISCONNECT guarded_signal_specification "
            "t_AFTER expression t_Semicolon is not supported.");
};


discrete_range:
// --- subtype_indication -----------------------------------------------
//name constraint
name range_constraint
{
    yydebug("discrete_range: name range_constraint.");
    RULE_BREAK_MACRO

    constraint_t * constraint = new constraint_t();
    constraint->range_constraint = $2;

    $$ = parserInstance->parse_DiscreteRange(
                parserInstance->parse_SubtypeIndication( $1, constraint ));
}
// --- range ------------------------------------------------------------
//| /*range_*/ attribute_name
| /*simple_expression*/ expression
{
    yydebug("discrete_range: expression");
    RULE_BREAK_MACRO $$ = parserInstance->parse_DiscreteRange( $1 );
}
| simple_expression direction simple_expression
{
    yydebug("discrete_range: simple_expression direction simple_expression.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_Range( $1, $2, $3 );
};


// element_association:
// NOTE: To solve shift/reduce conflict 'element_association'
//       has been moved after the rule 'hdl_or_psl_expression'

element_association_list:
element_association_list t_Comma element_association
{
    yydebug("element_association_list: element_association_list t_Comma element_association.");
    RULE_BREAK_MACRO
    $$ = $1;
    $$->push_back( $3 );
}
| element_association
{
    yydebug("element_association_list: element_association.");
    RULE_BREAK_MACRO
    $$ = new BList<AggregateAlt>();
    $$->push_back( $1 );
};



element_declaration:
identifier_list t_Colon element_subtype_definition t_Semicolon
{
    yydebug("element_declaration: identifier_list t_Colon element_subtype_definition "
            "t_Semicolon.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ElementDeclaration( $1, $3 );
};


element_declaration_list:
element_declaration_list element_declaration
{
    yydebug("element_declaration_list: element_declaration_list element_declaration.");
    RULE_BREAK_MACRO

    $$ = $1;
    $$->merge( *$2 );
    delete $2;
}
| element_declaration
{
    yydebug("element_declaration_list: element_declaration.");
    RULE_BREAK_MACRO $$ = $1;
};



element_subtype_definition:
subtype_indication
{
    yydebug("element_subtype_definition: subtype_indication.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ElementSubtypeDefinition( $1 );
};


entity_aspect:
t_ENTITY /*entity_*/ name
{
    yydebug("entity_aspect: t_ENTITY name.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_EntityAspect( $2, true, false );
}
| t_CONFIGURATION /*configuration_*/ name
{
    yydebug("entity_aspect: CONFIGURATION name.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_EntityAspect( $2, false, true );
}
| t_OPEN
{
    yydebug("entity_aspect: t_OPEN.");
    yyerror("entity_aspect: t_OPEN is not supported.");
};


entity_class:
t_ENTITY
{
    yydebug("entity_class: t_ENTITY.");
    //yyerror("entity_class: t_ENTITY is not supported.");
}
| t_ARCHITECTURE
{
    yydebug("entity_class: t_ARCHITECTURE.");
    //yyerror("entity_class: t_ARCHITECTURE is not supported.");
}
| t_CONFIGURATION
{
    yydebug("entity_class: t_CONFIGURATION.");
    //yyerror("entity_class: t_CONFIGURATION is not supported.");
}
| t_PROCEDURE
{
    yydebug("entity_class: t_PROCEDURE.");
    //yyerror("entity_class: t_PROCEDURE is not supported.");
}
| t_FUNCTION
{
    yydebug("entity_class: t_FUNCTION.");
    //yyerror("entity_class: t_FUNCTION is not supported.");
}
| t_PACKAGE
{
    yydebug("entity_class: t_PACKAGE.");
    //yyerror("entity_class: t_PACKAGE is not supported.");
}
| t_TYPE
{
    yydebug("entity_class: t_TYPE.");
    //yyerror("entity_class: t_TYPE is not supported.");
}
| t_SUBTYPE
{
    yydebug("entity_class: t_SUBTYPE.");
    //yyerror("entity_class: t_SUBTYPE is not supported.");
}
| t_CONSTANT
{
    yydebug("entity_class: t_CONSTANT.");
    //yyerror("entity_class: t_CONSTANT is not supported.");
}
| t_SIGNAL
{
    yydebug("entity_class: t_SIGNAL.");
    //yyerror("entity_class: t_SIGNAL is not supported.");
}
| t_VARIABLE
{
    yydebug("entity_class: t_VARIABLE.");
    //yyerror("entity_class: t_VARIABLE is not supported.");
}
| t_COMPONENT
{
    yydebug("entity_class: t_COMPONENT.");
    //yyerror("entity_class: t_COMPONENT is not supported.");
}
| t_LABEL
{
    yydebug("entity_class: t_LABEL.");
    //yyerror("entity_class: t_LABEL is not supported.");
}
| t_LITERAL
{
    yydebug("entity_class: t_LITERAL.");
    //yyerror("entity_class: t_LITERAL is not supported.");
}
| t_UNITS
{
    yydebug("entity_class: t_UNITS.");
    //yyerror("entity_class: t_UNITS is not supported.");
};


entity_class_entry:
entity_class t_LTSym t_GTSym
{
    yydebug("entity_class_entry: entity_class t_LTSym t_GTSym.");
    yyerror("entity_class_entry: entity_class t_LTSym t_GTSym is not supported" );
}
| entity_class
{
    yydebug("entity_class_entry: entity_class.");
    yyerror("entity_class_entry: entity_class is not supported" );
};


entity_class_entry_list:
entity_class_entry_list t_Comma entity_class_entry
{
    yydebug("entity_class_entry_list: entity_class_entry_list t_Comma entity_class_entry.");
    yyerror("entity_class_entry_list is not supported" );
}
| entity_class_entry
{
    yydebug("entity_class_entry_list: entity_class_entry.");
    yyerror("entity_class_entry_list is not supported" );
};



entity_declaration:
t_ENTITY identifier t_IS
entity_header
entity_declarative_part
t_BEGIN entity_statement_part
t_END t_ENTITY_opt /*entity_*/identifier_opt t_Semicolon
{
    yydebug("entity_declaration: t_ENTITY identifier t_IS entity_header entity_declarative_part t_BEGIN "
            "entity_statement_part t_END t_ENTITY_opt identifier_opt t_Semicolon.");

    yyerror("entity_declaration: t_ENTITY identifier t_IS entity_header entity_declarative_part t_BEGIN "
            "entity_statement_part t_END t_ENTITY_opt identifier_opt t_Semicolon is not supported.");
}
| t_ENTITY identifier t_IS
entity_header
entity_declarative_part
t_END t_ENTITY_opt /*entity_*/identifier_opt t_Semicolon
{
    yydebug("entity_declaration: t_ENTITY identifier t_IS entity_header entity_declarative_part "
            "t_END t_ENTITY_opt identifier_opt t_Semicolon.");
    RULE_BREAK_MACRO
    parserInstance->setCurrentBlockCodeInfo($1);
    $$ = parserInstance->parse_EntityDeclaration( $2, $4, $5 );

    delete $8;
};


entity_declarative_item:
subprogram_declaration
{
    yydebug("entity_declarative_item: subprogram_declaration.");
    RULE_BREAK_MACRO

    $$ = new entity_declarative_item_t();
    $$->subprogram_declaration = $1;
}
| subprogram_body
{
    yydebug("entity_declarative_item: subprogram_body.");
    RULE_BREAK_MACRO

    $$ = new entity_declarative_item_t();
    $$->subprogram_body = $1;
}
| type_declaration
{
    yydebug("entity_declarative_item: type_declaration.");
    RULE_BREAK_MACRO

    $$ = new entity_declarative_item_t();
    $$->type_declaration = $1;
}
| subtype_declaration
{
    yydebug("entity_declarative_item: subtype_declaration.");
    RULE_BREAK_MACRO

    $$ = new entity_declarative_item_t();
    $$->subtype_declaration = $1;
}
| constant_declaration
{
    yydebug("entity_declarative_item: constant_declaration.");
    RULE_BREAK_MACRO

    $$ = new entity_declarative_item_t();
    $$->constant_declaration = $1;
}
| signal_declaration
{
    yydebug("entity_declarative_item: signal_declaration.");
    RULE_BREAK_MACRO

    $$ = new entity_declarative_item_t();
    $$->signal_declaration = $1;
}
| /*shared_*/variable_declaration
{
    yydebug("entity_declarative_item: variable_declaration.");
    RULE_BREAK_MACRO

    $$ = new entity_declarative_item_t();
    $$->variable_declaration = $1;
}
| file_declaration
{
    yydebug("entity_declarative_item: file_declaration.");
    yyerror("entity_declarative_item: file_declaration is not supported.");
}
| alias_declaration
{
    yydebug("entity_declarative_item: alias_declaration.");
    RULE_BREAK_MACRO

    $$ = new entity_declarative_item_t();
    $$->alias_declaration = $1;
}
| attribute_declaration
{
    yydebug("entity_declarative_item: attribute_declaration.");
    RULE_BREAK_MACRO
    $$ = new entity_declarative_item_t();
    $$->isSkipped = true;

}
| attribute_specification
{
    yydebug("entity_declarative_item: attribute_specification.");
    RULE_BREAK_MACRO
    $$ = new entity_declarative_item_t();
    $$->isSkipped = true;
}
| disconnection_specification
{
    yydebug("entity_declarative_item: disconnection_specification.");
    yyerror("entity_declarative_item: disconnection_specification is not supported.");
}
| use_clause
{
    yydebug("entity_declarative_item: use_clause.");
    RULE_BREAK_MACRO
    $$ = new entity_declarative_item_t();
    $$->use_clause = $1;
}
| group_template_declaration
{
    yydebug("entity_declarative_item: group_template_declaration.");
    yyerror("entity_declarative_item: group_template_declaration is not supported.");
}
| group_declaration
{
    yydebug("entity_declarative_item: group_declaration.");
    yyerror("entity_declarative_item: group_declaration is not supported.");
};

entity_declarative_part:
/*empty*/
{
    yydebug("entity_declarative_part: empty.");
    RULE_BREAK_MACRO $$ = new std::list<entity_declarative_item_t*>();
}
| entity_declarative_part entity_declarative_item
{
    yydebug("entity_declarative_part: entity_declarative_part entity_declarative_item.");
    RULE_BREAK_MACRO
    $$ = $1;
    $$->push_back( $2 );
};


entity_designator:
entity_tag signature
{
    yydebug("entity_designator: entity_tag signature.");
    //yyerror("entity_designator: entity_tag signature is not supported.");
}
| entity_tag
{
    yydebug("entity_designator: entity_tag.");
    //yyerror("entity_designator: entity_tag is not supported.");
};

entity_designator_list:
entity_designator_list t_Comma entity_designator
{
    yydebug("entity_designator_list: entity_designator_list t_Comma entity_designator.");
    //yyerror("entity_designator_list: entity_designator_list t_Comma entity_designator is not supported.");
}
| entity_designator
{
    yydebug("entity_designator_list: entity_designator.");
    //yyerror("entity_designator_list: entity_designator is not supported.");
};




entity_header:
/*formal_*/generic_clause /*formal_*/port_clause %prec HIGH
{
    yydebug("entity_header: generic_clause port_clause.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_EntityHeader( $1, $2 );
}
| /*formal_*/ generic_clause %prec LOW
{
    yydebug("entity_header: generic_clause.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_EntityHeader( $1, nullptr );
}
| /*formal_*/ port_clause
{
    yydebug("entity_header: port_clause.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_EntityHeader( nullptr, $1 );
};



entity_name_list:
entity_designator_list
{
    yydebug("entity_name_list: entity_designator_list.");
    //yyerror("entity_name_list: entity_designator_list.");
}
| t_OTHERS
{
    yydebug("entity_name_list: t_OTHERS.");
    //yyerror("entity_name_list: t_OTHERS.");
}
| t_ALL
{
    yydebug("entity_name_list: t_ALL.");
    //yyerror("entity_name_list: t_ALL.");
};


entity_specification:
entity_name_list t_Colon entity_class
{
    yydebug("entity_specification: entity_name_list t_Colon entity_class.");
    //yyerror("entity_specification: entity_name_list t_Colon entity_class is not supported.");
};

entity_statement:
concurrent_assertion_statement
{
    yydebug("entity_statement: concurrent_assertion_statement.");
    yyerror("entity_statement: concurrent_assertion_statement is not supported.");
}
| /*passive_*/concurrent_procedure_call_statement
{
    yydebug("entity_statement: concurrent_procedure_call_statement.");
    yyerror("entity_statement: concurrent_procedure_call_statement is not supported.");
}
| /*passive_*/process_statement
{
    yydebug("entity_statement: process_statement.");
    yyerror("entity_statement: process_statement is not supported.");
};


entity_statement_part:
/* empty */
{
    yydebug("entity_statement_part: empty.");
    yyerror("entity_statement_part: empty is not supported.");
}
| entity_statement_part entity_statement
{
    yydebug("entity_statement_part: entity_statement_part entity_statement.");
    yyerror("entity_statement_part: entity_statement_part entity_statement is not supported.");
};


entity_tag:
identifier
{
    yydebug("entity_tag: identifier.");
    //yyerror("entity_tag: identifier is not supported.");
    delete $1;
}
| character_literal
{
    yydebug("entity_tag: character_literal.");
    //yyerror("entity_tag: character_literal is not supported.");
}
| operator_symbol
{
    yydebug("entity_tag: operator_symbol.");
    //yyerror("entity_tag: operator_symbol is nto supported.");
};


enumeration_literal:
identifier
{
    yydebug("enumeration_literal: identifier.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_EnumerationLiteral( $1 );
}
| t_CharacterLit
{
    yydebug("enumeration_literal: t_CharacterLit.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_EnumerationLiteral( $1.name );
};

enumeration_literal_list:
enumeration_literal_list t_Comma enumeration_literal
{
    yydebug("enumeration_literal_list: enumeration_literal_list t_Comma enumeration_literal.");
    RULE_BREAK_MACRO
    $$ = $1;
    $$->push_back( $3 );
}
| enumeration_literal
{
    yydebug("enumeration_literal_list: enumeration_literal.");
    RULE_BREAK_MACRO
    $$ = new BList<EnumValue>();
    $$->push_back( $1 );
};

enumeration_type_definition:
t_LeftParen enumeration_literal_list t_RightParen
{
    yydebug("enumeration_type_definition: t_LeftParen enumeration_literal_list t_RightParen.");
    RULE_BREAK_MACRO $$ = $2;
};



exit_statement:
t_EXIT /*loop_*/identifier_opt t_WHEN /* condition */ expression t_Semicolon
{
    yydebug("exit_statement: t_EXIT identifier_opt t_WHEN /* condition */ expression t_Semicolon.");
    //yyerror("exit_statement: t_EXIT identifier_opt t_WHEN /* condition */ expression t_Semicolon is not supported.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ExitStatement( nullptr, $2 );
}
| t_EXIT /*loop_*/identifier_opt t_Semicolon
{
    yydebug("exit_statement: t_EXIT /*loop_*/identifier_opt t_Semicolon.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ExitStatement( nullptr, $2 );
};

/* @TODO
exponent ::= E [ + ] integer | E . integer
*/


expression:
relation
{
    yydebug("expression: relation");
    RULE_BREAK_MACRO $$ = $1;
}
| expression t_AND relation
{
    yydebug("expression: expression t_AND relation");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ExpressionAND( $1, $3 );
}
| expression t_OR relation
{
    yydebug("expression: expression t_OR relation");
    RULE_BREAK_MACRO $$ = parserInstance->parse_Expression( $1, $3, op_or );
}
| expression t_XOR relation
{
    yydebug("expression: expression_XOR");
    RULE_BREAK_MACRO $$ = parserInstance->parse_Expression( $1, $3, op_xor );
}
| expression t_XNOR relation
{
    yydebug("expression: expression_XNOR");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ExpressionXNOR( $1, $3 );
}
| relation t_NAND relation
{
    yydebug("expression: expression_NAND");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ExpressionNAND( $1, $3 );
}
| relation t_NOR relation
{
    yydebug("expression: expression_NOR");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ExpressionNOR( $1, $3 );
};


expression_opt:
/* empty */
{
    yydebug("expression_opt: empty.");
    RULE_BREAK_MACRO $$ = nullptr;
}
| expression
{
    yydebug("expression_opt: expression.");
    RULE_BREAK_MACRO $$ = $1;
};

expression_paren_opt:
/* empty */
{
    yydebug("expression_paren_opt: empty.");
    RULE_BREAK_MACRO $$ = nullptr;
}
| t_LeftParen expression t_RightParen
{
    yydebug("expression_paren_opt: t_LeftParen expression t_RightParen.");
    RULE_BREAK_MACRO $$ = $2;
};


/* @TODO
extended_digit ::= digit | letter

extended_identifier ::= \ graphic_character { graphic_character } \

*/


factor:
primary t_DoubleStar primary %prec HIGH
{
    yydebug("factor: primary t_DoubleStar primary.");
    RULE_BREAK_MACRO

    Expression * eo = hif_factory->expression( $1, op_pow, $3);
    $$ = eo;
    parserInstance->setCodeInfo( $$ );
}
| t_ABS primary %prec MEDIUM3
{
    yydebug("factor: t_ABS primary.");
    RULE_BREAK_MACRO

    Expression * eo = hif_factory->expression( op_abs, $2 );
    $$ = eo;
    parserInstance->setCodeInfo( $$ );
}
| t_NOT primary %prec MEDIUM2
{
    yydebug("factor: t_NOT primary.");
    RULE_BREAK_MACRO

    Expression * eo = hif_factory->expression( op_not, $2 );
    $$ = eo;
    parserInstance->setCodeInfo( $$ );
}
| primary %prec LOW
{
    yydebug("factor: primary.");
    RULE_BREAK_MACRO $$ = $1;
};


file_declaration:
t_FILE identifier_list t_Colon subtype_indication file_open_information t_Semicolon
{
    yydebug("file_declaration: t_FILE identifier_list t_Colon subtype_indication "
            "file_open_information t_Semicolon.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FileDeclaration( $2, $4, $5 );
}
| t_FILE identifier_list t_Colon subtype_indication t_Semicolon
{
    yydebug("file_declaration: t_FILE identifier_list t_Colon subtype_indication "
            "t_Semicolon.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FileDeclaration( $2, $4, nullptr );
};


file_logical_name:
/*string_*/expression
{
    yydebug("file_logical_name: expression.");
    RULE_BREAK_MACRO $$ = $1;
};

file_open_information:
t_OPEN /*file_open_kind_*/expression t_IS file_logical_name
{
    yydebug("file_open_information: t_OPEN expression t_IS file_logical_name.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FileOpenInformation( $2, $4 );
}
| t_IS file_logical_name
{
    yydebug("file_open_information: t_IS file_logical_name.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FileOpenInformation( nullptr, $2 );
};


file_type_definition:
t_FILE t_OF name
{
    yydebug("file_type_definition: t_FILE t_OF name.");
    RULE_BREAK_MACRO
            $$ = parserInstance->parse_FileTypeDefinition($3);
};

/* WARNING: see scalar_type_definition
floating_type_definition:
range_constraint
{
    yydebug("floating_type_definition: range_constraint.");
    Real * ro = new Real();
    $$ = ro;
    parserInstance->setCodeInfo($$);
    ro->SetRange( $1 );
};
*/

floating_or_integer_type_definition:
range_constraint
{
    yydebug("floating_or_integer_type_definition: range_constraint.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FloatingOrIntegerTypeDefinition( $1 );
};



/*formal_designator:
 name
{
    //generic_ | port_ | parameter_
    $$ = $1;
};
*/

formal_parameter_list:
/* parameter_*/ interface_list
{
    yydebug("formal_parameter_list: interface_list.");
    RULE_BREAK_MACRO $$ = $1;
};

formal_parameter_list_paren_opt:
/* empty */
{
    yydebug("formal_parameter_list_paren_opt: empty.");
    RULE_BREAK_MACRO $$ = new std::list<interface_declaration_t*>();
}
| t_LeftParen formal_parameter_list t_RightParen
{
    yydebug("formal_parameter_list_paren_opt: t_LeftParen formal_parameter_list t_RightParen.");
    RULE_BREAK_MACRO $$ = $2;
};


formal_part:
/* formal_designator */ name
{
    yydebug("formal_part: name.");
    RULE_BREAK_MACRO $$ = $1;
};
// Conflicts with the next: | function_ name ( formal_designator )
// Same of fcall which is a name.
//| name t_LeftParen name t_RightParen


full_type_declaration:
t_TYPE identifier t_IS type_definition t_Semicolon
{
    yydebug("full_type_declaration: t_TYPE identifier t_IS type_definition t_Semicolon.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FullTypeDeclaration( $2, $4 );
};


/* WARNING: since function_call appears only in rules with name,
 * there is no reasons to let parenthesis optional.
 * Moreover, this have the same syntax of indexed_name and slice_name.
 * See the top of this file.
 */
function_call:
name t_LeftParen actual_parameter_part t_RightParen
{
    yydebug("function_call: name t_LeftParen actual_parameter_part t_RightParen.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FunctionCall( $1, $3 );
};



generate_statement:
/*generate_*/identifier t_Colon
generation_scheme t_GENERATE
block_declarative_item_list_opt
concurrent_statement_list
t_END t_GENERATE /*generate_*/identifier_opt t_Semicolon
{
    yydebug("identifier t_Colon generation_scheme t_GENERATE block_declarative_item_list "
            "t_BEGIN concurrent_statement_list t_END t_GENERATE identifier_opt t_Semicolon.");
    RULE_BREAK_MACRO
    parserInstance->setCurrentBlockCodeInfo($4);
    $$ = parserInstance->parse_GenerateStatement( $1, $3, $5, $6 );
};


block_declarative_item_list_opt:
/* empty */
{
    yydebug("block_declarative_item_list_opt: /* empty */");
    RULE_BREAK_MACRO $$ = new std::list<block_declarative_item_t*>();
}
| block_declarative_item_list t_BEGIN
{
    yydebug("block_declarative_item_list_opt: block_declarative_item_list t_BEGIN");
    RULE_BREAK_MACRO $$ = $1;
};


generation_scheme:
t_FOR /*generate_*/ parameter_specification
{
    yydebug("generation_scheme: t_FOR parameter_specification.");
    RULE_BREAK_MACRO
    parserInstance->setCurrentBlockCodeInfo( $1 );
    $$ = parserInstance->parse_GenerationScheme( $2 );
}
| t_IF /* condition */ expression
{
    yydebug("generation_scheme: t_IF condition.");
    RULE_BREAK_MACRO
    parserInstance->setCurrentBlockCodeInfo( $1 );
    $$ = parserInstance->parse_GenerationScheme( $2 );
};


generic_clause:
t_GENERIC t_LeftParen generic_list t_RightParen t_Semicolon
{
    yydebug("generic_clause: t_GENERIC t_LeftParen generic_list t_RightParen t_Semicolon.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_GenericClause( $3 );
};

generic_clause_opt:
/*empty*/
{
    yydebug("generic_clause_opt: empty.");
    RULE_BREAK_MACRO $$ = nullptr;
}
| generic_clause
{
    yydebug("generic_clause_opt: generic_clause.");
    RULE_BREAK_MACRO $$ = $1;
};


generic_list:
/*generic_*/ interface_list
{
    yydebug("generic_list: interface_list.");
    RULE_BREAK_MACRO $$ = $1;
};


generic_map_aspect:
t_GENERIC t_MAP t_LeftParen /*generic_*/association_list t_RightParen
{
    yydebug("generic_map_aspect: t_GENERIC t_MAP t_LeftParen association_list "
            "t_RightParen.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_GenericMapAspect( $4 );
};

generic_map_aspect_opt:
/*empty*/
{
    yydebug("generic_map_aspect_opt: empty.");
    RULE_BREAK_MACRO $$ = new BList<TPAssign>();
}
| generic_map_aspect
{
    yydebug("generic_map_aspect_opt: generic_map_aspect.");
    RULE_BREAK_MACRO $$ = $1;
};


/* @TODO
graphic_character ::= [ 13.1 ]
basic_graphic_character | lower_case_letter | other_special_character
*/


group_constituent:
name
{
    yydebug("group_constituent: name.");
    yyerror("group_constituent: name is not supported.");
}
| character_literal
{
    yydebug("group_constituent: character_literal.");
    yyerror("group_constituent: character_literal is not supported.");
};

group_constituent_list:
group_constituent_list t_Comma group_constituent
{
    yydebug("group_constituent_list: group_constituent_list t_Comma group_constituent.");
    yyerror("group_constituent_list is not supported." );
}
| group_constituent
{
    yydebug("group_constituent_list: group_constituent.");
    yyerror("group_constituent_list is not supported" );
};

/* WARNING this rule is ambiguous, since name could be id( name ).
 * Therefore, we simplify it for the moment. @NOTSTANDARD
 */
group_declaration:
t_GROUP identifier t_Colon /*group_template_*/ name_internal_simple t_LeftParen group_constituent_list t_RightParen t_Semicolon
{
    yydebug("group_declaration: t_GROUP identifier t_Colon /*group_template_*/ name t_LeftParen group_constituent_list t_RightParen t_Semicolon.");
    yyerror("group_declaration: t_GROUP identifier t_Colon /*group_template_*/ name t_LeftParen group_constituent_list t_RightParen t_Semicolon is not supported" );
};


group_template_declaration:
t_GROUP identifier t_IS t_LeftParen entity_class_entry_list t_RightParen t_Semicolon
{
    yydebug("group_template_declaration: t_GROUP identifier t_IS t_LeftParen entity_class_entry_list t_RightParen t_Semicolon.");
    yyerror("group_template_declaration: t_GROUP identifier t_IS t_LeftParen entity_class_entry_list t_RightParen t_Semicolon is not supported." );
};


guarded_signal_specification:
/*guarded_*/ signal_list t_Colon name
{
    yydebug("guarded_signal_specification: signal_list t_Colon name.");
    yyerror("guarded_signal_specification: signal_list t_Colon name is not supported.");
};

identifier:
/* basic_identifier | extended_identifier */
t_Identifier
{
    yydebug( "identifier: t_Identifier." );
    RULE_BREAK_MACRO $$ = parserInstance->parse_Identifier( $1.name );
};

identifier_colon_opt:
/* empty */
{
    yydebug( "identifier_colon_opt: empty." );
    RULE_BREAK_MACRO $$ = nullptr;
}
| identifier t_Colon
{
   yydebug( "identifier_colon_opt: identifier t_Colon." );
   RULE_BREAK_MACRO

   Identifier * identifier = dynamic_cast< Identifier *>( $1 );
   messageAssert( identifier != nullptr, "Expected identifier object", $1, nullptr );
   $$ = identifier;
};


identifier_opt:
/* empty */
{
    yydebug( "identifier_opt: empty." );
    RULE_BREAK_MACRO $$ = nullptr;
}
| identifier
{
    yydebug( "identifier_opt: identifier." );
    RULE_BREAK_MACRO

    Identifier * identifier = dynamic_cast< Identifier *>( $1 );
    messageAssert( identifier != nullptr, "Expected identifier object", $1, nullptr );
    $$ = identifier;
};


identifier_list:
identifier_list t_Comma identifier
{
    yydebug("identifier_list: identifier_list t_Comma identifier.");
    RULE_BREAK_MACRO

    Identifier * identifier = dynamic_cast< Identifier *>( $3 );
    messageAssert( identifier != nullptr, "Expected identifier object", $3, nullptr );
    $$ = $1;
    $$->push_back( identifier );
}
| identifier
{
    yydebug("identifier_list: identifier.");
    RULE_BREAK_MACRO

    $$ = new BList<Identifier>();
    Identifier * identifier = dynamic_cast< Identifier *>( $1 );
    messageAssert( identifier != nullptr, "Expected identifier object", $1, nullptr );
    $$->push_back( identifier );
};


if_statement:
identifier_colon_opt
t_IF /* condition */ expression t_THEN sequence_of_statements
if_statement_elseif_list
t_ELSE sequence_of_statements
t_END t_IF /* if_*/identifier_opt t_Semicolon %prec t_ELSIF_SUP
{
    yydebug("if_statement: identifier_colon_opt t_IF /* condition */ expression t_THEN sequence_of_statements "
            "if_statement_elseif_list t_ELSE sequence_of_statements t_END t_IF identifier_opt t_Semicolon.");
    RULE_BREAK_MACRO

    delete $1;
    delete $11;
    parserInstance->setCurrentBlockCodeInfo($2);
    $$ = parserInstance->parse_IfStatement( $3, $5, $6, $8 );
}
| identifier_colon_opt t_IF /* condition */ expression t_THEN sequence_of_statements
if_statement_elseif_list
t_END t_IF /* if_*/identifier_opt t_Semicolon %prec t_ELSIF
{
    yydebug("if_statement: identifier_colon_opt t_IF /* condition */ expression t_THEN sequence_of_statements "
            "if_statement_elseif_list t_END t_IF identifier_opt t_Semicolon.");
    RULE_BREAK_MACRO

    delete $1;
    delete $9;
    parserInstance->setCurrentBlockCodeInfo($2);
    $$ = parserInstance->parse_IfStatement( $3, $5, $6 );
}
| identifier_colon_opt t_IF /* condition */ expression t_THEN sequence_of_statements
t_ELSE sequence_of_statements
t_END t_IF /* if_*/identifier_opt t_Semicolon %prec t_ELSE
{
    yydebug("if_statement: identifier_colon_opt t_IF /* condition */ expression t_THEN sequence_of_statements "
            "t_ELSE sequence_of_statements t_END t_IF identifier_opt t_Semicolon.");
    RULE_BREAK_MACRO

    delete $1;
    delete $10;
    parserInstance->setCurrentBlockCodeInfo($2);
    $$ = parserInstance->parse_IfStatement( $3, $5, $7 );
}
| identifier_colon_opt t_IF /* condition */ expression t_THEN sequence_of_statements
t_END t_IF /* if_*/identifier_opt t_Semicolon %prec t_ELSE_LOWER
{
    yydebug("if_statement: identifier_colon_opt t_IF /* condition */ expression t_THEN sequence_of_statements "
            "t_END t_IF identifier_opt t_Semicolon.");
    RULE_BREAK_MACRO

    delete $1;
    delete $8;
    parserInstance->setCurrentBlockCodeInfo($2);
    $$ = parserInstance->parse_IfStatement( $3, $5 );
};



if_statement_elseif_list:
t_ELSIF /* condition */ expression t_THEN sequence_of_statements %prec t_ELSE_LOWER
{
    yydebug("if_statement_elseif_list: t_ELSIF /* condition */ expression t_THEN sequence_of_statements.");
    RULE_BREAK_MACRO
    parserInstance->setCurrentBlockCodeInfo($1);
    $$ = parserInstance->parse_IfStatementElseifList( $2, $4 );
}
| if_statement_elseif_list t_ELSIF /* condition */ expression t_THEN sequence_of_statements %prec t_ELSE
{
    yydebug("if_statement_elseif_list: if_statement_elseif_list t_ELSIF /* condition */ expression t_THEN sequence_of_statements.");
    RULE_BREAK_MACRO
    parserInstance->setCurrentBlockCodeInfo($2);
    $$ = parserInstance->parse_IfStatementElseifList( $1, $3, $5 );
};



incomplete_type_declaration:
t_TYPE identifier t_Semicolon
{
    yydebug("incomplete_type_declaration: t_TYPE identifier t_Semicolon.");
    yyerror("incomplete_type_declaration: t_TYPE identifier t_Semicolon is not supported.");
};


index_constraint:
t_LeftParen index_constraint_list t_RightParen
{
    yydebug("index_constraint: t_LeftParen  index_constraint_list t_RightParen.");
    RULE_BREAK_MACRO $$ = $2;
};

index_constraint_list:
index_constraint_list t_Comma discrete_range
{
    yydebug("index_constraint_list: index_constraint_list t_Comma discrete_range.");
    RULE_BREAK_MACRO
    $$ = $1;
    $$->push_back( parserInstance->parse_IndexConstraint( $3 ) );
}
| discrete_range
{
    yydebug("index_constraint_list: discrete_range.");
    RULE_BREAK_MACRO
    $$ = new BList<Range>();
    $$->push_back( parserInstance->parse_IndexConstraint( $1) );
};

index_specification:
discrete_range
{
    yydebug( "index_specification: discrete_range." );
    RULE_BREAK_MACRO $$ = $1;
}
//| /*static_*/ expression
;


index_subtype_definition:
name t_RANGE t_LTSym t_GTSym
{
    yydebug("index_subtype_definition: name t_RANGE t_LTSym t_GTSym.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_IndexSubtypeDefinition( $1 );
};

index_subtype_definition_list:
index_subtype_definition_list t_Comma index_subtype_definition
{
    yydebug("index_subtype_definition_list: index_subtype_definition_list t_Comma "
            "index_subtype_definition.");
    RULE_BREAK_MACRO
    $$ = $1;
    $$->push_back($3);
}
| index_subtype_definition
{
    yydebug( "index_subtype_definition_list: index_subtype_definition. " );
    RULE_BREAK_MACRO
    $$ = new BList<Range>();
    $$->push_back($1);
};

// WARNING Removed. See the top of this file.
//indexed_name:
//prefix t_LeftParen expression_list t_RightParen %prec HIGH
//{
//    yydebug("indexed_name: prefix t_LeftParen expression_list t_RightParen.");
//    Member* m = new Member();
//    parserInstance->setCodeInfo( m );
//    m->setPrefix( $1 );
//    m->value.merge( *$3 );
//    delete $3;
//    $$ = m;
//};



/* WARNING: component keyword optional, but here made required!
 * See: the beginning of this file.
 */
instantiated_unit:
t_COMPONENT /*component_*/ name
{
    yyerror("instantiated_unit: t_COMPONENT name is not supported.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_InstantiatedUnit( true, false, $2 );
}
| name
{
    yydebug("instantiated_unit: name.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_InstantiatedUnit( false, false, $1 );
}
| t_ENTITY /* entity_name t_rightParen architecture_identifier t_leftParen */ name
{
    yydebug("instantiated_unit: t_ENTITY /* t_rightParen identifier t_leftParen */ name.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_InstantiatedUnit( false, true, $2 );
}
| t_CONFIGURATION /*configuration_*/ name
{
    yydebug("instantiated_unit: t_CONFIGURATION name.");
    yyerror("instantiated_unit: t_CONFIGURATION name is not supported.");
};



instantiation_list:
/* instantiation_ */ identifier_list
{
    yydebug("instantiation_list: identifier_list.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_InstantiationList( $1 );
}
| t_OTHERS
{
    yydebug("instantiation_list: t_OTHERS.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_InstantiationList( false );
}
| t_ALL
{
    yydebug("instantiation_list: t_ALL.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_InstantiationList( true );
};



/* @TODO
integer: digit { [ underline ] digit } [ 13
.4.1]
*/

/* WARNING: see scalar_type_definition.
integer_type_definition:
range_constraint
{
    yydebug("integer_type_definition: range_constraint.");
    Int * io = new Int();
    $$ = io;
    parserInstance->setCodeInfo( $$ );
    io->SetRange( $1 );
    io->setSpan( hif::semantics::getSpanFromRange( $1 ) );
};
*/


/* WARNING: see interface_declaration */
interface_constant_declaration:
t_CONSTANT identifier_list t_Colon t_IN_opt subtype_indication t_VarAsgn /*static_*/expression
{
    yydebug("interface_constant_declaration: t_CONSTANT_opt identifier_list t_Colon "
            "t_IN_opt subtype_indication t_VarAsgn expression.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_InterfaceConstantDeclaration( $2, $4, $5, $7 );
}
| t_CONSTANT identifier_list t_Colon t_IN_opt subtype_indication
{
    yydebug("interface_constant_declaration: t_CONSTANT identifier_list t_Colon "
            "t_IN_opt subtype_indication.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_InterfaceConstantDeclaration( $2, $4, $5, nullptr );
};


/* WARNING: added a rule, to avoid ambiguity due to variable,
 * constant and signal keyword optionality, and made them
 * required into respective rules. */
interface_declaration:
identifier_list t_Colon mode_opt subtype_indication t_VarAsgn expression
{
    yydebug("interface_declaration: identifier_list t_Colon mode_opt subtype_indication t_VarAsgn expression.");
    RULE_BREAK_MACRO

    $$ = new interface_declaration_t();
    $$->port_list = parserInstance->parse_InterfaceSignalDeclaration( $1, $3, $4, $6 );
}
| interface_constant_declaration
{
    yydebug("interface_declaration: interface_constant_declaration.");
    RULE_BREAK_MACRO

    $$ = new interface_declaration_t();
    $$->constant_declaration = $1;
}
| interface_signal_declaration
{
    yydebug("interface_declaration: interface_signal_declaration.");
    RULE_BREAK_MACRO

    $$ = new interface_declaration_t();
    $$->signal_declaration = $1;
}
| interface_variable_declaration
{
    yydebug("interface_declaration: interface_variable_declaration.");
    RULE_BREAK_MACRO

    $$ = new interface_declaration_t();
    $$->variable_declaration = $1;
}
| interface_file_declaration
{
    yydebug("interface_declaration: interface_file_declaration.");
    yyerror("interface_declaration: interface_file_declaration is not supported.");
}
| identifier_list t_Colon mode_opt subtype_indication
{
    yydebug("interface_declaration: identifier_list t_Colon mode_opt subtype_indication.");
    RULE_BREAK_MACRO

    $$ = new interface_declaration_t();
    $$->port_list = parserInstance->parse_InterfaceDeclaration( $1, $3, $4 );
};


interface_element:
interface_declaration
{
    yydebug("interface_element: interface_declaration.");
    RULE_BREAK_MACRO $$ = $1;
};



interface_file_declaration:
t_FILE identifier_list t_Colon subtype_indication
{
    yydebug("interface_file_declaration: t_FILE identifier_list t_Colon  subtype_indication.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FileDeclaration( $2, $4, nullptr );
};


interface_list:
interface_list t_Semicolon interface_element
{
    yydebug("interface_list: interface_list t_Semicolon interface_element.");
    RULE_BREAK_MACRO

    $$ = $1;
    $$->push_back( $3 );
}
| interface_element
{
    yydebug("interface_list: interface_element.");
    RULE_BREAK_MACRO

    $$ = new std::list<interface_declaration_t*>();
    $$->push_back( $1 );
};


/* WARNING: see interface_declaration */
interface_signal_declaration:
t_SIGNAL identifier_list t_Colon mode_opt subtype_indication t_BUS_opt t_VarAsgn
/*static_*/ expression
{
    yydebug("interface_signal_declaration: t_SIGNAL identifier_list t_Colon mode_opt "
            "subtype_indication t_BUS_opt t_VarAsgn expression.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_InterfaceSignalDeclaration( $2, $4, $5, $8);
}
| t_SIGNAL identifier_list t_Colon mode_opt subtype_indication t_BUS_opt
{
    yydebug("interface_signal_declaration: t_SIGNAL identifier_list t_Colon mode_opt "
            "subtype_indication t_BUS_opt.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_InterfaceSignalDeclaration( $2, $4, $5, nullptr);
};


/* WARNING: see interface_declaration */
interface_variable_declaration:
t_VARIABLE identifier_list t_Colon mode_opt subtype_indication t_BUS_opt t_VarAsgn
/*static_*/ expression
{
    yydebug("interface_ t_VARIABLE identifier_list t_Colon mode_opt "
            "subtype_indication t_VarAsgn expression.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_InterfaceSignalDeclaration( $2, $4, $5, $8);
}
| t_VARIABLE identifier_list t_Colon mode_opt subtype_indication
{
    yydebug("interface_variable_declaration: t_VARIABLE identifier_list t_Colon mode_opt "
            "subtype_indication.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_InterfaceSignalDeclaration( $2, $4, $5, nullptr);
};


iteration_scheme:
t_WHILE /* condition */ expression
{
    yydebug("iteration_scheme: t_WHILE /* condition */ expression .");
    RULE_BREAK_MACRO $$ = parserInstance->parse_IterationScheme( $2 );
}
| t_FOR /*loop_*/ parameter_specification
{
    yydebug("iteration_scheme: t_FOR parameter_specification.");
    RULE_BREAK_MACRO $$ = $2;
};


iteration_scheme_opt:
/* empty */
{
    yydebug("iteration_scheme_opt: empty.");
    RULE_BREAK_MACRO $$ = nullptr;
}
| iteration_scheme
{
    yydebug("iteration_scheme_opt: iteration_scheme.");
    RULE_BREAK_MACRO $$ = $1;
};


/*
label: identifier
{
    yydebug( "label: identifier." );
    $$ = $1;
};
*/

/*
label_colon_opt:
{
    // empty
    yydebug("label_colon_opt: empty.");
    $$ = nullptr;
}
| label t_Colon
{
    yydebug("label_colon_opt: label t_Colon.");
    $$ = $1;
};
*/

/*
label_opt:
{
    // empty
    yydebug( "label_opt: empty. " );
    $$ = nullptr;
}
| label
{
    yydebug( "label_opt: label. " );
    $$ = $1;
};
*/

/*
label_list:
label_list t_Comma label
{
    yydebug("label_list: label_list t_Comma label.");
    $$ = $1;
    $$->push_back( $3 );
}
| label
{
    yydebug("label_list: label.");
    $$ = new BList<Identifier>();
    $$->push_back( $1 );
};
*/

/* @TODO
letter ::= upper_case_letter | lower_case_letter
letter_or_digit ::= letter | digit
*/

library_clause:
t_LIBRARY logical_name_list t_Semicolon
{
    yydebug("library_clause: t_LIBRARY logical_name_list t_Semicolon.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_LibraryClause( $2 );
};


library_unit:
primary_unit
{
    yydebug("library_unit: primary_unit.");
    RULE_BREAK_MACRO
    $$ = new library_unit_t();
    $$->primary_unit = $1;
}
| secondary_unit
{
    yydebug("library_unit: secondary_unit.");
    RULE_BREAK_MACRO

    $$ = new library_unit_t();
    $$->secondary_unit = $1;
};


literal:
character_literal
{
    yydebug("literal: character_literal.");
    RULE_BREAK_MACRO $$ = $1;
}
| numeric_literal
{
    yydebug("literal: numeric_literal.");
    RULE_BREAK_MACRO $$ = $1;
}
/* Conflicts with names. But what we really want is
 * to translate them as names, so we comment this.
| enumeration_literal
{
    yydebug("literal: enumeration_literal.");
    $$ = new Identifier( $1->getName() );
    delete $1;
}*/
/* Conflicts with name, for operator_name.
   since literal is used only where appear also name (i.e. into primary),
   we can safely remove it, and put it into name. See also name.
| string_literal
{
    yydebug("literal: string_literal.");
    $$ = $1;
}*/
| bit_string_literal
{
    yydebug("literal: bitstring_literal.");
    RULE_BREAK_MACRO $$ = $1;
}
| t_NULL
{
    yydebug("literal: t_NULL.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_Literal_null();
};


logical_name:
identifier
{
    yydebug("logical_name: identifier.");
    RULE_BREAK_MACRO

    Identifier * identifier = dynamic_cast< Identifier *>( $1 );
    messageAssert( identifier != nullptr, "Expected identifier object", $1, nullptr );
    $$ = identifier;
};


logical_name_list:
logical_name_list t_Comma logical_name
{
    yydebug("logical_name_list: logical_name_list t_Comma logical_name.");
    RULE_BREAK_MACRO

    $$ = $1;
    $$->push_back( $3 );
}
| logical_name
{
    yydebug("logical_name_list: logical_name.");
    RULE_BREAK_MACRO

    $$ = new BList<Identifier>();
    $$->push_back( $1 );
};

loop_statement:
identifier_colon_opt
/*2*/ iteration_scheme_opt t_LOOP
/*4*/ sequence_of_statements
t_END t_LOOP /*7 loop_*/ identifier_opt t_Semicolon
{
    yydebug("loop_statement: identifier_colon_opt iteration_scheme_opt t_LOOP sequence_of_statements "
            "t_END t_LOOP identifier_opt t_Semicolon.");
    RULE_BREAK_MACRO

    $$ = parserInstance->parse_LoopStatement( $1, $2, $4 );
    delete $7;
};

mode:
t_IN
{
    yydebug("mode: t_IN.");
    RULE_BREAK_MACRO $$ = dir_in;
}
| t_OUT
{
    yydebug("mode: t_OUT.");
    RULE_BREAK_MACRO $$ = dir_out;
}
| t_INOUT
{
    yydebug("mode: t_INOUT.");
    RULE_BREAK_MACRO $$ = dir_inout;
}
| t_BUFFER
{
    yydebug("mode: t_BUFFER.");
    yyerror("mode: t_BUFFER is not supported.");
}
| t_LINKAGE
{
    yydebug("mode: t_LINKAGE.");
    yyerror("mode: t_LINKAGE is not supported.");
};

mode_opt:
/* empty */
{
    yydebug("mode_opt: empty.");
    // The VHDL-2002 default mode is t_IN:
    RULE_BREAK_MACRO $$ = dir_in;
}
| mode
{
    yydebug("mode_opt: mode.");
    RULE_BREAK_MACRO $$ = $1;
};


multiplying_operator:
t_Star
{
    yydebug("multiplying_operator: t_Star.");
    RULE_BREAK_MACRO $$ = op_mult;
}
| t_Slash
{
    yydebug("multiplying_operator: t_Slash.");
    RULE_BREAK_MACRO $$ = op_div;
}
| t_MOD
{
    yydebug("multiplying_operator: t_MOD.");
    RULE_BREAK_MACRO $$ = op_mod;
}
| t_REM
{
    yydebug("multiplying_operator: t_Rem.");
    RULE_BREAK_MACRO $$ = op_rem;
};

name:
/* simple_name */ identifier
{
    yydebug("name: identifier.");
    RULE_BREAK_MACRO $$ = $1;
}
| selected_name
{
    yydebug("name: selected_name.");
    RULE_BREAK_MACRO $$ = $1;
}
| attribute_name
{
    yydebug("name: attribute_name.");
    RULE_BREAK_MACRO $$ = $1;
}
| /* operator_symbol */ string_literal
{
    yydebug("name: string_literal.");
    RULE_BREAK_MACRO $$ = $1;
}
| function_call
{
    yydebug("name: function_call.");
    RULE_BREAK_MACRO $$ = $1;
};


name_internal_simple:
identifier
{
    yydebug("name_internal_: identifier.");
    RULE_BREAK_MACRO $$ = $1;
}
| name_internal_simple t_Dot identifier
{
    yydebug("name_internal_: name_internal_simple t_Dot identifier.");
    delete $3;
    RULE_BREAK_MACRO $$ = $1;
};

name_list:
name_list t_Comma name
{
    yydebug("name_list: name_list t_Comma name.");
    RULE_BREAK_MACRO

    $$ = $1;
    $$->push_back($3);
}
| name
{
    yydebug("name_list: name.");
    RULE_BREAK_MACRO

    $$ = new BList<Value>();
    $$->push_back( $1 );
};

next_statement:
identifier_colon_opt
t_NEXT /*loop_*/ /*3*/ identifier_opt t_WHEN /*5*/ /* condition */ expression t_Semicolon
{
    yydebug("next_statement: identifier_colon_opt t_NEXT identifier_opt t_WHEN /* condition */ expression t_Semicolon.");
    RULE_BREAK_MACRO

    delete $1;
    $$ = parserInstance->parse_NextStatement( $3, $5 );
}
| identifier_colon_opt t_NEXT /*loop_*/ identifier_opt t_Semicolon
{
    yydebug("next_statement: identifier_colon_opt t_NEXT identifier_opt t_Semicolon.");
    RULE_BREAK_MACRO

    delete $1;
    $$ = parserInstance->parse_NextStatement( $3 );
}
;


null_statement:
identifier_colon_opt t_NULL t_Semicolon
{
    yydebug("null_statement: identifier_colon_opt t_NULL t_Semicolon.");
    RULE_BREAK_MACRO

    $$ = new Null();
    parserInstance->setCodeInfo($$);
    delete $1;
};

numeric_literal:
abstract_literal %prec LOW
{
    yydebug("numeric_literal: abstract_literal.");
    RULE_BREAK_MACRO $$ = $1;
}
//| physical_literal
| abstract_literal /*unit_*/ name %prec HIGH
{
    yydebug("numeric_literal: physical_literal_no_name.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_NumericLiteral( $1, $2 );
};

/* WARNING: defined by the standard, but unuseful. */
//object_declaration:
//constant_declaration
//| signal_declaration
//| variable_declaration
//| file_declaration


operator_symbol:
string_literal
{
    yydebug("operator_symbol: string_literal.");
    RULE_BREAK_MACRO $$ = $1;
};


options:
/* empty */
{
    yydebug("options: empty.");
}
| t_GUARDED delay_mechanism %prec HIGH
{
    yydebug("options: t_GUARDED delay_mechanism.");
    yyerror("options: t_GUARDED delay_mechanism is not supported.");
}
| t_GUARDED %prec LOW
{
    yydebug("options: t_GUARDED.");
    yyerror("options: t_GUARDED is not supported.");
}
| delay_mechanism
{
    yydebug("options: delay_mechanism.");
    yyerror("options: delay_mechanism is not supported.");
};


package_body:
t_PACKAGE t_BODY /*package_*/ identifier t_IS
package_body_declarative_part
t_END t_PACKAGE_BODY_opt /*package_*/ identifier_opt t_Semicolon
{
    yydebug("t_PACKAGE t_BODY identifier t_IS package_body_declarative_part "
            "t_END t_PACKAGE_BODY_opt identifier_opt t_Semicolon.");
    RULE_BREAK_MACRO

    parserInstance->setCurrentBlockCodeInfo($1);
    $$ = parserInstance->parse_PackageBody( $3, $5 );
    delete $8;
};


package_body_declarative_item:
subprogram_declaration
{
    yydebug("package_body_declarative_item: subprogram_declaration.");
    RULE_BREAK_MACRO

    $$ = new BList<Declaration>();
    $$->push_back( $1 );
}
| subprogram_body
{
    yydebug("package_body_declarative_item: subprogram_body.");
    RULE_BREAK_MACRO

    $$ = new BList<Declaration>();
    $$->push_back( $1 );
}
| type_declaration
{
    yydebug("package_body_declarative_item: type_declaration.");
    RULE_BREAK_MACRO

    $$ = new BList<Declaration>();
    $$->push_back( $1 );
}
| subtype_declaration
{
    yydebug("package_body_declarative_item: subtype_declaration.");
    RULE_BREAK_MACRO

    $$ = new BList<Declaration>();
    $$->push_back( $1 );
}
| constant_declaration
{
    yydebug("package_body_declarative_item: constant_declaration.");
    RULE_BREAK_MACRO $$ = $1;
}
| /*shared_*/ variable_declaration
{
    yydebug("package_body_declarative_item: variable_declaration.");
    RULE_BREAK_MACRO

    $$ = new BList<Declaration>();
    $$->merge( *$1 );
    delete $1;
}
| file_declaration
{
    yydebug("package_body_declarative_item: file_declaration.");
    yyerror("package_body_declarative_item: file_declaration is nto supported.");
}
| alias_declaration
{
    yydebug("package_body_declarative_item: alias_declaration.");
    yyerror("package_body_declarative_item: alias_declaration is not supported.");
}
| use_clause
{
    yydebug("package_body_declarative_item: use_declaration.");
    yyerror("package_body_declarative_item: use_declaration is not supported.");
}
| group_template_declaration
{
    yydebug("package_body_declarative_item: group_template_declaration.");
    yyerror("package_body_declarative_item: group_template_declaration is not supported.");
}
| group_declaration
{
    yydebug("package_body_declarative_item: group_declaration.");
    yyerror("package_body_declarative_item: group_declaration is not supported.");
};


package_body_declarative_part:
/* empty */
{
    yydebug("package_body_declarative_part: package_body_declarative_item.");
    RULE_BREAK_MACRO $$ = new BList<Declaration>();
}
| package_body_declarative_part package_body_declarative_item
{
    yydebug("package_body_declarative_part: package_body_declarative_part "
            "package_body_declarative_item.");
    RULE_BREAK_MACRO

    $$ = $1;
    $$->merge( *$2 );
    delete $2;
};


package_declaration:
t_PACKAGE identifier t_IS
package_declarative_part
t_END t_PACKAGE /*package_*/ identifier_opt t_Semicolon
{
    yydebug("package_declaration: t_PACKAGE identifier t_IS package_declarative_part "
            "t_END t_PACKAGE /*package_*/ identifier_opt t_Semicolon.");

    RULE_BREAK_MACRO
    parserInstance->setCurrentBlockCodeInfo($1);
    $$ = parserInstance->parse_PackageDeclaration( $2, $4 );
    delete $7;
}
| t_PACKAGE identifier t_IS
package_declarative_part
t_END /*package_*/ identifier_opt t_Semicolon
{
    yydebug("package_declaration: t_PACKAGE identifier t_IS package_declarative_part "
            "t_END /*package_*/ identifier_opt t_Semicolon.");

    RULE_BREAK_MACRO
    parserInstance->setCurrentBlockCodeInfo($1);
    $$ = parserInstance->parse_PackageDeclaration( $2, $4 );
    delete $6;
};


package_declarative_item:
subprogram_declaration
{
    yydebug("package_declarative_item: subprogram_declaration.");
    RULE_BREAK_MACRO

    $$ = new BList<Declaration>();
    $$->push_back( $1 );
}
| type_declaration
{
    yydebug("package_declarative_item: type_declaration.");
    RULE_BREAK_MACRO

    $$ = new BList<Declaration>();
    $$->push_back( $1 );
}
| subtype_declaration
{
    yydebug("package_declarative_item: subtype_declaration.");
    RULE_BREAK_MACRO

    $$ = new BList<Declaration>();
    $$->push_back( $1 );
}
| constant_declaration
{
    yydebug("package_declarative_item: constant_declaration.");
    RULE_BREAK_MACRO $$ = $1;
}
| signal_declaration
{
    yydebug("package_declarative_item: signal_declaration.");
    RULE_BREAK_MACRO
    $$ = new BList<Declaration>();
    $$->merge( *$1 );
    delete $1;
}
| /*shared_*/variable_declaration
{
    yydebug("package_declarative_item: variable_declaration.");
    RULE_BREAK_MACRO
    $$ = new BList<Declaration>();
    $$->merge( *$1 );
    delete $1;
}
| file_declaration
{
    yydebug("package_declarative_item: file_declaration.");
    yyerror("package_declarative_item: file_declaration is not supported.");
}
| alias_declaration
{
    yydebug("package_declarative_item: alias_declaration.");
    yyerror("package_declarative_item: alias_declaration is nto supported.");
}
| component_declaration
{
    yydebug("package_declarative_item: component_declaration.");
    RULE_BREAK_MACRO

    $$ = new BList<Declaration>();
    $$->push_back( $1 );
}
| attribute_declaration
{
    yydebug("package_declarative_item: attribute_declaration.");
    RULE_BREAK_MACRO
    $$ = new BList<Declaration>();
}
| attribute_specification
{
    yydebug("package_declarative_item: attribute_specification.");
    RULE_BREAK_MACRO
    $$ = new BList<Declaration>();
}
| disconnection_specification
{
    yydebug("package_declarative_item: disconnection_specification.");
    yyerror("package_declarative_item: disconnection_specification is not supported.");
}
| use_clause
{
    yydebug("package_declarative_item: use_clause.");
    yyerror("package_declarative_item: use_clause is not supported.");
}
| group_template_declaration
{
    yydebug("package_declarative_item: group_template_declaration.");
    yyerror("package_declarative_item: group_template_declaration is not supported.");
}
| group_declaration
{
    yydebug("package_declarative_item: group_declaration.");
    yyerror("package_declarative_item: group_declaration is not supported.");
};


package_declarative_part:
/* empty */
{
    yydebug("package_declarative_part: empty.");
    RULE_BREAK_MACRO $$ = new BList<Declaration>();
}
| package_declarative_part package_declarative_item
{
    yydebug("package_declarative_part: package_declarative_part package_declarative_item.");
    RULE_BREAK_MACRO
    $$ = $1;
    $$->merge( *$2 );
    delete $2;
};


parameter_specification:
identifier t_IN discrete_range
{
    yydebug("parameter_specification: identifier t_IN discrete_range.");
    RULE_BREAK_MACRO

    Range * range_o = dynamic_cast<Range*>( $3 );
    messageAssert(range_o != nullptr,
                  "parameter_specification: unexpected range specification", $3, nullptr);

    $$ = parserInstance->parse_ParameterSpecification( $1, range_o );
};


physical_literal:
//physical_literal_no_name
abstract_literal /*unit_*/ name
{
    yydebug("physical_literal: abstract_literal /*unit_*/ name.");
    yyerror("physical_literal: abstract_literal /*unit_*/ name is not supported.");
}
| name
{
    yydebug("physical_literal: name.");
    yyerror("physical_literal: name is not supported.");
};

///* Added, to solve some conflicts. */
//physical_literal_no_name:
//abstract_literal /*unit_*/ name
//{
//    yydebug("physical_literal_no_name: abstract_literal name.");
//    yyerror("physical_literal_no_name: abstract_literal name is not supported.");
//};


physical_type_definition:
range_constraint
t_UNITS
primary_unit_declaration
secondary_unit_declaration_list
t_END t_UNITS /*physical_type_*/ identifier_opt
{
    yydebug("range_constraint t_UNITS primary_unit_declaration "
            "secondary_unit_declaration_list t_END t_UNITS identifier_opt.");
    yyerror("range_constraint t_UNITS primary_unit_declaration "
            "secondary_unit_declaration_list t_END t_UNITS identifier_opt is not supported.");
};


port_clause:
t_PORT t_LeftParen port_list t_RightParen t_Semicolon
{
    yydebug("port_clause: t_PORT t_LeftParen port_list t_RightParen t_Semicolon.");
    RULE_BREAK_MACRO $$ = $3;
};


port_clause_opt:
/* empty */
{
    yydebug("port_clause_opt: empty.");
    RULE_BREAK_MACRO $$ = new BList<Port>();
}
| port_clause
{
    yydebug("port_clause_opt: port_clause.");
    RULE_BREAK_MACRO $$ = $1;
};

port_list:
/*port_*/ interface_list
{
    yydebug( "port_list: interface_list." );
    RULE_BREAK_MACRO $$ = parserInstance->parse_PortList( $1 );
};


port_map_aspect:
t_PORT t_MAP t_LeftParen /*port_*/ association_list t_RightParen
{
    yydebug("port_map_aspect: t_PORT t_MAP t_LeftParen port_association_list t_RightParen.");
    RULE_BREAK_MACRO $$ = $4;
};

port_map_aspect_opt:
/* empty */
{
    yydebug("port_map_aspect_opt: empty.");
    RULE_BREAK_MACRO $$ = new BList<PortAssign>();
}
| port_map_aspect
{
    yydebug("port_map_aspect_opt: port_map_aspect.");
    RULE_BREAK_MACRO $$ = $1;
};

/* Removed due to conflicts.*/
/* Removed, since added into name. See the top of this file. */
//prefix:
//function_call
//{
//    yydebug("prefix: function_call.");
//    $$ = $1;
//};
//| name
//{
//    yydebug("prefix: name.");
//    $$ = $1;
//};


primary:
name
{
    yydebug("primary: name.");
    RULE_BREAK_MACRO $$ = $1;
}
| literal
{
    yydebug("primary: literal.");
    RULE_BREAK_MACRO $$ = $1;
}
| aggregate
{
    yydebug("primary: aggregate.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_Primary( $1 );
}
| qualified_expression
{
    yydebug("primary: qualified_expression.");
    RULE_BREAK_MACRO $$ = $1;
}
| allocator
{
    yydebug("primary: allocator.");
    RULE_BREAK_MACRO $$ = $1;
}
// Removed, since added into name. See the top of this file.
//| function_call
// Removed, since has the same syntax of function_call.
// See the top of this file.
//| type_conversion
// Removed, since has the same syntax of aggregate.
// See the top of this file.
//| t_LeftParen expression t_RightParen
;


primary_unit:
entity_declaration
{
    yydebug("primary_unit: entity_declaration.");
    RULE_BREAK_MACRO

    $$ = new primary_unit_t();
    $$->entity_declaration = $1;
}
| configuration_declaration
{
    yydebug("primary_unit: configuration_declaration.");
    RULE_BREAK_MACRO $$ = new primary_unit_t();
}
| package_declaration
{
    yydebug("primary_unit: package_declaration.");
    RULE_BREAK_MACRO

    $$ = new primary_unit_t();
    $$->package_declaration = $1;
};


primary_unit_declaration:
identifier t_Semicolon
{
    yydebug("primary_unit_declaration: identifier t_Semicolon.");
    yyerror("primary_unit_declaration: identifier t_Semicolon is not supported.");
};


/* WARNING: since name has a rule similar to a pcall,
 * we simply call the name rule parsing, and then refine it into a pcall.
 */
procedure_call:
//name t_LeftParen actual_parameter_part t_RightParen
/*procedure_*/ name
{
    yydebug("procedure_call: name.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ProcedureCall( $1 );
};


procedure_call_statement:
procedure_call t_Semicolon
{
    yydebug("procedure_call_statement: procedure_call t_Semicolon");
    RULE_BREAK_MACRO $$ = $1;
};


process_declarative_item:
subprogram_declaration
{
    yydebug("process_declarative_item: subprogram_declaration.");
    RULE_BREAK_MACRO

    $$ = new BList<Declaration>();
    $$->push_back( $1 );
}
| subprogram_body
{
    yydebug("process_declarative_item: subprogram_body.");
    RULE_BREAK_MACRO

    $$ = new BList<Declaration>();
    $$->push_back( $1 );
}
| type_declaration
{
    yydebug("process_declarative_item: type_declaration.");
    RULE_BREAK_MACRO

    $$ = new BList<Declaration>();
    $$->push_back( $1 );
}
| subtype_declaration
{
    yydebug("process_declarative_item: subtype_declaration.");
    RULE_BREAK_MACRO

    $$ = new BList<Declaration>();
    $$->push_back( $1 );
}
| constant_declaration
{
    yydebug("process_declarative_item: costant_declaration.");
    RULE_BREAK_MACRO $$ = $1;
}
| variable_declaration
{
    yydebug("process_declarative_item: variable_declaration.");
    RULE_BREAK_MACRO $$ = $1;
}
| file_declaration
{
    yydebug("process_declarative_item: file_declaration.");
    RULE_BREAK_MACRO $$ = $1;
}
| alias_declaration
{
    yydebug("process_declarative_item: alias_declaration.");
    yyerror("process_declarative_item: alias_declaration is not supported.");
}
| attribute_declaration
{
    yydebug("process_declarative_item: attribute_declaration.");
    RULE_BREAK_MACRO
    $$ = new BList<Declaration>();
}
| attribute_specification
{
    yydebug("process_declarative_item: attribute_specification.");
    RULE_BREAK_MACRO
    $$ = new BList<Declaration>();
}
| use_clause
{
    yydebug("process_declarative_item: use_clause.");
    yyerror("process_declarative_item: use_clause is not supported.");
    RULE_BREAK_MACRO $$ = reinterpret_cast< BList<Declaration>* >($1);
}
| group_template_declaration
{
    yydebug("process_declarative_item: group_template_declaration.");
    yyerror("process_declarative_item: group_template_declaration is not supported.");
}
| group_declaration
{
    yydebug("process_declarative_item: group_declaration.");
    yydebug("process_declarative_item: group_declaration is not supported.");
};

process_declarative_part:
/* empty */
{
    yydebug("process_declarative_part: empty.");
    RULE_BREAK_MACRO $$ = new BList<Declaration>();
}
| process_declarative_part process_declarative_item
{
    yydebug("process_declarative_part: process_declarative_part process_declarative_item.");
    RULE_BREAK_MACRO

    $$ = $1;
    $$->merge( *$2 );
    delete $2;
};


process_statement:
/* 1 process_*/ identifier_colon_opt
t_POSTPONED_opt
t_PROCESS sensitivity_list_paren_opt t_IS_opt
process_declarative_part
t_BEGIN
process_statement_part
t_END t_PROCESS /*process_*/ identifier_opt t_Semicolon
{
    yydebug("process_statement: identifier_colon_opt t_POSTPONED_opt t_PROCESS "
            "sensitivity_list_paren_opt t_IS_opt process_declarative_part "
            "t_BEGIN process_statement_part t_END t_POSTPONED_opt t_PROCESS"
            "identifier_opt t_Semicolon.");
    RULE_BREAK_MACRO
    parserInstance->setCurrentBlockCodeInfo( $3 );
    $$ = parserInstance->parse_ProcessStatement( $1, $4, $6, $8, $11);
};


process_statement_part:
/* empty */
{
    yydebug("process_statement_part: empty.");
    RULE_BREAK_MACRO $$ = new BList<Action>();
}
| process_statement_part sequential_statement
{
    yydebug("process_statement_part: process_statement_part sequential_statement.");
    RULE_BREAK_MACRO

    $$ = $1;
    $$->merge(*$2);
    delete $2;
};



protected_type_body:
t_PROTECTED t_BODY
protected_type_body_declarative_part
t_END t_PROTECTED t_BODY /*protected_type_*/ identifier_opt
{
    yydebug("protected_type_body: t_PROTECTED t_BODY protected_type_body_declarative_part "
            "t_END t_PROTECTED t_BODY identifier_opt.");
    yyerror("protected_type_body: t_PROTECTED t_BODY protected_type_body_declarative_part "
            "t_END t_PROTECTED t_BODY identifier_opt is not supported.");
};


protected_type_body_declarative_item:
subprogram_declaration
{
    yydebug("protected_type_body_declarative_item: subprogram_declaration.");
    yyerror("protected_type_body_declarative_item: subprogram_declaration is not supported.");
}
| subprogram_body
{
    yydebug("protected_type_body_declarative_item: subprogram_body.");
    yyerror("protected_type_body_declarative_item: subprogram_body is not supported.");
}
| type_declaration
{
    yydebug("protected_type_body_declarative_item: type_declaration.");
    yyerror("protected_type_body_declarative_item: type_declaration is not supported.");
}
| subtype_declaration
{
    yydebug("protected_type_body_declarative_item: subtype_declaration.");
    yyerror("protected_type_body_declarative_item: subtype_declaration is not supported.");
}
| constant_declaration
{
    yydebug("protected_type_body_declarative_item: constant_declaration.");
    yyerror("protected_type_body_declarative_item: constant_declaration is not supported.");
}
| variable_declaration
{
    yydebug("protected_type_body_declarative_item: variable_declaration.");
    yyerror("protected_type_body_declarative_item: variable_declaration is not supported.");
}
| file_declaration
{
    yydebug("protected_type_body_declarative_item: file_declaration.");
    yyerror("protected_type_body_declarative_item: variable_declaration is not supported.");
}
| alias_declaration
{
    yydebug("protected_type_body_declarative_item: alias_declaration.");
    yyerror("protected_type_body_declarative_item: alias_declaration is not supported.");
}
| attribute_declaration
{
    yydebug("protected_type_body_declarative_item: attribute_declaration.");
    yyerror("protected_type_body_declarative_item: attribute_declaration is not supported");
}
| attribute_specification
{
    yydebug("protected_type_body_declarative_item: attribute_specification.");
    yyerror("protected_type_body_declarative_item: attribute_specification is not supported.");
}
| use_clause
{
    yydebug("protected_type_body_declarative_item: use_clause.");
    yyerror("protected_type_body_declarative_item: use_clause is not supported.");
}
| group_template_declaration
{
    yydebug("protected_type_body_declarative_item: group_template_declaration.");
    yyerror("protected_type_body_declarative_item: group_template_declaration is not supported.");
}
| group_declaration
{
    yydebug("protected_type_body_declarative_item: group_declaration.");
    yyerror("protected_type_body_declarative_item: group_declaration is not supported.");
};



protected_type_body_declarative_part:
/* empty */
{
    yydebug("protected_type_body_declarative_part: empty.");
    yyerror("protected_type_body_declarative_part: empty is not supported.");
}
| protected_type_body_declarative_part protected_type_body_declarative_item
{
    yydebug("protected_type_body_declarative_part: protected_type_body_declarative_part protected_type_body_declarative_item.");
    yyerror("protected_type_body_declarative_part: protected_type_body_declarative_part protected_type_body_declarative_item is not supported.");
};



protected_type_declaration:
t_PROTECTED
protected_type_declarative_part
t_END t_PROTECTED /*protected_type_*/ identifier_opt
{
    yydebug("protected_type_declaration: t_PROTECTED protected_type_declarative_part "
            "t_END t_PROTECTED identifier_opt.");
    yyerror("protected_type_declaration: t_PROTECTED protected_type_declarative_part "
            "t_END t_PROTECTED identifier_opt is not supported.");

};

protected_type_declarative_item:
subprogram_specification
{
    yydebug("protected_type_declarative_item: subprogram_specification.");
    yyerror("protected_type_declarative_item: subprogram_specification is not supported.");
}
| attribute_specification
{
    yydebug("protected_type_declarative_item: attribute_specification.");
    yyerror("protected_type_declarative_item: attribute_specification is nto supported.");
}
| use_clause
{
    yydebug("protected_type_declarative_item: use_clause.");
    yyerror("protected_type_declarative_item: use_clause.");
};


protected_type_declarative_part:
/* empty */
{
    yydebug("protected_type_declarative_part: empty.");
    yyerror("protected_type_declarative_part: empty is not supported.");
}
| protected_type_declarative_part protected_type_declarative_item
{
    yydebug("protected_type_declarative_part: protected_type_declarative_part protected_type_declarative_item.");
    yyerror("protected_type_declarative_part: protected_type_declarative_part protected_type_declarative_item is not supported.");
};



protected_type_definition:
protected_type_declaration
{
    yydebug("protected_type_definition: protected_type_declaration.");
    yyerror("protected_type_definition: protected_type_declaration is not supported.");
}
| protected_type_body
{
    yydebug("protected_type_definition: protected_type_body.");
    yyerror("protected_type_definition: protected_type_body is not supported.");
};


qualified_expression:
/* Removed. Same syntax of the following. See the top of this file. */
///* type_mark */ mark t_Apostrophe t_LeftParen expression t_RightParen
//{
//    yydebug("qualified_expression: /* type_mark */ mark t_Apostrophe t_LeftParen expression t_RightParen.");
//    yyerror("qualified_expression: /* type_mark */ mark t_Apostrophe t_LeftParen expression t_RightParen. is not supported");
//}
//|
name t_Apostrophe aggregate
{
    yydebug("qualified_expression: name t_Apostrophe aggregate.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_QualifiedExpression( $1, $3 );
};


range:
simple_expression %prec LOW
///*range_*/ attribute_name %prec LOW
{
    yydebug("range: attribute_name.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_Range( $1 );
}
| simple_expression direction simple_expression %prec HIGH
{
    yydebug("range: simple_expression direction simple_expression.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_Range( $1, $2, $3 );
};


range_constraint:
t_RANGE range
{
    yydebug("range_constraint: t_RANGE range.");
    RULE_BREAK_MACRO $$ = $2;
};


record_type_definition:
t_RECORD
element_declaration_list
t_END t_RECORD /*5 record_type_*/ identifier_opt
{
    yydebug("record_type_definition: t_RECORD element_declaration_list "
            "t_END t_RECORD identifier_opt.");
    RULE_BREAK_MACRO

    $$ = parserInstance->parse_RecordTypeDefinition( $2 );
    if ( $5 != nullptr )
    {
        delete $5;
    }
};


relation:
shift_expression relational_operator shift_expression
{
    yydebug("relation: shift_expression relational_operator shift_expression.");
    RULE_BREAK_MACRO

    Expression * eo = hif_factory->expression( $1, $2, $3 );
    $$ = eo;
    parserInstance->setCodeInfo( $$ );
}
| shift_expression
{
    yydebug("relation: shift_expression.");
    RULE_BREAK_MACRO $$ = $1;
};



relational_operator:
t_EQSym
{
    yydebug("relational_operator: t_EQSym.");
    RULE_BREAK_MACRO $$ = op_eq;
}
| t_NESym
{
    yydebug("relational_operator: t_NESym.");
    RULE_BREAK_MACRO $$ = op_neq;
}
| t_LTSym
{
    yydebug("relational_operator: t_LTSym.");
    RULE_BREAK_MACRO $$ = op_lt;
}
| t_LESym
{
    yydebug("relational_operator: t_LESym.");
    RULE_BREAK_MACRO $$ = op_le;
}
| t_GTSym
{
    yydebug("relational_operator: t_GTSym.");
    RULE_BREAK_MACRO $$ = op_gt;
}
| t_GESym
{
    yydebug("relational_operator: t_GESym.");
    RULE_BREAK_MACRO $$ = op_ge;
};


report_statement:
identifier_colon_opt t_REPORT expression t_SEVERITY expression t_Semicolon
{
    yydebug("report_statement: identifier_colon_opt t_REPORT expression t_SEVERITY expression t_Semicolon.");
    RULE_BREAK_MACRO
    assert_directive_t * tmp = parserInstance->parse_AssertDirective(nullptr, $3, $5);
    $$ = parserInstance->parse_Assertion(tmp);
    delete $1;
}
| identifier_colon_opt t_REPORT expression t_Semicolon
{
    yydebug("report_statement: identifier_colon_opt t_REPORT expression t_Semicolon.");
    RULE_BREAK_MACRO
    assert_directive_t * tmp = parserInstance->parse_AssertDirective(nullptr, $3, nullptr);
    $$ = parserInstance->parse_Assertion(tmp);
    delete $1;
};


return_statement:
identifier_colon_opt t_RETURN expression_opt t_Semicolon
{
    yydebug("return_statement: identifier_colon_opt t_RETURN expression_opt t_Semicolon.");
    RULE_BREAK_MACRO

    delete $1;
    $$ = parserInstance->parse_ReturnStatement( $3 );
};


scalar_type_definition:
enumeration_type_definition
{
    yydebug("scalar_type_definition: enumeration_type_definition.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ScalarTypeDefinition( $1 );
}
/* WARNING: These rules are the same!
 * Adding a new unifying rule:
| integer_type_definition
{
    yydebug("scalar_type_definition: integer_type_definition.");
    $$ = $1;
}
| floating_type_definition
{
    yydebug("scalar_type_definition: floating_type_definition.");
    $$ = $1;
}
*/
| floating_or_integer_type_definition
{
    yydebug("scalar_type_definition: floating_or_integer_type_definition.");
    RULE_BREAK_MACRO $$ = $1;
}
| physical_type_definition
{
    yydebug("scalar_type_definition: physical_type_definition.");
    yyerror("scalar_type_definition: physical_type_definition is not supported.");
};


secondary_unit:
architecture_body
{
    yydebug("secondary_unit: architecture_body.");
    RULE_BREAK_MACRO

    $$ = new secondary_unit_t();
    $$->architecture_body = $1;
}
| package_body
{
    yydebug("secondary_unit: architecture_body.");
    RULE_BREAK_MACRO

    $$ = new secondary_unit_t();
    $$->package_body = $1;
};


secondary_unit_declaration:
identifier t_EQSym physical_literal t_Semicolon
{
    yydebug("secondary_unit_declaration: identifier t_EQSym physical_literal t_Semicolon.");
    yyerror("secondary_unit_declaration: identifier t_EQSym physical_literal t_Semicolon is tno supported.");
};

secondary_unit_declaration_list:
/* empty */
{
    yydebug("secondary_unit_declaration_list: empty.");
    yydebug("secondary_unit_declaration_list: empty is not supported.");
}
| secondary_unit_declaration_list secondary_unit_declaration
{
    yydebug("secondary_unit_declaration_list: secondary_unit_declaration_list secondary_unit_declaration.");
    yyerror("secondary_unit_declaration_list: secondary_unit_declaration_list secondary_unit_declaration is not supported.");
};


selected_name:
name t_Dot suffix
{
    yydebug("selected_name: name t_DOT suffix.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_SelectedName( $1, $3 );
};


selected_name_list:
selected_name_list t_Comma selected_name
{
    yydebug("selected_name_list: selected_name_list t_Comma selected_name.");
    RULE_BREAK_MACRO

    $$ = $1;
    $$->push_back( $3 );
}
| selected_name
{
    yydebug("selected_name_list: selected_name.");
    RULE_BREAK_MACRO

    $$ = new BList<FieldReference>();
    $$->push_back( $1 );
};


selected_signal_assignment:
t_WITH expression t_SELECT
target t_LESym options selected_waveforms t_Semicolon
{
    yydebug("t_WITH expression t_SELECT target t_LESym options selected_waveforms t_Semicolon.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_SelectedSignalAssignment( $2, $4, $7);
};


selected_waveforms:
selected_waveforms_when
{
    yydebug("selected_waveforms: selected_waveforms_when.");
    RULE_BREAK_MACRO

    $$ = new BList<WithAlt>();
    $$->push_back( $1 );
}
| selected_waveforms t_Comma selected_waveforms_when
{
    yydebug("selected_waveforms: selected_waveforms t_Comma selected_waveforms_when.");
    RULE_BREAK_MACRO

    $$ = $1;
    $$->push_back( $3 );
};

selected_waveforms_when:
waveform t_WHEN choices
{
    yydebug("selected_waveforms_when: waveform t_WHEN choices.");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_SelectedWaveformsWhen( $1, $3 );
};


sensitivity_clause:
t_ON sensitivity_list
{
    yydebug("sensitivity_clause: t_ON sensitivity_list.");
    RULE_BREAK_MACRO $$ = $2;
};


sensitivity_clause_opt:
/*empty*/
{
    yydebug("sensitivity_clause_opt: empty.");
    RULE_BREAK_MACRO $$ = nullptr;
}
| sensitivity_clause
{
    yydebug("sensitivity_clause_opt: sensitivity_clause.");
    RULE_BREAK_MACRO $$ = $1;
};


sensitivity_list:
/*signal_*/ sensitivity_list t_Comma name
{
    yydebug("sensitivity_list: sensitivity_list t_Comma name.");
    RULE_BREAK_MACRO

    $$ = $1;
    $$->push_back( $3 );
}
| name
{
    yydebug("sensitivity_list: name.");
    RULE_BREAK_MACRO

    $$ = new BList<Value>();
    $$->push_back( $1 );
};

sensitivity_list_paren_opt:
/* empty */
{
    yydebug("sensitivity_list_paren_opt: empty.");
    RULE_BREAK_MACRO $$ = new BList<Value>();
}
| t_LeftParen sensitivity_list t_RightParen
{
    yydebug("sensitivity_list_paren_opt: t_LeftParen sensitivity_list t_RightParen.");
    RULE_BREAK_MACRO $$ = $2;
};


sequence_of_statements:
/* empty */
{
    yydebug("sequence_of_statements: empty.");
    RULE_BREAK_MACRO $$ = new BList<Action>();
}
| sequence_of_statements sequential_statement
{
    yydebug("sequence_of_statements: sequence_of_statements sequential_statement.");
    RULE_BREAK_MACRO

    $$ = $1;
    $$->merge( *$2 );
    delete $2;
};



sequential_statement:
wait_statement
{
    yydebug("sequential_statement: wait_statement");
    RULE_BREAK_MACRO
    $$ = new BList<Action>();
    $$->push_back($1);
}
| assertion_statement
{
    yydebug("sequential_statement: assertion_statement.");
    RULE_BREAK_MACRO
    $$ = new BList<Action>();
    $$->push_back($1);
}
| report_statement
{
    yydebug("sequential_statement: report_statement");
    RULE_BREAK_MACRO
    $$ = new BList<Action>();
    $$->push_back($1);
}
| signal_assignment_statement
{
    yydebug("sequential_statement: signal_assignment_statement.");
    RULE_BREAK_MACRO
    $$ = &$1->toOtherBList<Action>();
}
| variable_assignment_statement
{
    yydebug("sequential_statement: variable_assignment_statement");
    RULE_BREAK_MACRO
    $$ = new BList<Action>();
    $$->push_back($1);
}
| procedure_call_statement
{
    yydebug("sequential_statement: procedure_call_statement.");
    RULE_BREAK_MACRO
    $$ = new BList<Action>();
    $$->push_back($1);
}
| if_statement
{
    yydebug("sequential_statement: if_statement.");
    RULE_BREAK_MACRO
    $$ = new BList<Action>();
    $$->push_back($1);
}
| case_statement
{
    yydebug("sequential_statement: case_statement.");
    RULE_BREAK_MACRO
    $$ = new BList<Action>();
    $$->push_back($1);
}
| loop_statement
{
    yydebug("sequential_statement: loop_statement.");
    RULE_BREAK_MACRO
    $$ = new BList<Action>();
    $$->push_back($1);
}
| next_statement
{
    yydebug("sequential_statement: next_statement.");
    RULE_BREAK_MACRO
    $$ = new BList<Action>();
    $$->push_back($1);
}
| exit_statement
{
    yydebug("sequential_statement: exit_statement.");
    RULE_BREAK_MACRO
    $$ = new BList<Action>();
    $$->push_back($1);
}
| return_statement
{
    yydebug("sequential_statement: return_statement.");
    RULE_BREAK_MACRO
    $$ = new BList<Action>();
    $$->push_back($1);
}
| null_statement
{
    yydebug("sequential_statement: null_statement.");
    RULE_BREAK_MACRO
    $$ = new BList<Action>();
    $$->push_back($1);
};


shift_expression:
shift_expression shift_operator simple_expression
{
    yydebug("shift_expression: shift_expression shift_operator simple_expression.");
    RULE_BREAK_MACRO

    Expression * eo = hif_factory->expression( $1, $2, $3 );
    $$ = eo;
    parserInstance->setCodeInfo( $$ );
}
| simple_expression
{
    yydebug("shift_expression: simple_expression.");
    RULE_BREAK_MACRO $$ = $1;
};

shift_operator:
t_SLL
{
    yydebug("shift_operator: t_SLL.");
    RULE_BREAK_MACRO $$ = op_sll;
}
| t_SRL
{
    yydebug("shift_operator: t_SRL.");
    RULE_BREAK_MACRO $$ = op_srl;
}
| t_SLA
{
    yydebug("shift_operator: t_SLA.");
    RULE_BREAK_MACRO $$ = op_sra;
}
| t_SRA
{
    yydebug("shift_operator: t_SRA.");
    RULE_BREAK_MACRO $$ = op_sra;
}
| t_ROL
{
    yydebug("shift_operator: t_ROL.");
    RULE_BREAK_MACRO $$ = op_rol;
}
| t_ROR
{
    yydebug("shift_operator: t_ROR.");
    RULE_BREAK_MACRO $$ = op_ror;
};


sign:
t_Plus
{
    yydebug("sign: t_Plus.");
    RULE_BREAK_MACRO $$ = op_plus;
}
| t_Minus
{
    yydebug("sign: t_Minus.");
    RULE_BREAK_MACRO $$ = op_minus;
};

signal_assignment_statement:
target t_LESym delay_mechanism waveform t_Semicolon
{
    yydebug("signal_assignment_statement: target t_LESym "
            "delay_mechanism waveform t_Semicolon.");
    yyerror("signal_assignment_statement: target t_LESym "
            "delay_mechanism waveform t_Semicolon is not supported.");
}
| target t_LESym waveform t_Semicolon
{
    yydebug("signal_assignment_statement: target t_LESym "
            "waveform t_Semicolon.");
    RULE_BREAK_MACRO
    parserInstance->setCurrentBlockCodeInfo($1);
    $$ = parserInstance->parse_SignalAssignmentStatement( nullptr, $1, $3 );
}
| identifier t_Colon target t_LESym delay_mechanism waveform t_Semicolon
{
    yydebug("signal_assignment_statement: identifier t_Colon target t_LESym "
            "delay_mechanism waveform t_Semicolon.");
    yyerror("signal_assignment_statement: identifier t_Colon target t_LESym "
            "delay_mechanism waveform t_Semicolon is not supported.");
}
| identifier t_Colon target t_LESym waveform t_Semicolon
{
    yydebug("signal_assignment_statement: identifier t_Colon target t_LESym "
            "waveform t_Semicolon.");
    RULE_BREAK_MACRO
    parserInstance->setCurrentBlockCodeInfo($3);
    $$ = parserInstance->parse_SignalAssignmentStatement( nullptr, $3, $5 );
    delete $1;
};


signal_declaration:
t_SIGNAL identifier_list t_Colon subtype_indication signal_kind t_VarAsgn expression t_Semicolon
{
    yydebug("t_SIGNAL identifier_list t_Colon subtype_indication signal_kind "
            "t_VarAsgn expression t_Semicolon.");
    yyerror("t_SIGNAL identifier_list t_Colon subtype_indication signal_kind "
            "t_VarAsgn expression t_Semicolon is not supported.");
}
| t_SIGNAL identifier_list t_Colon subtype_indication t_VarAsgn expression t_Semicolon
{
    yydebug("t_SIGNAL identifier_list t_Colon subtype_indication "
            "t_VarAsgn expression t_Semicolon.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_SignalDeclaration( $2, $4, $6 );
}
| t_SIGNAL identifier_list t_Colon subtype_indication signal_kind t_Semicolon
{
    yydebug("t_SIGNAL identifier_list t_Colon subtype_indication signal_kind "
            "t_Semicolon.");
    yyerror("t_SIGNAL identifier_list t_Colon subtype_indication signal_kind "
            "t_Semicolon is not supported.");
}
| t_SIGNAL identifier_list t_Colon subtype_indication t_Semicolon
{
    yydebug("t_SIGNAL identifier_list t_Colon subtype_indication t_Semicolon.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_SignalDeclaration( $2, $4 );
};


signal_kind:
t_REGISTER
{
    yydebug("signal_kind: t_REGISTER.");
    yyerror("signal_kind: t_REGISTER is not supported.");
}
| t_BUS
{
    yydebug("signal_kind: t_BUS.");
    yyerror("signal_kind: t_BUS is not supported.");
};

signal_list:
name_list
{
    yydebug("signal_list: name_list.");
    yyerror("signal_list: name_list is not supported.");
}
| t_OTHERS
{
    yydebug("signal_list: t_OTHERS.");
    yyerror("signal_list: t_OTHERS is not supported.");
}
| t_ALL
{
    yydebug("signal_list: t_ALL.");
    yyerror("signal_list: t_ALL is not supported.");
};


signature:
t_LeftBracket name_list t_RETURN name t_RightBracket
{
    yydebug("signature: name_list t_RETURN name.");
    yyerror("signature: name_list t_RETURN name is not supported.");
}
| t_LeftBracket name_list t_RightBracket
{
    yydebug("signature: name_list t_RETURN name.");
    yyerror("signature: name_list t_RETURN name is not supported.");
}
| t_LeftBracket t_RETURN name t_RightBracket
{
    yydebug("signature: t_RETURN name.");
    yyerror("signature: t_RETURN name is not supported.");
};


signature_opt:
/* empty */
{
    yydebug("signature_opt: empty.");
    //$$ = nullptr;
}
| signature
{
    yydebug("signature_opt: signature.");
    yyerror("signature_opt: signature is not suported.");
};

simple_expression:
sign simple_expression_support %prec HIGH
{
    yydebug("simple_expression: sign simple_expression_support.");
    RULE_BREAK_MACRO

    Expression * e = new Expression();
    parserInstance->setCodeInfo(e);
    e->setOperator( $1 );
    e->setValue1( $2 );
    $$ = e;
}
| simple_expression_support %prec LOW
{
    yydebug("simple_expression: simple_expression_support.");
    RULE_BREAK_MACRO $$ = $1;
};


simple_expression_support:
term %prec LOW
{
    yydebug("simple_expression_support: term.");
    RULE_BREAK_MACRO $$ = $1;
}
| simple_expression_support adding_operator term %prec HIGH
{
    yydebug("simple_expression_support: simple_expression_support adding_operator term.");
    RULE_BREAK_MACRO

    Expression * expr = new Expression();
    expr->setOperator( $2 );
    expr->setValue1( $1 );
    expr->setValue2( $3 );
    parserInstance->setCodeInfo(expr);
    $$ = expr;
};


string_literal:
t_StringLit
{
    yydebug("string_literal: t_StringLit.");
    RULE_BREAK_MACRO

    $$ = parserInstance->parse_StringLiteral( $1 );
    free($1.name);
};


subprogram_body:
/*1*/ subprogram_specification t_IS
/*3*/ subprogram_declarative_part
t_BEGIN
/*5*/ subprogram_statement_part
t_END /*7*/ subprogram_kind_opt /*8*/ designator_opt t_Semicolon
{
    yydebug("subprogram_body: subprogram_specification t_IS subprogram_declarative_part t_BEGIN "
            "subprogram_statement_part t_END subprogram_kind_opt designator_opt t_Semicolon.");
    RULE_BREAK_MACRO

    delete $8;
    $$ = parserInstance->parse_SubprogramBody( $1, $3, $5 );
};

subprogram_declaration:
subprogram_specification t_Semicolon
{
    yydebug("subprogram_declaration: subprogram_specification t_Semicolon.");
    RULE_BREAK_MACRO $$ = $1;
};

subprogram_declarative_item:
subprogram_declaration
{
    yydebug("subprogram_declarative_item: subprogram_declaration.");
    RULE_BREAK_MACRO

    $$ = new BList<Declaration>();
    $$->push_back( $1 );
}
| subprogram_body
{
    yydebug("subprogram_declarative_item: subprogram_body.");
    RULE_BREAK_MACRO

    $$ = new BList<Declaration>();
    $$->push_back( $1 );
}
| type_declaration
{
    yydebug("subprogram_declarative_item: type_declaration.");
    RULE_BREAK_MACRO

    $$ = new BList<Declaration>();
    $$->push_back( $1 );
}
| subtype_declaration
{
    yydebug("subprogram_declarative_item: subtype_declaration.");
    RULE_BREAK_MACRO

    $$ = new BList<Declaration>();
    $$->push_back( $1 );
}
| constant_declaration
{
    yydebug("subprogram_declarative_item: constant_declaration.");
    RULE_BREAK_MACRO $$ = $1;
}
| variable_declaration
{
    yydebug("subprogram_declarative_item: variable_declaration.");
    RULE_BREAK_MACRO $$ = $1;
}
| file_declaration
{
    yydebug("subprogram_declarative_item: file_declaration.");
    yyerror("subprogram_declarative_item: file_declaration is not supported.");
}
| alias_declaration
{
    yydebug("subprogram_declarative_item: alias_declaration.");
    RULE_BREAK_MACRO

    $$ = new BList<Declaration>();
    $$->push_back( $1 );
}
| attribute_declaration
{
    yydebug("subprogram_declarative_item: attribute_declaration.");
    RULE_BREAK_MACRO
    $$ = new BList<Declaration>();
}
| attribute_specification
{
    yydebug("subprogram_declarative_item: attribute_specification.");
    RULE_BREAK_MACRO
    $$ = new BList<Declaration>();
}
| use_clause
{
    yydebug("subprogram_declarative_item: use_clause.");
    yyerror("subprogram_declarative_item: use_clause is not supported.");
}
| group_template_declaration
{
    yydebug("subprogram_declarative_item: group_template_declaration.");
    yyerror("subprogram_declarative_item: group_template_declaration is not supported.");
}
| group_declaration
{
    yydebug("subprogram_declarative_item: group_declaration.");
    yyerror("subprogram_declarative_item: group_declaration is not supported.");
};

subprogram_declarative_part:
/* empty */
{
    yydebug("subprogram_declarative_part: empty.");
    RULE_BREAK_MACRO $$ = new BList<Declaration>();
}
| subprogram_declarative_part subprogram_declarative_item
{
    yydebug("subprogram_declarative_part: empty.");
    RULE_BREAK_MACRO

    $$ = $1;
    $$->merge( *$2 );
    delete $2;
};


subprogram_kind:
t_PROCEDURE
{
    yydebug("subprogram_kind: t_PROCEDURE.");
}
| t_FUNCTION
{
    yydebug("subprogram_kind: t_FUNCTION.");
};

subprogram_kind_opt:
/* empty */
{
    yydebug("subprogram_kind_opt: empty.");
}
| subprogram_kind
{
    yydebug("subprogram_kind_opt: subprogram_kind.");
};

subprogram_specification:
t_PROCEDURE designator formal_parameter_list_paren_opt
{
    yydebug("subprogram_specification: t_PROCEDURE designator formal_parameter_list_paren_opt.");
    RULE_BREAK_MACRO
    parserInstance->setCurrentBlockCodeInfo($1);
    $$ = parserInstance->parse_SubprogramSpecification( $2, $3 );
}
| /*1*/ subprogram_specification_pure_impure
 t_FUNCTION /*3*/ designator /*4*/ formal_parameter_list_paren_opt
t_RETURN /*6*/ name
{
    yydebug("subprogram_specification: subprogram_specification_pure_impure_opt "
            "t_FUNCTION designator formal_parameter_list_paren_opt t_RETURN name.");
    RULE_BREAK_MACRO
    parserInstance->setCurrentBlockCodeInfo($2);
    $$ = parserInstance->parse_SubprogramSpecification( $3, $4, $6);
}
| t_FUNCTION /*3*/ designator /*4*/ formal_parameter_list_paren_opt
t_RETURN /*6*/ name
{
    yydebug("subprogram_specification: subprogram_specification_pure_impure_opt "
            "t_FUNCTION designator formal_parameter_list_paren_opt t_RETURN name.");
    RULE_BREAK_MACRO
    parserInstance->setCurrentBlockCodeInfo($1);
    $$ = parserInstance->parse_SubprogramSpecification( $2, $3, $5);
};


subprogram_specification_pure_impure:
t_PURE
{
    yydebug("subprogram_specification_pure_impure_opt: t_PURE.");
    yyerror("subprogram_specification_pure_impure_opt: t_PURE is not supported.");
}
| t_IMPURE
{
    yydebug("subprogram_specification_pure_impure_opt: t_IMPURE.");
    yyerror("subprogram_specification_pure_impure_opt: t_IMPURE is not supported.");
};


subprogram_statement_part:
//sequential_statement_list
sequence_of_statements
{
    yydebug("subprogram_statement_part: sequential_statement_list.");
    RULE_BREAK_MACRO $$ = $1;
};


subtype_declaration:
t_SUBTYPE identifier t_IS subtype_indication_ext t_Semicolon
{
    yydebug("subtype_declaration: subtype identifier t_IS subtype_indication.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_SubtypeDeclaration( $2, $4 );
};

subtype_indication:
name range_constraint %prec HIGH
{
    yydebug("subtype_indication: name range_constraint.");
    RULE_BREAK_MACRO

    constraint_t * constraint = new constraint_t();
    constraint->range_constraint = $2;

    $$ = parserInstance->parse_SubtypeIndication( $1, constraint );
}
| name %prec LOW
{
    yydebug("subtype_indication: name.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_SubtypeIndication( $1, nullptr );
};


subtype_indication_ext:
subtype_indication
{
    $$ = $1;
}
| name name range_constraint
{
    yydebug("subtype_indication: name name constraint.");
    yyerror("subtype_indication: name name constraint is not supported.");
}
| name name
{
    yydebug("subtype_indication: name name.");
    yyerror("subtype_indication: name name is not supported.");
};


subtype_indication_colon_opt:
/* empty */
{
    yydebug("subtype_indication_colon_opt: empty.");
    RULE_BREAK_MACRO $$ = nullptr;
}
| t_Colon subtype_indication
{
    yydebug("subtype_indication_colon_opt: t_Colon subtype_indication.");
    RULE_BREAK_MACRO $$ = $2;
};



suffix:
identifier
{
    yydebug("suffix: identifier.");
    RULE_BREAK_MACRO $$ = $1;
}
| character_literal
{
    yydebug("suffix: character_literal.");
    RULE_BREAK_MACRO $$ = $1;
}
| operator_symbol
{
    yydebug("suffix: operator_symbol.");
    yyerror("suffix: operator_symbol is not supported.");
}
| t_ALL
{
    yydebug("suffix: t_ALL.");
    RULE_BREAK_MACRO

    Identifier * name_o = new Identifier( "all" );
    parserInstance->setCodeInfo( name_o );
    $$ = name_o;
};

target:
name
{
    yydebug("target: name.");
    RULE_BREAK_MACRO $$ = $1;
}
| aggregate
{
    yydebug("target: aggregate.");
    RULE_BREAK_MACRO $$ = $1;
};


term:
factor %prec LOW
{
    yydebug("term: factor.");
    RULE_BREAK_MACRO $$ = $1;
}
| term multiplying_operator factor %prec HIGH
{
    yydebug("term: term multiplying_operator factor.");
    RULE_BREAK_MACRO

    Expression * expr = new Expression();
    parserInstance->setCodeInfo( expr );
    expr->setOperator( $2 );
    expr->setValue1( $1 );
    expr->setValue2( $3 );

    $$ = expr;
};


timeout_clause:
t_FOR /*time_*/expression
{
    yydebug("timeout_clause: t_FOR expression.");
    RULE_BREAK_MACRO $$ = $2;
};

timeout_clause_opt:
/* empty */
{
    yydebug("timeout_clause_opt: empty.");
    RULE_BREAK_MACRO $$ = nullptr;
}
| timeout_clause
{
    yydebug("timeout_clause_opt: timeout_clause.");
    RULE_BREAK_MACRO $$ = $1;
};

/* WARNING: removed. See the top of this file.
type_conversion:
name t_LeftParen expression t_RightParen
{
    yydebug("type_conversion: name t_LeftParen expression t_RightParen.");
    $$ = new Cast();
    BList<Range> c;
    Identifier * no = dynamic_cast<Identifier*>($1);
    if( no == nullptr )
    {
    yyerror( "type_conversion: unsupported type name.", $1 );
    }
    $$->SetType( resolveType( no->getName(), &c ));
    $$->SetOp( $3 );
}
*/

type_declaration:
full_type_declaration
{
    yydebug("type_declaration: full_type_declaration.");
    RULE_BREAK_MACRO $$ = $1;
}
| incomplete_type_declaration
{
    yydebug("type_declaration: incomplete_type_declaration.");
    yyerror("type_declaration: incomplete_type_declaration is not supported.");
};


type_definition:
scalar_type_definition
{
    yydebug("type_definition: scalar_type_definition.");
    RULE_BREAK_MACRO $$ = $1;
}
| composite_type_definition
{
    yydebug("type_definition: composite_type_definition.");
    RULE_BREAK_MACRO $$ = $1;
}
| access_type_definition
{
    yydebug("type_definition: access_type_definition.");
    yyerror("type_definition: access_type_definition is not supported.");
}
| file_type_definition
{
    yydebug("type_definition: file_type_definition.");
    RULE_BREAK_MACRO $$ = $1;
}
| protected_type_definition
{
    yydebug("type_definition: protected_type_definition.");
    yyerror("type_definition: protected_type_definition is not supported.");
};

/* Removed due to conflicts. */
/*type_mark:
 name
{
    //type_ | subtype_
    yydebug("type_mark: name.");
    $$ = $1;
};*/

/* Removed since unuseful.
type_mark_list:
type_mark_list t_Comma type_mark
{
    yydebug("type_mark_list: type_mark_list t_Comma type_mark.");
    yyerror("type_mark_list: type_mark_list t_Comma type_mark is not supported.");
}

| type_mark
{
    yydebug("type_mark_list: type_mark.");
    yyerror("type_mark_list: type_mark is not supported.");
};
*/


t_ARCHITECTURE_opt:
/* empty */
{
    yydebug( "t_ARCHITECTURE_opt: empty."  );
}
| t_ARCHITECTURE
{
    yydebug( "t_ARCHITEECTURE_opt: t_ARCHITECTURE."  );
};

t_BUS_opt:
/* empty */
{
    yydebug( "t_BUS_opt: empty."  );
}
| t_BUS
{
    yydebug( "t_BUS_opt: t_BUS."  );
};



t_CONFIGURATION_opt:
/* empty */
{
    yydebug( "t_CONFIGURATION_opt: empty."  );
}
| t_CONFIGURATION
{
    yydebug( "t_CONFIGURATION_opt: t_CONFIGURATION."  );
};



t_ENTITY_opt:
/* empty */
{
    yydebug( "t_ENTITY_opt: empty."  );
}
| t_ENTITY
{
    yydebug( "t_ENTITY_opt: t_ENTITY."  );
};


t_IN_opt:
/* empty */
{
    yydebug( "t_IN_opt: empty."  );
    RULE_BREAK_MACRO $$ = false;
}
| t_IN
{
    yydebug( "t_IN_opt: t_IN."  );
    RULE_BREAK_MACRO $$ = true;
};


t_IS_opt:
/* empty */
{
    yydebug( "t_IS_opt: empty."  );
}
| t_IS
{
    yydebug( "t_IS_opt: t_IS."  );
};


t_PACKAGE_BODY_opt:
/* empty */
{
    yydebug( "t_PACKAGE_BODY_opt: empty."  );
}
| t_PACKAGE t_BODY
{
    yydebug( "t_IS_opt: t_PACKAGE_BODY."  );
};


t_POSTPONED_opt:
/* empty */
{
    yydebug( "t_POSTPONED_opt: empty."  );
}
| t_POSTPONED
{
    yydebug( "t_POSTPONED_opt: t_POSTPONED."  );
    yyerror( "t_POSTPONED_opt: t_POSTPONED is not supported."  );
};


unconstrained_array_definition:
t_ARRAY t_LeftParen index_subtype_definition_list t_RightParen
t_OF /*element_*/subtype_indication
{
    yydebug("unconstrained_array_definition: t_ARRAY t_LeftParen "
            "index_subtype_definition_list t_RightParen "
            "t_OF subtype_indication.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_UnconstrainedArrayDefinition( $3, $6 );
};


use_clause:
t_USE selected_name_list t_Semicolon
{
    yydebug("t_USE selected_name_list t_Semicolon.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_UseClause( $2 );
};

use_clause_list:
/* empty */
{
    yydebug( "use_clause_list: empty."  );
    RULE_BREAK_MACRO $$ = new BList<Library>();
}
| use_clause_list use_clause
{
    yydebug( "use_clause_list: use_clause_list use_clause."  );
    RULE_BREAK_MACRO

    $$ = $1;
    $$->merge( *$2 );
    delete $2;
};


variable_assignment_statement:
target t_VarAsgn expression t_Semicolon
{
    yydebug("variable_assignment_statement: target t_VarAsgn expression t_Semicolon.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_VariableAssignmentStatement( $1, $3 );
};


variable_declaration:
t_SHARED t_VARIABLE identifier_list t_Colon subtype_indication t_VarAsgn expression t_Semicolon
{
    yydebug("variable_declaration: t_SHARED t_VARIABLE identifier_list t_Colon "
            "subtype_indication t_VarAsgn expression t_Semicolon.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_VariableDeclaration( $3, $5, $7);

}
| t_VARIABLE identifier_list t_Colon subtype_indication t_VarAsgn expression t_Semicolon
{
    yydebug("variable_declaration: t_VARIABLE identifier_list t_Colon "
            "subtype_indication t_VarAsgn expression t_Semicolon.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_VariableDeclaration( $2, $4, $6);

}
| t_SHARED t_VARIABLE identifier_list t_Colon subtype_indication t_Semicolon
{
    yydebug("variable_declaration: t_SHARED t_VARIABLE identifier_list t_Colon "
            "subtype_indication t_Semicolon.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_VariableDeclaration( $3, $5 );
}
| t_VARIABLE identifier_list t_Colon subtype_indication t_Semicolon
{
    yydebug("variable_declaration: t_VARIABLE identifier_list t_Colon "
            "subtype_indication t_Semicolon.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_VariableDeclaration( $2, $4 );
};


wait_statement:
t_WAIT sensitivity_clause_opt condition_clause_opt timeout_clause_opt t_Semicolon
{
    yydebug("wait_statement: t_WAIT sensitivity_clause_opt "
            "condition_clause_opt timeout_clause_opt t_Semicolon.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_WaitStatement( $2, $3, $4 );
};


waveform:
waveform_element_list
{
    yydebug(" waveform: waveform_element_list.");
    RULE_BREAK_MACRO $$ = $1;
}
| t_UNAFFECTED
{
    yydebug(" waveform: t_UNAFFECTED.");
    yyerror(" waveform: t_UNAFFECTED isn't supported.");
};

waveform_element_list:
waveform_element_list t_Comma waveform_element
{
    yydebug("waveform_element_list: waveform_element_list t_Comma waveform_element" );
    RULE_BREAK_MACRO
    $1->push_back($3);
    $$ = $1;
}
| waveform_element
{
    yydebug( "waveform_element_list: waveform_element." );
    RULE_BREAK_MACRO

    $$ = new BList<Assign>();
    $$->push_back( $1 );
};

waveform_element:
expression
{
    yydebug( "waveform_element: expression." );
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_WaveformElement($1, nullptr);
}
| expression t_AFTER /*time_*/ expression
{
    yydebug( "waveform_element: expression t_AFTER /*time_*/ expression." );
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_WaveformElement($1, $3);
};










/* -----------------------------------------------------------------------
 *  PROPERTY SPECIFICATION LANGUAGE (PSL)
 * ----------------------------------------------------------------------- */

/*
    The PSL syntax refers to the following nonterminals of VHDL IEEE Std 1076 syntax:
    — block_declarative_item
    — concurrent_statement
    — design_unit
    — identifier
    — expression
    — entity_aspect

*/

/* -----------------------------------------------------------------------
 *  VERIFICATION UNITS
 * -----------------------------------------------------------------------
 */

verification_unit:
vunit_type /* psl_identifier */ identifier t_LeftBrace inherit_spec_list override_spec_list vunit_item_list t_RightBrace
{
    yydebug("verification_unit: vunit_type /* psl_identifier */ identifier t_LeftBrace inherit_spec_list "
            "override_spec_list vunit_item_list t_RightBrace");
    RULE_BREAK_MACRO
    parserInstance->parse_VerificationUnit($2, $6);
}
| vunit_type /* psl_identifier */ identifier t_LeftParen context_spec t_RightParen
t_LeftBrace inherit_spec_list override_spec_list vunit_item_list t_RightBrace
{
    yydebug("verification_unit: vunit_type /* psl_identifier */ identifier t_LeftParen context_spec t_RightParen "
            "t_LeftBrace inherit_spec_list override_spec_list vunit_item_list t_RightBrace");
    RULE_BREAK_MACRO
    parserInstance->parse_VerificationUnit($2, $4, $9);
};

inherit_spec_list:
/* empty */
{
    yydebug("inherit_spec_list: empty");
}
| inherit_spec_list inherit_spec
{
    yydebug("inherit_spec_list: inherit_spec_list inherit_spec");
    yyerror("inherit_spec_list: inherit_spec_list inherit_spec is not supported");
};

override_spec_list:
/* empty */
{
    yydebug("override_spec_list: empty");
}
| override_spec_list override_spec
{
    yydebug("override_spec_list: override_spec_list override_spec");
    yyerror("override_spec_list: override_spec_list override_spec is not supported");
};

vunit_item_list:
/* empty */
{
    yydebug("vunit_item_list: empty");
    RULE_BREAK_MACRO $$ = new std::list<vunit_item_t*>();
}
| vunit_item_list vunit_item
{
    yydebug("vunit_item_list: vunit_item_list vunit_item");
    RULE_BREAK_MACRO
    $$ = $1;
    $$->push_back( $2 );
};

vunit_type:
t_VUNIT
{
    yydebug("vunit_type: t_VUNIT");
    parserInstance->setCurrentBlockCodeInfo($1);
    parserInstance->setContextPsl();
}
| t_VPKG
{
    yydebug("vunit_type: t_VPKG");
    parserInstance->setCurrentBlockCodeInfo($1);
    parserInstance->setContextPsl();
}
| t_VPROP
{
    yydebug("vunit_type: t_VPROP");
    parserInstance->setCurrentBlockCodeInfo($1);
    parserInstance->setContextPsl();
}
| t_VMODE
{
    yydebug("vunit_type: t_VMODE");
    parserInstance->setCurrentBlockCodeInfo($1);
    parserInstance->setContextPsl();
};

context_spec:
binding_spec
{
    yydebug("context_spec: binding_spec");
    RULE_BREAK_MACRO $$ = $1;
}
| formal_parameter_list_psl
{
    yydebug("context_spec: formal_parameter_list_psl");
    yyerror("context_spec: formal_parameter_list_psl is not supported");
};

binding_spec:
hdl_module_name path_separator_instance_name_list
{
    yydebug("binding_spec: hierarchical_hdl_name");
    RULE_BREAK_MACRO $$ = $1;
};

//hierarchical_hdl_name:
//hdl_module_name path_separator_instance_name_list
//{
//    yydebug("hierarchical_hdl_name: hdl_module_name path_separator_instance_name_list");
//    yyerror("hierarchical_hdl_name: hdl_module_name path_separator_instance_name_list is not supported");
//};

path_separator_instance_name_list:
/* empty */
{
    yydebug("path_separator_instance_name_list: empty");
}
| path_separator_instance_name_list path_separator_instance_name
{
    yydebug("path_separator_instance_name_list: path_separator_instance_name_list path_separator_instance_name");
    yyerror("path_separator_instance_name_list: path_separator_instance_name_list path_separator_instance_name is not supported");
};

path_separator_instance_name:
t_Dot /* instance_name*/ /* hdl_or_psl_identifier */ identifier
{
    yydebug("path_separator_instance_name: t_Dot instance_name");
    yyerror("path_separator_instance_name: t_Dot instance_name is not supported");
}
| t_Slash /* instance_name*/ /* hdl_or_psl_identifier */ identifier
{
    yydebug("path_separator_instance_name: t_Slash instance_name");
    yyerror("path_separator_instance_name: t_Slash instance_name is not supported");
};

//hdl_module_name:
//hdl_module_name hdl_module_name_paren_opt
//{
//    yydebug("hdl_module_name: hdl_module_name hdl_module_name_paren_opt");
//    yyerror("hdl_module_name: hdl_module_name hdl_module_name_paren_opt is not supported");
//};

//hdl_module_name_paren_opt:
//t_LeftParen hdl_module_name t_RightParen
//{
//    yydebug("hdl_module_name_paren_opt: t_LeftParen hdl_module_name t_RightParen");
//    yyerror("hdl_module_name_paren_opt: t_LeftParen hdl_module_name t_RightParen is not supported");
//};

hdl_module_name:
identifier
{
    yydebug("hdl_module_name: identifier");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_HdlModuleName( $1 );
}
| identifier t_LeftParen identifier t_RightParen
{
    yydebug("hdl_module_name: identifier t_LeftParen identifier t_RightParen");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_HdlModuleName( $1, $3 );
};

inherit_spec:
t_INHERIT /* vunit_name */ /* hdl_or_psl_identifier */ identifier comma_vunit_name_list t_Semicolon
{
    yydebug("inherit_spec: t_INHERIT /* vunit_name */ /* hdl_or_psl_identifier */ identifier comma_vunit_name_list t_Semicolon");
    yyerror("inherit_spec: t_INHERIT /* vunit_name */ /* hdl_or_psl_identifier */ identifier comma_vunit_name_list t_Semicolon is not supported");
}
| t_NONTRANSITIVE t_INHERIT /* vunit_name */ /* hdl_or_psl_identifier */ identifier comma_vunit_name_list t_Semicolon
{
    yydebug("inherit_spec: t_NONTRANSITIVE t_INHERIT /* vunit_name */ /* hdl_or_psl_identifier */ identifier comma_vunit_name_list t_Semicolon");
    yyerror("inherit_spec: t_NONTRANSITIVE t_INHERIT /* vunit_name */ /* hdl_or_psl_identifier */ identifier comma_vunit_name_list t_Semicolon is not supported");
};

comma_vunit_name_list:
/* empty */
{
    yydebug("comma_vunit_name_list: empty");
}
| comma_vunit_name_list t_Comma /* vunit_name */ /* hdl_or_psl_identifier */ identifier
{
    yydebug("comma_vunit_name_list: comma_vunit_name_list t_Comma /* vunit_name */ /* hdl_or_psl_identifier */ identifier");
    yyerror("comma_vunit_name_list: comma_vunit_name_list t_Comma /* vunit_name */ /* hdl_or_psl_identifier */ identifier is not supported");
};

vunit_item:
psl_directive
{
    yydebug("vunit_item: psl_directive");
    RULE_BREAK_MACRO
    $$ = new vunit_item_t();
    $$->psl_directive = parserInstance->parse_PslDirective( $1 );
}
| HDL_DECL
{
    yydebug("vunit_item: HDL_DECL");
    RULE_BREAK_MACRO
    $$ = new vunit_item_t();
    $$->hdl_decl = $1;
}
| HDL_STMT
{
    yydebug("vunit_item: HDL_STMT");
    RULE_BREAK_MACRO
    $$ = new vunit_item_t();
    $$->concurrent_statement = $1;
}
| psl_declaration
{
    yydebug("vunit_item: psl_declaration");
    yyerror("vunit_item: psl_declaration is not supported");
}
| vunit_instance
{
    yydebug("vunit_item: vunit_INstance");
    yyerror("vunit_item: vunit_INstance is not supported");
};

vunit_instance:
/* label */ /* psl_identifier */ identifier t_Colon vunit_type /* hdl_or_psl_identifier */ identifier actual_parameter_list_paren_opt t_Semicolon
{
    yydebug("vunit_instance: /* label */ /* psl_identifier */ identifier t_Colon vunit_type "
            "/* hdl_or_psl_identifier */ identifier actual_parameter_list_paren_opt t_Semicolon");
    yyerror("vunit_instance: /* label */ /* psl_identifier */ identifier t_Colon vunit_type "
            "/* hdl_or_psl_identifier */ identifier actual_parameter_list_paren_opt t_Semicolon is not supported");
};

override_spec:
t_OVERRIDE /* name_list */ name_list_psl t_Semicolon
{
    yydebug("override_spec: t_OVERRIDE /* name_list */ name_list_psl t_Semicolon");
    yyerror("override_spec: t_OVERRIDE /* name_list */ name_list_psl t_Semicolon is not supported");
};

/* name_list */
name_list_psl:
name
{
    yydebug("name_list_psl: name");
    yyerror("name_list_psl: name is not supported");
}
| name_list_psl t_Comma name
{
    yydebug("name_list_psl: /* name_list */ name_list_psl t_Comma /* name_list */ name_list_psl");
    yyerror("name_list_psl: /* name_list */ name_list_psl t_Comma /* name_list */ name_list_psl is not supported");
};


/* -----------------------------------------------------------------------
 *  PSL DECLARATIONS
 * -----------------------------------------------------------------------
 */

psl_declaration:
property_declaration
{
    yydebug("psl_declaration: property_declaration");
    yyerror("psl_declaration: property_declaration is not supported");
}
| sequence_declaration
{
    yydebug("psl_declaration: sequence_declaration");
    yyerror("psl_declaration: sequence_declaration is not supported");
}
| clock_declaration
{
    yydebug("psl_declaration: clock_declaration");
    yyerror("psl_declaration: clock_declaration is not supported");
};

property_declaration:
t_PROPERTY /* psl_identifier */ identifier formal_parameter_list_psl_paren_opt DEF_SYM property t_Semicolon
{
    yydebug("property_declaration: t_PROPERTY /* psl_identifier */ identifier formal_parameter_list_psl_paren_opt DEF_SYM property t_Semicolon");
    yyerror("property_declaration:t_PROPERTY /* psl_identifier */ identifier formal_parameter_list_psl_paren_opt DEF_SYM property t_Semicolon is not supported");
};

formal_parameter_list_psl_paren_opt:
/* empty */
{
    yydebug("formal_parameter_list_psl_paren_opt: empty");
}
| t_LeftParen formal_parameter_list_psl t_RightParen
{
    yydebug("formal_parameter_list_psl_paren_opt: t_LeftParen formal_parmeter_list t_RightParen");
    yyerror("formal_parameter_list_psl_paren_opt: t_LeftParen formal_parmeter_list t_RightParen is not supported");
};

formal_parameter_list_psl:
formal_parameter_list_psl t_Semicolon formal_parameter
{
    yydebug("formal_parameter_list_psl: formal_parameter_list_psl t_Semicolon formal_parameter");
    yyerror("formal_parameter_list_psl: formal_parameter_list_psl t_Semicolon formal_parameter is not supported");
}
| formal_parameter
{
    yydebug("formal_parameter_list_psl: formal_parameter");
    yyerror("formal_parameter_list_psl: formal_parameter is not supported");
};

formal_parameter:
param_spec psl_identifier_list
{
    yydebug("formal_parameter: param_spec psl_identifier_list");
    yyerror("formal_parameter: param_spec psl_identifier_list is not supported");
};

psl_identifier_list:
psl_identifier_list t_Comma /* psl_identifier */ identifier
{
    yydebug("psl_identifier_list: psl_identifier_list t_Comma /* psl_identifier */ identifier");
    yyerror("psl_identifier_list: psl_identifier_list t_Comma /* psl_identifier */ identifier is not supported");
}
| /* psl_identifier */ identifier
{
    yydebug("psl_identifier_list: /* psl_identifier */ identifier");
    yyerror("psl_identifier_list: /* psl_identifier */ identifier is not supported");
};

param_spec:
t_CONST
{
    yydebug("param_spec: t_CONST");
    yyerror("param_spec: t_CONST is not supported");
}
| t_CONST value_parameter
{
    yydebug("param_spec: t_CONST value_parameter");
    yyerror("param_spec: t_CONST value_parameter is not supported");
}
| t_MUTABLE value_parameter
{
    yydebug("param_spec: t_MUTABLE value_parameter");
    yyerror("param_spec: t_MUTABLE value_parameter is not supported");
}
| value_parameter
{
    yydebug("param_spec: value_parameter");
    yyerror("param_spec: value_parameter is not supported");
}
| t_SEQUENCE
{
    yydebug("param_spec: t_SEQUENCE");
    yyerror("param_spec: t_SEQUENCE is not supported");
}
| t_PROPERTY
{
    yydebug("param_spec: t_PROPERTY");
    yyerror("param_spec: t_PROPERTY is not supported");
};

value_parameter:
hdl_type
{
    yydebug("value_parameter: hdl_type");
    yyerror("value_parameter: hdl_type is not supported");
}
| psl_type_class
{
    yydebug("value_parameter: psl_type_class");
    yyerror("value_parameter: psl_type_class is not supported");
};

hdl_type:
t_HDLTYPE HDL_VARIABLE_TYPE
{
    yydebug("hdl_type: t_HDLTYPE HDL_VARIABLE_TYPE");
    yyerror("hdl_type: t_HDLTYPE HDL_VARIABLE_TYPE is not supported");
};

psl_type_class:
t_BOOLEAN
{
    yydebug("psl_type_class: t_BOOLEAN");
    yyerror("psl_type_class: t_BOOLEAN is not supported");
}
| t_BIT
{
    yydebug("psl_type_class: t_BIT");
    yyerror("psl_type_class: t_BIT is not supported");
}
| t_BITVECTOR
{
    yydebug("psl_type_class: bitvector");
    yyerror("psl_type_class: bitvector is not supported");
}
| t_NUMERIC
{
    yydebug("psl_type_class: numeric");
    yyerror("psl_type_class: numeric is not supported");
}
| t_STRING
{
    yydebug("psl_type_class: string");
    yyerror("psl_type_class: string is not supported");
};

sequence_declaration:
t_SEQUENCE /* psl_identifier */ identifier formal_parameter_list_psl_paren_opt DEF_SYM sequence t_Semicolon
{
    yydebug("sequence_declaration: t_SEQUENCE /* psl_identifier */ identifier formal_parameter_list_psl_paren_opt DEF_SYM sequence t_Semicolon");
    yyerror("sequence_declaration: t_SEQUENCE /* psl_identifier */ identifier formal_parameter_list_psl_paren_opt DEF_SYM sequence t_Semicolon is not supported");
};

clock_declaration:
t_DEFAULT t_CLOCK DEF_SYM clock_expression t_Semicolon
{
    yydebug("clock_declaration: t_DEFAULT t_CLOCK DEF_SYM clock_expression t_Semicolon");
    yyerror("clock_declaration: t_DEFAULT t_CLOCK DEF_SYM clock_expression t_Semicolon is not supported");
};

clock_expression:
/* boolean_name */ /* hdl_or_psl_identifier */ identifier
{
    yydebug("clock_expression: /* boolean_name */ /* hdl_or_psl_identifier */ identifier");
    RULE_BREAK_MACRO $$ = $1;
}
| /* boolean_built_in_function_call */ built_in_function_call
{
    yydebug("clock_expression: /* boolean_build_in_function_call */ built_in_functionbuilt_in_function_call_call");
    yyerror("clock_expression: /* boolean_build_in_function_call */ built_in_function_call is not supported");
}
| t_LeftParen /* boolean */ hdl_or_psl_expression t_RightParen
{
    yydebug("clock_expression: t_LeftParen /* boolean */ hdl_or_psl_expression t_RightParen");
    RULE_BREAK_MACRO $$ = $2;
}
// NOTE: the same as above
//| t_LeftParen HDL_CLOCK_EXPR t_RightParen
;

actual_parameter_list:
actual_parameter_list t_Comma actual_parameter
{
    yydebug("actual_parameter_list: actual_parameter_list t_Comma actual_parameter");
    RULE_BREAK_MACRO
    $$ = $1;
    $$->push_back($3);
}
| actual_parameter
{
    yydebug("actual_parameter_list: actual_parameter");
    RULE_BREAK_MACRO
    $$ = new BList<Value>();
    $$->push_back($1);
};

actual_parameter:
///* anytype */ /* number */ hdl_or_psl_expression
//| sequence
//NOTE: property --> fl_property --> hdl_or_psl_expression
//NOTE: property --> fl_property --> sequence
property
{
    yydebug("actual_parameter: property");
    RULE_BREAK_MACRO $$ = $1;
};

/* -----------------------------------------------------------------------
 *  PSL DIRECTIVES
 * -----------------------------------------------------------------------
 */

psl_directive:
verification_directive
{
    yydebug("psl_directive: verification_directive");
    RULE_BREAK_MACRO $$ = $1;
}
| /* label */ identifier t_Colon verification_directive
{
    yydebug("psl_directive: identifier t_Colon verification_directive");
    RULE_BREAK_MACRO
    $$ = $3;
    Identifier * label = dynamic_cast<Identifier*>( $1 );
    messageAssert(label != nullptr, "Unexpected label identifier", nullptr, nullptr);
    $$->label = label;
};

verification_directive:
assert_directive
{
    yydebug("verification_directive: assert_directive");
    RULE_BREAK_MACRO
    $$ = new verification_directive_t();
    $$->assert_directive = $1;
}
| assume_directive
{
    yydebug("verification_directive: assume_directive");
    yyerror("verification_directive: assume_directive is not supported");
}
| restrict_directive
{
    yydebug("verification_directive: restrict_directive");
    yyerror("verification_directive: restrict_directive is not supported");
}
| restrict_excl_directive
{
    yydebug("verification_directive: restrict_excl_directive");
    yyerror("verification_directive: restrict_excl_directive is not supported");
}
| cover_directive
{
    yydebug("verification_directive: cover_directive");
    yyerror("verification_directive: cover_directive is not supported");
}
| fairness_statement
{
    yydebug("verification_directive: fairness_statement");
    yyerror("verification_directive: fairness_statement is not supported");
};

//
//  This rule is used also in VHDL grammar (See 'assertion' rule).
//
assert_directive:
t_ASSERT property t_Semicolon
{
    yydebug("assert_directive: t_ASSERT property t_Semicolon");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AssertDirective($2, nullptr, nullptr);
}
| t_ASSERT property t_REPORT /* string */ expression t_Semicolon
{
    yydebug("assert_directive: t_ASSERT property t_REPORT expression_Semicolon");
    RULE_BREAK_MACRO $$ = parserInstance->parse_AssertDirective($2, $4, nullptr);
}
//
// @NOTSTANDARD: SEVERITY is allowed only in VHDL flavor
//
| t_ASSERT property t_SEVERITY expression t_Semicolon
{
    yydebug("assert_directive: t_ASSERT property t_Semicolon");
    RULE_BREAK_MACRO $$ = parserInstance->parse_AssertDirective($2, nullptr, $4);
}
| t_ASSERT property t_REPORT /* string */ expression t_SEVERITY expression t_Semicolon
{
    yydebug("assert_directive: t_ASSERT property t_REPORT expression t_SEVERITY expression t_Semicolon");
    RULE_BREAK_MACRO $$ = parserInstance->parse_AssertDirective($2, $4, $6);
};

assume_directive:
t_ASSUME property t_Semicolon
{
    yydebug("assume_directive: t_ASSUME property t_Semicolon");
    yyerror("assume_directive: t_ASSUME property t_Semicolon is not supported");
};

restrict_directive:
t_RESTRICT sequence t_Semicolon
{
    yydebug("restrict_directive: t_RESTRICT sequence t_Semicolon");
    yyerror("restrict_directive: t_RESTRICT sequence t_Semicolon is not supported");
};

restrict_excl_directive:
t_RESTRICT_EXCL sequence t_Semicolon
{
    yydebug("restrict_excl_directive: t_RESTRICT_EXCL sequence t_Semicolon");
    yyerror("restrict_excl_directive: t_RESTRICT_EXCL sequence t_Semicolon is not supported");
};

cover_directive:
t_COVER sequence t_LeftBracket t_REPORT string t_RightBracket t_Semicolon
{
    yydebug("cover_directive: t_COVER sequence t_LeftBracket t_REPORT string t_RightBracket t_Semicolon");
    yyerror("cover_directive: t_COVER sequence t_LeftBracket t_REPORT string t_RightBracket t_Semicolon is not supported");
};

fairness_statement:
t_FAIRNESS /* boolean */ hdl_or_psl_expression t_Semicolon
{
    yydebug("fairness_statement: t_FAIRNESS  /* boolean */ hdl_or_psl_expression t_Semicolon");
    yyerror("fairness_statement: t_FAIRNESS  /* boolean */ hdl_or_psl_expression t_Semicolon is not supported");
}
| t_STRONG t_FAIRNESS /* boolean */ hdl_or_psl_expression t_Comma /* boolean */ hdl_or_psl_expression t_Semicolon
{
    yydebug("fairness_statement: t_STRONG t_FAIRNESS /* boolean */ hdl_or_psl_expression t_Comma  /* boolean */ hdl_or_psl_expression t_Semicolon");
    yyerror("fairness_statement: t_STRONG t_FAIRNESS /* boolean */ hdl_or_psl_expression t_Comma  /* boolean */ hdl_or_psl_expression t_Semicolon is not supported");
};

/* -----------------------------------------------------------------------
 *  PSL PROPERTIES
 * -----------------------------------------------------------------------
 */

property:
replicator property
{
    yydebug("property: replicator property");
    yyerror("property: replicator property is not supported");
}
| fl_property
{
    yydebug("property: fl_property");
    RULE_BREAK_MACRO $$ = $1;
}
//| obe_property
//{
//    yydebug("property: obe_property");
//    yyerror("property: obe_property is not supported");
//}
;

replicator:
t_FORALL parameter_definition t_Colon
{
    yydebug("replicator: t_FORALL parameter_definition t_Colon");
    yyerror("replicator: t_FORALL parameter_definition t_Colon is not supported");
};

//index_range:
//t_LeftParen /*range */ range_psl t_RightParen %prec HIGH
//// LEFT_SYM /*range */ range_psl RIGHT_SYM %prec HIGH
//{
//    yydebug("index_range: LEFT_SYM range RIGHT_SYM");
//    yyerror("index_range: LEFT_SYM range RIGHT_SYM is not supported");
//}
//| t_LeftParen HDL_RANGE t_RightParen %prec LOW
//{
//    yydebug("index_range: t_LeftParen HDL_RANGE t_RightParen");
//    yyerror("index_range: t_LeftParen HDL_RANGE t_RightParen is not supported");
//};

index_range:
t_LeftParen hdl_psl_range t_RightParen
{
    yydebug("index_range: t_LeftParen hdl_psl_range t_RightParen");
    yyerror("index_range: t_LeftParen hdl_psl_range t_RightParen is not supported");
};

hdl_psl_range:
// ---------- PSL ----------
low_bound RANGE_SYM high_bound
{
    yydebug("hdl_psl_range: low_bound RANGE_SYM high_bound");
    RULE_BREAK_MACRO $$ = parserInstance->parse_RangePsl($1, $3);
}
// ---------- HDL ----------
| /*range_*/ attribute_name %prec LOW
{
    yydebug("hdl_psl_range: attribute_name.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_Range( $1 );
}
| simple_expression direction simple_expression %prec HIGH
{
    yydebug("hdl_psl_range: simple_expression direction simple_expression.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_Range( $1, $2, $3 );
};


value_set:
t_LeftBrace value_range_list t_RightBrace
{
    yydebug("value_set: t_LeftBrace value_range_list t_RightBrace");
    RULE_BREAK_MACRO $$ = $2;
}
| t_BOOLEAN
{
    yydebug("value_set: t_BOOLEAN");
    RULE_BREAK_MACRO
    $$ = new BList<Value>();
};

value_range_list:
value_range_list t_Comma value_range
{
    yydebug("value_range_list: value_range_list t_Comma value_range");
    RULE_BREAK_MACRO
    $$ = $1;
    $$->push_back( $3 );
}
| value_range
{
    yydebug("value_range_list: value_range");
    RULE_BREAK_MACRO
    $$ = new BList<Value>();
    $$->push_back( $1 );
};

value_range:
value
{
    yydebug("value_range value");
    RULE_BREAK_MACRO $$ = $1;
}
| /* range */ range_psl
{
    yydebug("value_range: range");
    RULE_BREAK_MACRO $$ = $1;
};

value:
///* boolean */ hdl_or_psl_expression
//| /* number */ hdl_or_psl_expression
hdl_or_psl_expression
{
    yydebug("value: hdl_or_psl_expression");
    RULE_BREAK_MACRO $$ = $1;
};

proc_block:
t_DOUBLE_OPEN_BRACKETS proc_block_item_list t_DOUBLE_CLOSE_BRACKETS
{
    yydebug("proc_block:t_DOUBLE_OPEN_BRACKETS proc_block_item_listt_DOUBLE_CLOSE_BRACKETS");
    yyerror("proc_block:t_DOUBLE_OPEN_BRACKETS proc_block_item_listt_DOUBLE_CLOSE_BRACKETS is not supported");
};

proc_block_item_list:
proc_block_item
{
    yydebug("proc_block_item_list: proc_block_item");
    yyerror("proc_block_item_list: proc_block_item is not supported");
}
| proc_block_item_list proc_block_item
{
    yydebug("proc_block_item_list: proc_block_item_list proc_block_item");
    yyerror("proc_block_item_list: proc_block_item_list proc_block_item is not supported");
};


proc_block_item:
HDL_DECL
{
    yydebug("proc_block_item: HDL_DECL");
    yyerror("proc_block_item: HDL_DECL is not supported");
}
| HDL_SEQ_STMT
{
    yydebug("proc_block_item: HDL_SEQ_STMT");
    yyerror("proc_block_item: HDL_SEQ_STMT is not supported");
};


fl_property:
/* boolean */ hdl_or_psl_expression %prec LOW
{
    yydebug("fl_property: /* boolean */ hdl_or_psl_expression");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FLProperty( $1 );
}
| t_LeftParen hdl_decl_list_brackets fl_property t_RightParen
{
    yydebug("fl_property: t_LeftParen hdl_decl_list_brackets fl_property t_RightParen");
    yyerror("fl_property: t_LeftParen hdl_decl_list_brackets fl_property t_RightParen is not supported");
}
//| name t_LeftParen actual_parameter_list t_RightParen
| t_LeftParen fl_property t_RightParen
{
    yydebug("fl_property: t_LeftParen fl_property t_RightParen");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FLProperty( $2 );
}
| fl_property t_AT clock_expression
{
    yydebug("fl_property: fl_property t_AT clock_expression");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FLProperty( $1, $3 );
}
| fl_property t_ABORT /* boolean */ hdl_or_psl_expression
{
    yydebug("fl_property: fl_property t_ABORT /* boolean */ hdl_or_psl_expression");
    yyerror("fl_property: fl_property t_ABORT /* boolean */ hdl_or_psl_expression is not supported");
}
| fl_property t_ASYNC_ABORT /* boolean */ hdl_or_psl_expression
{
    yydebug("fl_property: fl_property t_ASYNC_ABORT /* boolean */ hdl_or_psl_expression");
    yyerror("fl_property: fl_property t_ASYNC_ABORT /* boolean */ hdl_or_psl_expression is not supported");
}
| fl_property t_SYNC_ABORT /* boolean */ hdl_or_psl_expression
{
    yydebug("fl_property: fl_property t_SYNC_ABORT /* boolean */ hdl_or_psl_expression");
    yyerror("fl_property: fl_property t_SYNC_ABORT /* boolean */ hdl_or_psl_expression is not supported");
}
| parameterized_property
{
    yydebug("fl_property: parameterized_property");
    yyerror("fl_property: parameterized_property is not supported");
}
| fl_property /* AND_OP */ t_AND fl_property
{
    yydebug("fl_property: fl_property AND_OP fl_property");
    RULE_BREAK_MACRO $$ = parserInstance->parse_Expression( $1, $3, op_and );
}
| fl_property /* OR_OP */ t_OR fl_property
{
    yydebug("fl_property: fl_property OR_OP fl_property");
    RULE_BREAK_MACRO $$ = parserInstance->parse_Expression( $1, $3, op_or );
}
| /* NOT_OP */ t_NOT fl_property %prec NOT_PREC
{
    yydebug("fl_property: /* NOT_OP */ t_NOT fl_property");
    RULE_BREAK_MACRO
    $$ = hif_factory->expression( op_not, $2 );
    parserInstance->setCodeInfo($$);
}
| fl_property t_BOOLEAN_IMPLICATION fl_property
{
    yydebug("fl_property: fl_property t_BOOLEAN_IMPLICATION fl_property");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FLProperty("psl_imply", $1, $3);
}
| fl_property t_DOUBLE_BOOLEAN_IMPLICATION fl_property
{
    yydebug("fl_property: fl_property t_DOUBLE_BOOLEAN_IMPLICATION fl_property");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FLProperty("psl_double_imply", $1, $3);
}
| t_X fl_property
{
    yydebug("fl_property: t_X fl_property");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FLProperty("psl_X", $2);
}
| t_X_EXCL fl_property
{
    yydebug("fl_property: t_X_EXCL fl_property");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FLProperty("psl_X!", $2);
}
| t_F fl_property
{
    yydebug("fl_property: t_F fl_property");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FLProperty("psl_F", $2);
}
| t_LeftBracket fl_property t_U fl_property t_RightBracket
{
    yydebug("fl_property: t_LeftBracket fl_property t_U fl_property t_RightBracket");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FLProperty("psl_U", $2, $4 );
}
| t_LeftBracket fl_property t_W fl_property t_RightBracket
{
    yydebug("fl_property: t_LeftBracket fl_property t_W fl_property t_RightBracket");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FLProperty("psl_W", $2, $4 );
}
| t_ALWAYS fl_property
{
    yydebug("fl_property: t_ALWAYS fl_property");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FLProperty("psl_always", $2);
}
| t_NEVER fl_property
{
    yydebug("fl_property: t_NEVER fl_property");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FLProperty("psl_never", $2);
}
| t_G fl_property
{
    yydebug("fl_property: t_G fl_property");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FLProperty("psl_G", $2);
}
| t_NEXT fl_property
{
    yydebug("fl_property: t_NEXT fl_property");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FLProperty("psl_next", $2 );
}
| t_NEXT_EXCL fl_property
{
    yydebug("fl_property: t_NEXT_EXCL fl_property");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FLProperty("psl_next!", $2 );
}
| t_EVENTUALLY_EXCL fl_property
{
    yydebug("fl_property: t_EVENTUALLY_EXCL fl_property");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FLProperty("psl_eventually!", $2);
}
| fl_property t_UNTIL_EXCL fl_property
{
    yydebug("fl_property: fl_property t_UNTIL_EXCL fl_property");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FLProperty("psl_until!", $1, $3 );
}
| fl_property t_UNTIL fl_property
{
    yydebug("fl_property: fl_property t_UNTIL fl_property");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FLProperty("psl_until", $1, $3 );
}
| fl_property t_UNTIL_EXCL_UNDERSCORE fl_property
{
    yydebug("fl_property: fl_property t_UNTIL_EXCL_UNDERSCORE fl_property");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FLProperty("psl_until!_", $1, $3 );
}
| fl_property t_UNTIL_UNDERSCORE fl_property
{
    yydebug("fl_property: fl_property t_UNTIL_UNDERSCORE fl_property");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FLProperty("psl_until_", $1, $3 );
}
| fl_property t_BEFORE_EXCL fl_property
{
    yydebug("fl_property: fl_property t_BEFORE_EXCL fl_property");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FLProperty("psl_before!", $1, $3 );
}
| fl_property t_BEFORE fl_property
{
    yydebug("fl_property: fl_property t_BEFORE fl_property");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FLProperty("psl_before", $1, $3 );
}
| fl_property t_BEFORE_EXCL_UNDERSCORE fl_property
{
    yydebug("fl_property: fl_property t_BEFORE_EXCL_UNDERSCORE fl_property");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FLProperty("psl_before!_", $1, $3 );
}
| fl_property t_BEFORE_UNDERSCORE fl_property
{
    yydebug("fl_property: fl_property t_BEFORE_UNDERSCORE fl_property");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FLProperty("psl_before_", $1, $3 );
}
| t_X t_LeftBracket /* number */ hdl_or_psl_expression t_RightBracket t_LeftParen fl_property t_RightParen
{
    yydebug("fl_property: t_X t_LeftBracket /* number */ hdl_or_psl_expression t_RightBracket t_LeftParen fl_property t_RightParen");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FLPropertyCycles("psl_X", $6, $3 );
}
| t_X_EXCL t_LeftBracket /* number */ hdl_or_psl_expression t_RightBracket t_LeftParen fl_property t_RightParen
{
    yydebug("fl_property: t_X_EXCL t_LeftBracket /* number */ hdl_or_psl_expression t_RightBracket t_LeftParen fl_property t_RightParen");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FLPropertyCycles("psl_X!", $6, $3 );
}
| t_NEXT t_LeftBracket /* number */ hdl_or_psl_expression t_RightBracket t_LeftParen fl_property t_RightParen
{
    yydebug("fl_property: t_NEXT t_LeftBracket /* number */ hdl_or_psl_expression t_RightBracket t_LeftParen fl_property t_RightParen");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FLPropertyCycles("psl_next", $6, $3 );
}
| t_NEXT_EXCL t_LeftBracket /* number */ hdl_or_psl_expression t_RightBracket t_LeftParen fl_property t_RightParen
{
    yydebug("fl_property: t_NEXT_EXCL t_LeftBracket /* number */ hdl_or_psl_expression t_RightBracket t_LeftParen fl_property t_RightParen");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FLPropertyCycles("psl_next!", $6, $3 );
}
| t_NEXT_A t_LeftBracket /* range */ range_psl t_RightBracket t_LeftParen fl_property t_RightParen
{
    yydebug("fl_property: t_NEXT_A t_LeftBracket /* range */ range_psl t_RightBracket t_LeftParen fl_property t_RightParen");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FLPropertyRange("psl_next_a", $6, $3 );
}
| t_NEXT_A_EXCL t_LeftBracket /* range */ range_psl t_RightBracket t_LeftParen fl_property t_RightParen
{
    yydebug("fl_property: t_NEXT_A_EXCL t_LeftBracket /* range */ range_psl t_RightBracket t_LeftParen fl_property t_RightParen");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FLPropertyRange("psl_next_a!", $6, $3 );
}
| t_NEXT_E t_LeftBracket /* range */ range_psl t_RightBracket t_LeftParen fl_property t_RightParen
{
    yydebug("fl_property: t_NEXT_E t_LeftBracket /* range */ range_psl t_RightBracket t_LeftParen fl_property t_RightParen");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FLPropertyRange("psl_next_e", $6, $3 );
}
| t_NEXT_E_EXCL t_LeftBracket /* range */ range_psl t_RightBracket t_LeftParen fl_property t_RightParen
{
    yydebug("fl_property: t_NEXT_E_EXCL t_LeftBracket /* range */ range_psl t_RightBracket t_LeftParen fl_property t_RightParen");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FLPropertyRange("psl_next_e!", $6, $3 );
}
| t_NEXT_EVENT_EXCL t_LeftParen  /* boolean */ hdl_or_psl_expression t_RightParen t_LeftParen fl_property t_RightParen
{
    yydebug("fl_property: t_NEXT_EVENT_EXCL t_LeftParen  /* boolean */ hdl_or_psl_expression t_RightParen t_LeftParen fl_property t_RightParen");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FLPropertyOccurrence("psl_next!", $6, $3 );
}
| t_NEXT_EVENT t_LeftParen  /* boolean */ hdl_or_psl_expression t_RightParen t_LeftParen fl_property t_RightParen
{
    yydebug("fl_property: t_NEXT_EVENT t_LeftParen  /* boolean */ hdl_or_psl_expression t_RightParen t_LeftParen fl_property t_RightParen");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FLPropertyOccurrence("psl_next", $6, $3 );
}
| t_NEXT_EVENT_EXCL t_LeftParen  /* boolean */ hdl_or_psl_expression t_RightParen t_LeftBracket /* number */ hdl_or_psl_expression t_RightBracket t_LeftParen fl_property t_RightParen
{
    yydebug("fl_property: t_NEXT_EVENT_EXCL t_LeftParen  /* boolean */ hdl_or_psl_expression t_RightParen t_LeftBracket /* number */ hdl_or_psl_expression t_RightBracket t_LeftParen fl_property t_RightParen");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FLPropertyOccurrenceCycles("psl_next!", $9, $3, $6 );
}
| t_NEXT_EVENT t_LeftParen  /* boolean */ hdl_or_psl_expression t_RightParen t_LeftBracket /* number */ hdl_or_psl_expression t_RightBracket t_LeftParen fl_property t_RightParen
{
    yydebug("fl_property: t_NEXT_EVENT t_LeftParen  /* boolean */ hdl_or_psl_expression t_RightParen t_LeftBracket /* number */ hdl_or_psl_expression t_RightBracket t_LeftParen fl_property t_RightParen");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FLPropertyOccurrenceCycles("psl_next_event", $9, $3, $6 );
}
| t_NEXT_EVENT_A_EXCL t_LeftParen  /* boolean */ hdl_or_psl_expression t_RightParen t_LeftBracket /* range */ range_psl t_RightBracket t_LeftParen fl_property t_RightParen
{
    yydebug("fl_property: t_NEXT_EVENT_A_EXCL t_LeftParen  /* boolean */ hdl_or_psl_expression t_RightParen t_LeftBracket /* range */ range_psl t_RightBracket t_LeftParen fl_property t_RightParen");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FLPropertyOccurrenceRange("psl_next_event_a!", $9, $3, $6 );
}
| t_NEXT_EVENT_A t_LeftParen  /* boolean */ hdl_or_psl_expression t_RightParen t_LeftBracket /* range */ range_psl t_RightBracket t_LeftParen fl_property t_RightParen
{
    yydebug("fl_property: t_NEXT_EVENT_A t_LeftParen  /* boolean */ hdl_or_psl_expression t_RightParen t_LeftBracket /* range */ range_psl t_RightBracket t_LeftParen fl_property t_RightParen");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FLPropertyOccurrenceRange("psl_next_event_a", $9, $3, $6 );
}
| t_NEXT_EVENT_E_EXCL t_LeftParen  /* boolean */ hdl_or_psl_expression t_RightParen t_LeftBracket /* range */ range_psl t_RightBracket t_LeftParen fl_property t_RightParen
{
    yydebug("fl_property: t_NEXT_EVENT_E_EXCL t_LeftParen  /* boolean */ hdl_or_psl_expression t_RightParen t_LeftBracket /* range */ range_psl t_RightBracket t_LeftParen fl_property t_RightParen");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FLPropertyOccurrenceRange("psl_next_event_e!", $9, $3, $6 );
}
| t_NEXT_EVENT_E t_LeftParen  /* boolean */ hdl_or_psl_expression t_RightParen t_LeftBracket /* range */ range_psl t_RightBracket t_LeftParen fl_property t_RightParen
{
    yydebug("fl_property: t_NEXT_EVENT_E t_LeftParen  /* boolean */ hdl_or_psl_expression t_RightParen t_LeftBracket /* range */ range_psl t_RightBracket t_LeftParen fl_property t_RightParen");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FLPropertyOccurrenceRange("psl_next_event_e", $9, $3, $6 );
}
| t_LeftBrace sere t_RightBrace t_LeftParen fl_property t_RightParen %prec HIGH
{
    yydebug("fl_property: sere_list t_LeftParen fl_property t_RightParen");
    yyerror("fl_property: sere_list t_LeftParen fl_property t_RightParen is not supported");
}
| sequence
{
    yydebug("fl_property: sequence");
    RULE_BREAK_MACRO
    $$ = $1;
}
| sequence t_Excl
{
    yydebug("fl_property: sequence t_Excl");
    yyerror("fl_property: sequence t_Excl is not supported");
}
| sequence t_SEQUENCE_IMPLICATION fl_property
{
    yydebug("fl_property: sequence t_SEQUENCE_IMPLICATION fl_property");
    yyerror("fl_property: sequence t_SEQUENCE_IMPLICATION fl_property is not supported");
}
| sequence t_DOUBLE_SEQUENCE_IMPLICATION fl_property
{
    yydebug("fl_property: sequence t_DOUBLE_SEQUENCE_IMPLICATION fl_property");
    yyerror("fl_property: sequence t_DOUBLE_SEQUENCE_IMPLICATION fl_property is not supported");
};


hdl_decl_list:
HDL_DECL
{
    yydebug("hdl_decl_list: HDL_DECL");
    yyerror("hdl_decl_list: HDL_DECL is not supported");
}
| hdl_decl_list t_Comma HDL_DECL
{
    yydebug("hdl_decl_list: hdl_decl_list t_Comma HDL_DECL");
    yyerror("hdl_decl_list: hdl_decl_list t_Comma HDL_DECL is not supported");
};

/* -----------------------------------------------------------------------
 *  SEQUENTIAL EXTENDED REGEX (SEREs)
 * -----------------------------------------------------------------------
 */

sere:
/* boolean */ hdl_or_psl_expression
{
    yydebug("sere:  /* boolean */ hdl_or_psl_expression");
    yyerror("sere:  /* boolean */ hdl_or_psl_expression is not supported");
}
| compound_sere
{
    yydebug("sere: compound_sere");
    yyerror("sere: compound_sere is not supported");
}
// NOTE: compound_sere -> sequence -> repeated_sere -> hdl_or_psl_expression proc_block
//| /* boolean */ hdl_or_psl_expression proc_block %prec HIGH
// NOTE: sere -> compound_sere -> sequence
//| sequence
| sere t_Semicolon sere
{
    yydebug("sere: sere t_Semicolon sere");
    yyerror("sere: sere t_Semicolon sere is not supported");
}
| sere t_Colon sere
{
    yydebug("sere: sere t_Colon sere");
    yyerror("sere: sere t_Colon sere is not supported");
};

compound_sere:
// NOTE: sequence -> repeated_sere/braced_sere/clocked_sere
//repeated_sere
//{
//    yydebug("compound_sere: repeated_sere");
//    yyerror("compound_sere: repeated_sere is not supported");
//}
//| braced_sere
//{
//    yydebug("compound_sere: braced_sere");
//    yyerror("compound_sere: braced_sere is not supported");
//}
//| clocked_sere
//{
//    yydebug("compound_sere: clocked_sere");
//    yyerror("compound_sere: clocked_sere is not supported");
//}
sequence
{
    yydebug("compound_sere: sequence");
    yyerror("compound_sere: sequence is not supported");
}
| compound_sere t_Bar compound_sere
{
    yydebug("compound_sere: compound_sere t_Bar compound_sere");
    yyerror("compound_sere: compound_sere t_Bar compound_sere is not supported");
}
| compound_sere t_Ampersand compound_sere
{
    yydebug("compound_sere: compound_sere t_Ampersand compound_sere");
    yyerror("compound_sere: compound_sere t_Ampersand compound_sere is not supported");
}
| compound_sere t_DOUBLE_AND compound_sere
{
    yydebug("compound_sere: compound_sere t_DOUBLE_AND compound_sere");
    yyerror("compound_sere: compound_sere t_DOUBLE_AND compound_sere is not supported");
}
| compound_sere t_WITHIN compound_sere
{
    yydebug("compound_sere: compound_sere t_WITHIN compound_sere");
    yyerror("compound_sere: compound_sere t_WITHIN compound_sere is not supported");
}
| parameterized_sere
{
    yydebug("compound_sere: parameterized_sere");
    yyerror("compound_sere: parameterized_sere is not supported");
};

/* -----------------------------------------------------------------------
 *  PARAMETERIZED PROPERTIES AND SEREs
 * -----------------------------------------------------------------------
 */

parameterized_property:
t_FOR parameters_definition t_Colon and_or_property_op t_LeftParen fl_property t_RightParen
{
    yydebug("parameterized_property: t_FOR parameters_definition t_Colon and_or_property_op t_LeftParen fl_property t_RightParen");
    yyerror("parameterized_property: t_FOR parameters_definition t_Colon and_or_property_op t_LeftParen fl_property t_RightParen is not supported");
};

parameterized_sere:
t_FOR parameters_definition t_Colon and_or_sere_op t_LeftBrace sere t_RightBrace
{
    yydebug("parameterized_sere: t_FOR parameters_definition t_Colon and_or_sere_op");
    yyerror("parameterized_sere: t_FOR parameters_definition t_Colon and_or_sere_op is not supported");
};

parameters_definition:
parameters_definition t_Comma parameter_definition
{
    yydebug("parameters_definition: parameters_definition parameter_definition");
    yyerror("parameters_definition: parameters_definition parameter_definition is not supported");
}
| parameter_definition
{
    yydebug("parameters_definition: parameter_definition");
    yyerror("parameters_definition: parameter_definition is not supported");
};

parameter_definition:
/* psl_identifier */ identifier index_range_opt t_IN value_set
{
    yydebug("parameter_definition: /* psl_identifier */ identifier index_range_opt t_IN value_set");
    yyerror("parameter_definition: /* psl_identifier */ identifier index_range_opt t_IN value_set is not supported");
};

index_range_opt:
/* empty */
{
    yydebug("index_range_opt: empty");
    yyerror("index_range_opt: empty is not supported");
}
| index_range
{
    yydebug("index_range_opt: index_range");
    yyerror("index_range_opt: index_range is not supported");
};

and_or_property_op:
AND_OP
{
    yydebug("and_or_property_op: AND_OP");
    RULE_BREAK_MACRO $$ = op_and;
}
| OR_OP
{
    yydebug("and_or_property_op: OR_OP");
    RULE_BREAK_MACRO $$ = op_or;
};

and_or_sere_op:
t_DOUBLE_AND
{
    yydebug("and_or_sere_op: t_DOUBLE_AND");
    yyerror("and_or_sere_op: t_DOUBLE_AND is not supported");
}
| t_Ampersand
{
    yydebug("and_or_sere_op: t_Ampersand");
    yyerror("and_or_sere_op: t_Ampersand is not supported");
}
| t_Bar
{
    yydebug("and_or_sere_op: t_Bar");
    yyerror("and_or_sere_op:: t_Bar is not supported");
};

/* -----------------------------------------------------------------------
 *  SEQUENCES
 * -----------------------------------------------------------------------
 */

sere_consecutive_op:
t_LeftBracket t_Star count_opt t_RightBracket
{
    yydebug("sere_consecutive_op: t_SERE_CONSECUTIVE_STAR count_opt t_RightBracket");
    yyerror("sere_consecutive_op: t_SERE_CONSECUTIVE_STAR count_opt t_RightBracket is not supported");
};

sere_not_consecutive_op:
t_LeftBracket t_EQSym count t_RightBracket
{
    yydebug("sere_not_consecutive_op: t_LeftBracket t_EQSym count t_RightBracket");
    yyerror("sere_not_consecutive_op: t_LeftBracket t_EQSym count t_RightBracket is not supported");
};

sere_goto_op:
t_LeftBracket t_BOOLEAN_IMPLICATION count_opt t_RightBracket
{
    yydebug("sere_goto_op: t_LeftBracket t_BOOLEAN_IMPLICATION count_opt t_RightBracket");
    yyerror("sere_goto_op: t_LeftBracket t_BOOLEAN_IMPLICATION count_opt t_RightBracket is not supported");
};

sere_consecutive_plus_op:
t_LeftBracket t_Plus t_RightBracket
{
    yydebug("sere_consecutive_plus_op: t_LeftBracket t_Plus t_RightBracket");
    yyerror("sere_consecutive_plus_op: t_LeftBracket t_Plus t_RightBracket is not supported");
};

sequence:
sequence_instance
{
    yydebug("sequence: sequence_instance");
    RULE_BREAK_MACRO
    $$ = $1;
}
| repeated_sere
{
    yydebug("sequence: repeated_sere");
    yyerror("sequence: repeated_sere is not supported");
}
| braced_sere
{
    yydebug("sequence: braced_sere");
    yyerror("sequence: braced_sere is not supported");
}
| clocked_sere // %prec HIGH
{
    yydebug("sequence: clocked_sere");
    yyerror("sequence: clocked_sere is not supported");
}
| sequence proc_block //%prec MEDIUM1
{
    yydebug("sequence: sequence proc_block");
    yyerror("sequence: sequence proc_block is not supported");
};

repeated_sere:
/* boolean */ hdl_or_psl_expression sere_consecutive_op %prec LOW
{
    yydebug("repeated_sere:  /* boolean */ hdl_or_psl_expression sere_consecutive_op");
    yyerror("repeated_sere:  /* boolean */ hdl_or_psl_expression sere_consecutive_op is not supported");
}
| sequence sere_consecutive_op
{
    yydebug("repeated_sere: sequence sere_consecutive_op");
    yyerror("repeated_sere: sequence sere_consecutive_op is not supported");
}
| sere_consecutive_op
{
    yydebug("repeated_sere: sere_consecutive_op");
    yyerror("repeated_sere: sere_consecutive_op is not supported");
}
|  /* boolean */ hdl_or_psl_expression sere_consecutive_plus_op
{
    yydebug("repeated_sere:  /* boolean */ hdl_or_psl_expression sere_consecutive_plus_op ");
    yyerror("repeated_sere:  /* boolean */ hdl_or_psl_expression sere_consecutive_plus_op is not supported");
}
| sequence sere_consecutive_plus_op
{
    yydebug("repeated_sere: sequence sere_consecutive_plus_op");
    yyerror("repeated_sere: sequence sere_consecutive_plus_op is not supported");
}
| sere_consecutive_plus_op
{
    yydebug("repeated_sere: sere_consecutive_plus_op");
    yyerror("repeated_sere: sere_consecutive_plus_op is not supported");
}
| /* boolean */ hdl_or_psl_expression sere_not_consecutive_op
{
    yydebug("repeated_sere:   /* boolean */ hdl_or_psl_expression sere_not_consecutive_op");
    yyerror("repeated_sere:   /* boolean */ hdl_or_psl_expression sere_not_consecutive_op is not supported");
}
| /* boolean */ hdl_or_psl_expression sere_goto_op
{
    yydebug("repeated_sere:  /* boolean */ hdl_or_psl_expression sere_goto_op");
    yyerror("repeated_sere:  /* boolean */ hdl_or_psl_expression sere_goto_op is not supported");
}
| /* boolean */ hdl_or_psl_expression proc_block
{
    yydebug("repeated_sere:  /* boolean */ hdl_or_psl_expression proc_block");
    yyerror("repeated_sere:  /* boolean */ hdl_or_psl_expression proc_block is not supported");
}
//| sequence proc_block
//{
//    yydebug("repeated_sere: sequence proc_block");
//    yyerror("repeated_sere: sequence proc_block is not supported");
//}
;

count_opt:
/*empty*/
{
    yydebug("count_opt: empty");
}
| count
{
    yydebug("count_opt: count");
    yyerror("count_opt: count is not supported");
};

braced_sere:
t_LeftBrace sere t_RightBrace
{
    yydebug("braced_sere: t_LeftBrace sere t_RightBrace");
    yyerror("braced_sere: t_LeftBrace sere t_RightBrace is not supported");
}
| t_LeftBrace hdl_decl_list_brackets sere t_RightBrace
{
    yydebug("braced_sere: t_LeftBrace hdl_decl_list_brackets sere t_RightBrace");
    yyerror("braced_sere: t_LeftBrace hdl_decl_list_brackets sere t_RightBrace is not supported");
}
| t_LeftBrace free_hdl_list sere t_RightBrace
{
    yydebug("braced_sere: t_LeftBrace free_hdl_list sere t_RightBrace");
    yyerror("braced_sere: t_LeftBrace free_hdl_list sere t_RightBrace is not supported");
};

hdl_decl_list_brackets:
t_DOUBLE_OPEN_BRACKETS hdl_decl_list t_DOUBLE_CLOSE_BRACKETS
{
    yydebug("hdl_decl_list_brackets: t_DOUBLE_OPEN_BRACKETS hdl_decl_list t_DOUBLE_CLOSE_BRACKETS");
    yyerror("hdl_decl_list_brackets: t_DOUBLE_OPEN_BRACKETS hdl_decl_list t_DOUBLE_CLOSE_BRACKETS is not supported");
};

free_hdl_list:
t_FREE t_LeftParen identifier_list t_RightParen
{
    yydebug("free_hdl_list: t_FREE t_LeftParen identifier_list t_RightParen");
    yyerror("free_hdl_list: t_FREE t_LeftParen identifier_list t_RightParen is not supported");
};


sequence_instance:
///* sequence_name */ /* hdl_or_psl_identifier */ identifier %prec LOW
//{
//    yydebug("sequence_instance: /* sequence_name */ /* hdl_or_psl_identifier */ identifier actual_parameter_list_paren_opt");
//    yyerror("sequence_instance: /* sequence_name */ /* hdl_or_psl_identifier */ identifier actual_parameter_list_paren_opt is not supported");
//}
//|
/* sequence_name */ /* hdl_or_psl_identifier */ identifier t_LeftParen actual_parameter_list t_RightParen
{
    yydebug("sequence_instance: /* sequence_name */ /* hdl_or_psl_identifier */ identifier actual_parameter_list_paren_opt");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_SequenceInstance($1, $3);
};

actual_parameter_list_paren_opt:
/*empty*/
{
    yydebug("actual_parameter_list_paren_opt: empty");
}
| t_LeftParen actual_parameter_list t_RightParen
{
    yydebug("actual_parameter_list_paren_opt: t_LeftParen actual_parameter_list t_RightParen");
    yyerror("actual_parameter_list_paren_opt: t_LeftParen actual_parameter_list t_RightParen is not supported");
};

clocked_sere:
braced_sere t_AT clock_expression
{
    yydebug("clocked_sere: braced_sere sere t_AT clock_expression");
    yyerror("clocked_sere: braced_sere sere t_AT clock_expression is not supported");
};

count:
/* number */ hdl_or_psl_expression
{
    yydebug("count: /* number */ hdl_or_psl_expression");
    yyerror("count: /* number */ hdl_or_psl_expression is not supported");
}
| /* range */ range_psl
{
    yydebug("count: /* range */ range_psl");
    yyerror("count: /* range */ range_psl is not supported");
};

/* range */
range_psl:
low_bound RANGE_SYM high_bound
{
    yydebug("range: low_bound RANGE_SYM high_bound");
    RULE_BREAK_MACRO $$ = parserInstance->parse_RangePsl( $1, $3 );
};

low_bound:
/* number */ hdl_or_psl_expression
{
    yydebug("low_bound: /* number */ hdl_or_psl_expression");
    RULE_BREAK_MACRO $$ = $1;
}
//| MIN_VAL   // in VHDL Flavor should be zero ( '0' )
;

high_bound:
/* number */ hdl_or_psl_expression
{
    yydebug("high_bound: /* number */ hdl_or_psl_expression");
    RULE_BREAK_MACRO $$ = $1;
}
| /*MAX_VAL*/ t_INF
{
    yydebug("high_bound: t_inf");
    yydebug("high_bound: t_inf is not supported");
};

/* -----------------------------------------------------------------------
 *  FORMS OF EXPRESSION
 * -----------------------------------------------------------------------
 */

//any_type: hdl_or_psl_expression;

//bit:
//hdl_or_psl_expression
//{
//    yydebug("bit: hdl_or_psl_expression");
//    yyerror("bit: hdl_or_psl_expression is not supported");
//};

//boolean:
//hdl_or_psl_expression
//{
//    yydebug("boolean: hdl_or_psl_expression");
//    yyerror("boolean: hdl_or_psl_expression is not supported");
//};
//
//bitvector:
//hdl_or_psl_expression
//{
//    yydebug("bitvector: hdl_or_psl_expression");
//    yyerror("bitvector: hdl_or_psl_expression is not supported");
//};
//
//number:
//hdl_or_psl_expression
//{
//    yydebug("number: hdl_or_psl_expression");
//    yyerror("number: hdl_or_psl_expression is not supported");
//};

string:
hdl_or_psl_expression
{
    yydebug("string: hdl_or_psl_expression");
    RULE_BREAK_MACRO $$ = $1;
};

hdl_or_psl_expression:
/*hdl_expression*/ expression %prec LOW
{
    yydebug("hdl_or_psl_expression: expression");
    RULE_BREAK_MACRO $$ = $1;
}
| psl_expression
{
    yydebug("hdl_or_psl_expression: psl_expression");
    yyerror("hdl_or_psl_expression: psl_expression is not supported");
}
| built_in_function_call
{
    yydebug("hdl_or_psl_expression: built_in_function_call");
    RULE_BREAK_MACRO $$ = $1;
}
| union_expression
{
    yydebug("hdl_or_psl_expression: union_expression");
    yyerror("hdl_or_psl_expression: union_expression is not supported");
};

element_association:
expression
{
    yydebug("element_association: expression.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ElementAssociation( $1 );
}
| choices t_Arrow expression
{
    yydebug("element_association: choices t_Arrow expression.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ElementAssociation( $1, $3 );
};


psl_expression:
/* boolean */ hdl_or_psl_expression t_BOOLEAN_IMPLICATION  /* boolean */ hdl_or_psl_expression
{
    yydebug("psl_expression:  /* boolean */ hdl_or_psl_expression t_BOOLEAN_IMPLICATION  /* boolean */ hdl_or_psl_expression");
    yyerror("psl_expression:  /* boolean */ hdl_or_psl_expression t_BOOLEAN_IMPLICATION  /* boolean */ hdl_or_psl_expression is not supported");
}
| /* boolean */ hdl_or_psl_expression t_DOUBLE_BOOLEAN_IMPLICATION  /* boolean */ hdl_or_psl_expression
{
    yydebug("psl_expression:  /* boolean */ hdl_or_psl_expression t_DOUBLE_BOOLEAN_IMPLICATION  /* boolean */ hdl_or_psl_expression");
    yyerror("psl_expression:  /* boolean */ hdl_or_psl_expression t_DOUBLE_BOOLEAN_IMPLICATION  /* boolean */ hdl_or_psl_expression is not supported");
};

built_in_function_call:
t_PREV t_LeftParen /* any_type */ hdl_or_psl_expression t_RightParen
{
    yydebug("built_in_function_call: t_PREV t_LeftParen /* any_type */ hdl_or_psl_expression t_RightParen");
    yyerror("built_in_function_call: t_PREV t_LeftParen /* any_type */ hdl_or_psl_expression t_RightParen is not supported");
}
| t_PREV t_LeftParen /* any_type */ hdl_or_psl_expression t_Comma /* number */ hdl_or_psl_expression t_RightParen
{
    yydebug("built_in_function_call: t_PREV t_LeftParen /* any_type */ hdl_or_psl_expression t_Comma /* number */ hdl_or_psl_expression t_RightParen");
    yyerror("built_in_function_call: t_PREV t_LeftParen /* any_type */ hdl_or_psl_expression t_Comma /* number */ hdl_or_psl_expression t_RightParen is not supported");
}
| t_PREV t_LeftParen /* any_type */ hdl_or_psl_expression t_Comma /* number */ hdl_or_psl_expression t_Comma clock_expression t_RightParen
{
    yydebug("built_in_function_call: t_PREV t_LeftParen /* any_type */ hdl_or_psl_expression t_Comma /* number */ hdl_or_psl_expression t_Comma clock_expression t_RightParen");
    yyerror("built_in_function_call: t_PREV t_LeftParen /* any_type */ hdl_or_psl_expression t_Comma /* number */ hdl_or_psl_expression t_Comma clock_expression t_RightParen is not supported");
}
| t_NEXT t_LeftParen /* any_type */ hdl_or_psl_expression t_RightParen
{
    yydebug("built_in_function_call: t_NEXT t_LeftParen /* any_type */ hdl_or_psl_expression t_RightParen ");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FLProperty("psl_next", $3);
}
| t_STABLE t_LeftParen /* any_type */ hdl_or_psl_expression t_RightParen
{
    yydebug("built_in_function_call: t_STABLE t_LeftParen /* any_type */ hdl_or_psl_expression t_RightParen ");
    yyerror("built_in_function_call: t_STABLE t_LeftParen /* any_type */ hdl_or_psl_expression t_RightParen ");
}
| t_STABLE t_LeftParen /* any_type */ hdl_or_psl_expression t_Comma clock_expression t_RightParen
{
    yydebug("built_in_function_call: t_STABLE t_LeftParen /* any_type */ hdl_or_psl_expression t_Comma clock_expression t_RightParen ");
    yyerror("built_in_function_call: t_STABLE t_LeftParen /* any_type */ hdl_or_psl_expression t_Comma clock_expression t_RightParen ");
}
| t_ROSE t_LeftParen /* bit */ hdl_or_psl_expression t_RightParen
{
    yydebug("built_in_function_call: t_ROSE t_LeftParen /* bit */ hdl_or_psl_expression t_RightParen ");
    yyerror("built_in_function_call: t_ROSE t_LeftParen /* bit */ hdl_or_psl_expression t_RightParen ");
}
| t_ROSE t_LeftParen /* bit */ hdl_or_psl_expression t_Comma clock_expression t_RightParen
{
    yydebug("built_in_function_call: t_ROSE t_LeftParen /* bit */ hdl_or_psl_expression t_Comma clock_expression t_RightParen ");
    yyerror("built_in_function_call: t_ROSE t_LeftParen /* bit */ hdl_or_psl_expression t_Comma clock_expression t_RightParen ");
}
| t_FELL t_LeftParen /* bit */ hdl_or_psl_expression t_RightParen
{
    yydebug("built_in_function_call: t_FELL t_LeftParen /* bit */ hdl_or_psl_expression t_RightParen ");
    yyerror("built_in_function_call: t_FELL t_LeftParen /* bit */ hdl_or_psl_expression t_RightParen ");
}
| t_FELL t_LeftParen /* bit */ hdl_or_psl_expression t_Comma clock_expression t_RightParen
{
    yydebug("built_in_function_call: t_FELL t_LeftParen /* bit */ hdl_or_psl_expression t_Comma clock_expression t_RightParen ");
    yyerror("built_in_function_call: t_FELL t_LeftParen /* bit */ hdl_or_psl_expression t_Comma clock_expression t_RightParen ");
}
| t_ENDED t_LeftParen sequence t_RightParen
{
    yydebug("built_in_function_call: t_ENDED t_LeftParen sequence )'");
    yyerror("built_in_function_call: t_ENDED t_LeftParen sequence )' is not supported");
}
| t_ENDED t_LeftParen sequence t_Comma clock_expression t_RightParen
{
    yydebug("built_in_function_call: t_ENDED t_LeftParen sequence t_Comma clock_expression )'");
    yyerror("built_in_function_call: t_ENDED t_LeftParen sequence t_Comma clock_expression )' is not supported");
}
| t_ISUNKNOWN t_LeftParen /* bitvector */ hdl_or_psl_expression t_RightParen
{
    yydebug("built_in_function_call: t_ISUNKNOWN t_LeftParen /* bitvector */ hdl_or_psl_expression t_RightParen ");
    yyerror("built_in_function_call: t_ISUNKNOWN t_LeftParen /* bitvector */ hdl_or_psl_expression t_RightParen is not supported");
}
| t_COUNTONES t_LeftParen /* bitvector */ hdl_or_psl_expression t_RightParen
{
    yydebug("built_in_function_call: t_COUNTONES t_LeftParen /* bitvector */ hdl_or_psl_expression t_RightParen ");
    yyerror("built_in_function_call: t_COUNTONES t_LeftParen /* bitvector */ hdl_or_psl_expression t_RightParen is not supported");
}
| t_ONEHOT t_LeftParen /* bitvector */ hdl_or_psl_expression t_RightParen
{
    yydebug("built_in_function_call: t_ONEHOT t_LeftParen /* bitvector */ hdl_or_psl_expression t_RightParen");
    yyerror("built_in_function_call: t_ONEHOT t_LeftParen /* bitvector */ hdl_or_psl_expression t_RightParen is not supported");
}
| t_ONEHOT0 t_LeftParen /* bitvector */ hdl_or_psl_expression t_RightParen
{
    yydebug("built_in_function_call: t_ONEHOT0 t_LeftParen /* bitvector */ hdl_or_psl_expression t_RightParen");
    yyerror("built_in_function_call: t_ONEHOT0 t_LeftParen /* bitvector */ hdl_or_psl_expression t_RightParen is not supported");
}
| t_NONDET t_LeftParen value_set t_RightParen
{
    yydebug("built_in_function_call: t_NONDET t_LeftParen value_set t_RightParen ");
    yyerror("built_in_function_call: t_NONDET t_LeftParen value_set t_RightParen is not supported");
}
| t_NONDET_VECTOR t_LeftParen /* number */ hdl_or_psl_expression t_Comma value_set t_RightParen
{
    yydebug("built_in_function_call: t_NONDET_VECTOR t_LeftParen /* number */ hdl_or_psl_expression t_Comma value_set t_RightParen ");
    yyerror("built_in_function_call: t_NONDET_VECTOR t_LeftParen /* number */ hdl_or_psl_expression t_Comma value_set t_RightParen is not supported");
};


union_expression:
/* any_type */ hdl_or_psl_expression t_UNION /* any_type */ hdl_or_psl_expression
{
    yydebug("union_expression: /* any_type */ hdl_or_psl_expression t_UNION /* any_type */ hdl_or_psl_expression ");
    yyerror("union_expression: /* any_type */ hdl_or_psl_expression t_UNION /* any_type */ hdl_or_psl_expression is not supported");
};

//obe_property:
/////* boolean */ hdl_or_psl_expression
////| /* obe_property_name */ /* hdl_or_psl_identifier */ identifier actual_parameter_list_paren_opt
////
//// NOTE: property -> fl_property -> hdl_or_psl_expression
////hdl_or_psl_expression actual_parameter_list_paren_opt
//hdl_or_psl_expression t_LeftParen actual_parameter_list t_RightParen
////| sequence_instance // the same as above
//| NOT_OP obe_property %prec NOT_PREC
//| obe_property AND_OP obe_property
//| obe_property OR_OP obe_property
//| obe_property t_BOOLEAN_IMPLICATION obe_property
//| obe_property t_DOUBLE_BOOLEAN_IMPLICATION obe_property
//| t_AX obe_property
//| t_AG obe_property
//| t_AF obe_property
//| t_A t_LeftBracket obe_property t_U obe_property t_RightBracket
//| t_EX obe_property
//| t_EG obe_property
//| t_EF obe_property
//| t_E t_LeftBracket obe_property t_U obe_property t_RightBracket
//;

//actualparameter_list_paren_opt:
///* empty */
//{
//    yydebug("actualparameter_list_paren_opt: empty");
//    yyerror("actualparameter_list_paren_opt: empty is not supported");
//}
//| t_LeftParen actual_parameter_list t_RightParen
//{
//    yydebug("actualparameter_list_paren_opt: t_LeftParen actual_parameter_list t_RightParen");
//    yyerror("actualparameter_list_paren_opt: t_LeftParen actual_parameter_list t_RightParen is not supported");
//};



DEF_SYM:
t_IS
{
    yydebug("DEF_SYM: t_IS");
};


RANGE_SYM:
t_TO
{
    yydebug("RANGE_SYM: t_TO");
};


AND_OP:
t_AND
{
    yydebug("AND_OP: t_AND");
    RULE_BREAK_MACRO $$ = op_and;
};


OR_OP:
t_OR
{
    yydebug("OR_OP: t_OR");
    RULE_BREAK_MACRO $$ = op_or;
};


//MIN_VAL:
//'0'
//{
//    yydebug("MIN_VAL: '0'");
//};


//MAX_VAL:
//t_INF
//{
//    yydebug("MAX_VAL: t_INF");
//};

//LEFT_SYM: t_LeftParen;
//RIGHT_SYM: t_RightParen;
//NOT_OP: t_NOT

//HDL_EXPR:
//expression
//{
//    yydebug("HDL_EXPR: expression");
//    RULE_BREAK_MACRO $1;
//};

//HDL_CLOCK_EXPR:
//expression
//{
//    yydebug("HDL_CLOCK_EXPR: expression");
//    yyerror("HDL_CLOCK_EXPR: expression is not supported");
//};


//HDL_UNIT:
//design_unit
//{
//    yydebug("HDL_UNIT: design_unit");
//    $$ = $1;
//};

HDL_DECL:
block_declarative_item
{
    yydebug("HDL_DECL: block_declarative_item");
    RULE_BREAK_MACRO $$ = $1;
};

HDL_STMT:
concurrent_statement
{
    yydebug("HDL_STMT: concurrent_statement");
    RULE_BREAK_MACRO $$ = $1;
};


HDL_SEQ_STMT:
sequential_statement
{
    yydebug("HDL_SEQ_STMT: sequential_statement");
    RULE_BREAK_MACRO $$ = $1;
};

HDL_VARIABLE_TYPE:
subtype_indication
{
    yydebug("HDL_VARIABLE_TYPE: subtype_indication");
    RULE_BREAK_MACRO $$ = parserInstance->parse_HdlVariableType( $1 );
};


//HDL_RANGE:
//range // range -> attribute_name
//{
//    yydebug("HDL_RANGE: range");
//    RULE_BREAK_MACRO $$ = $1;
//};

%%

#ifdef DEBUG_HERE
#endif
#ifdef TRANSFER
#endif
#ifdef CLEAR
#endif
#ifdef t_Colon
#endif
#ifdef t_ABS
#endif
#ifdef t_UNAFFECTED
#endif
#ifdef t_VarAsgn
#endif
#ifdef t_AND
#endif
#ifdef t_LeftParen
#endif
#ifdef t_LeftBracket
#endif
#ifdef t_RightBracket
#endif
#ifdef t_FILE
#endif
#ifdef yyerrok
#endif
#ifdef YYNRULES
#endif
#ifdef t_BasedLit
#endif
#ifdef t_WAIT
#endif
#ifdef t_WITH
#endif
#ifdef t_Ampersand
#endif
#ifdef YY_LOCATION_PRINT
#endif
#ifdef YYTOKENTYPE
#endif
#ifdef t_NULL
#endif
#ifdef t_OctStringLit
#endif
#ifdef t_PROCEDURE
#endif
#ifdef t_POSTPONED
#endif
#ifdef t_BODY
#endif
#ifdef YYNSTATES
#endif
#ifdef t_ELSIF
#endif
#ifdef t_ATTRIBUTE
#endif
#ifdef t_Bar
#endif
#ifdef t_Plus
#endif
#ifdef t_NEW
#endif
#ifdef t_GESym
#endif
#ifdef t_CharacterLit
#endif
#ifdef YYLSP_NEEDED
#endif
#ifdef t_Minus
#endif
#ifdef t_SEVERITY
#endif
#ifdef t_ARRAY
#endif
#ifdef t_LIBRARY
#endif
#ifdef t_REPORT
#endif
#ifdef t_OTHERS
#endif
#ifdef YYRHSLOC
#endif
#ifdef YYRECOVERING
#endif
#ifdef t_BUS
#endif
#ifdef t_GROUP
#endif
#ifdef t_TO
#endif
#ifdef t_XOR
#endif
#ifdef t_REM
#endif
#ifdef t_ACCESS
#endif
#ifdef t_AFTER
#endif
#ifdef YYFAIL
#endif
#ifdef t_Slash
#endif
#ifdef t_Comma
#endif
#ifdef t_BEGIN
#endif
#ifdef YYPULL
#endif
#ifdef t_NAND
#endif
#ifdef t_THEN
#endif
#ifdef t_INERTIAL
#endif
#ifdef t_ALL
#endif
#ifdef t_FUNCTION
#endif
#ifdef t_Arrow
#endif
#ifdef t_LTSym
#endif
#ifdef t_CASE
#endif
#ifdef YYBISON_VERSION
#endif
#ifdef t_Star
#endif
#ifdef t_RightParen
#endif
#ifdef t_RightBrace
#endif
#ifdef t_LeftBrace
#endif
#ifdef t_UNTIL
#endif
#ifdef YYBISON
#endif
#ifdef t_Dot
#endif
#ifdef t_PURE
#endif
#ifdef t_Semicolon
#endif
#ifdef t_DoubleStar
#endif
#ifdef t_ASSERT
#endif
#ifdef t_RANGE
#endif
#ifdef t_END
#endif
#ifdef t_GUARDED
#endif
#ifdef t_PACKAGE
#endif
#ifdef t_LINKAGE
#endif
#ifdef YYNNTS
#endif
#ifdef t_LABEL
#endif
#ifdef t_PROCESS
#endif
#ifdef t_OPEN
#endif
#ifdef t_GTSym
#endif
#ifdef t_Identifier
#endif
#ifdef t_MAP
#endif
#ifdef t_REGISTER
#endif
#ifdef t_MOD
#endif
#ifdef t_VARIABLE
#endif
#ifdef t_PORT
#endif
#ifdef t_ELSE
#endif
#ifdef t_NESym
#endif
#ifdef t_CONFIGURATION
#endif
#ifdef t_BitStringLit
#endif
#ifdef t_FOR
#endif
#ifdef YYERROR
#endif
#ifdef t_WHILE
#endif
#ifdef YYSTYPE_IS_DECLARED
#endif
#ifdef t_BLOCK
#endif
#ifdef t_SUBTYPE
#endif
#ifdef t_SELECT
#endif
#ifdef t_ENTITY
#endif
#ifdef t_ARCHITECTURE
#endif
#ifdef t_LESym
#endif
#ifdef t_UNITS
#endif
#ifdef t_TYPE
#endif
#ifdef t_AbstractLit
#endif
#ifdef yyclearin
#endif
#ifdef t_USE
#endif
#ifdef t_EQSym
#endif
#ifdef t_COMPONENT
#endif
#ifdef t_NOR
#endif
#ifdef t_NOT
#endif
#ifdef YYBACKUP
#endif
#ifdef YYSKELETON_NAME
#endif
#ifdef YYERRCODE
#endif
#ifdef t_REJECT
#endif
#ifdef t_RETURN
#endif
#ifdef t_INOUT
#endif
#ifdef t_Apostrophe
#endif
#ifdef yystype
#endif
#ifdef t_GENERATE
#endif
#ifdef t_IMPURE
#endif
#ifdef t_TRANSPORT
#endif
#ifdef t_BUFFER
#endif
#ifdef YYPURE
#endif
#ifdef t_DOWNTO
#endif
#ifdef YYPUSH
#endif
#ifdef t_CONSTANT
#endif
#ifdef t_ALIAS
#endif
#ifdef t_SIGNAL
#endif
#ifdef t_EXIT
#endif
#ifdef t_GENERIC
#endif
#ifdef t_WHEN
#endif
#ifdef t_HexStringLit
#endif
#ifdef t_OUT
#endif
#ifdef t_DISCONNECT
#endif
#ifdef t_LOOP
#endif
#ifdef t_NEXT
#endif
#ifdef t_XNOR
#endif
#ifdef YYLLOC_DEFAULT
#endif
#ifdef YYPACT_NINF
#endif
#ifdef YYTABLE_NINF
#endif
#ifdef YYLTYPE_IS_TRIVIAL
#endif
#ifdef t_IF
#endif
#ifdef t_IN
#endif
#ifdef t_IS
#endif
#ifdef t_StringLit
#endif
#ifdef t_ON
#endif
#ifdef t_RECORD
#endif
#ifdef t_OF
#endif
#ifdef t_OR
#endif
#ifdef t_ROR
#endif
#ifdef t_SHARED
#endif
#ifdef t_ROL
#endif
#ifdef t_SLA
#endif
#ifdef t_SLL
#endif
#ifdef t_SRA
#endif
#ifdef t_SRL
#endif
#ifdef t_LITERAL
#endif
#ifdef t_PROTECTED
#endif
#ifdef UMINUS
#endif
#ifdef t_ELSE_LOWER
#endif
#ifdef t_ELSIF_SUP
#endif
#ifdef LOW
#endif
#ifdef MEDIUM1
#endif
#ifdef MEDIUM2
#endif
#ifdef MEDIUM3
#endif
#ifdef HIGH
#endif

//
//  PSL
//
#ifdef t_ABORT
#endif
#ifdef t_NONDET_VECTOR
#endif
#ifdef t_NEXT_E
#endif
#ifdef t_ROSE
#endif
#ifdef t_MUTABLE
#endif
#ifdef t_NONTRANSITIVE
#endif
#ifdef t_PREV
#endif
#ifdef t_ALWAYS
#endif
#ifdef t_NEXT_EXCL
#endif
#ifdef t_NEXT_EVENT_A_EXCL
#endif
#ifdef t_BOOLEAN
#endif
#ifdef t_CONST
#endif
#ifdef t_RESTRICT
#endif
#ifdef t_BIT
#endif
#ifdef t_ISUNKNOWN
#endif
#ifdef t_VMODE
#endif
#ifdef t_COVER
#endif
#ifdef t_SEQUENCE
#endif
#ifdef t_NEXT_A
#endif
#ifdef t_DOUBLE_AND
#endif
#ifdef t_FREE
#endif
#ifdef t_NEXT_EVENT_E_EXCL
#endif
#ifdef t_RESTRICT_EXCL
#endif
#ifdef t_ONEHOT0
#endif
#ifdef t_DOUBLE_BOOLEAN_IMPLICATION
#endif
#ifdef t_OVERRIDE
#endif
#ifdef t_INF
#endif
#ifdef t_SYNC_ABORT
#endif
#ifdef t_A
#endif
#ifdef t_E
#endif
#ifdef t_G
#endif
#ifdef t_U
#endif
#ifdef t_W
#endif
#ifdef t_X
#endif
#ifdef t_BEFORE_EXCL
#endif
#ifdef t_ONEHOT
#endif
#ifdef t_DOUBLE_CLOSE_BRACKETS
#endif
#ifdef t_BEFORE_EXCL_UNDERSCORE
#endif
#ifdef t_BITVECTOR
#endif
#ifdef t_NEXT_A_EXCL
#endif
#ifdef t_ENDED
#endif
#ifdef t_VUNIT
#endif
#ifdef t_DOUBLE_SEQUENCE_IMPLICATION
#endif
#ifdef t_DOUBLE_OPEN_BRACKETS
#endif
#ifdef t_FELL
#endif
#ifdef t_VPROP
#endif
#ifdef t_NEXT_EVENT
#endif
#ifdef t_NEXT_EVENT_A
#endif
#ifdef t_INHERIT
#endif
#ifdef t_UNION
#endif
#ifdef t_BEFORE_UNDERSCORE
#endif
#ifdef t_FAIRNESS
#endif
#ifdef t_WITHIN
#endif
#ifdef t_NEXT_E_EXCL
#endif
#ifdef t_STRONG
#endif
#ifdef t_ASYNC_ABORT
#endif
#ifdef t_CLOCK
#endif
#ifdef t_F
#endif
#ifdef t_UNTIL_EXCL_UNDERSCORE
#endif
#ifdef t_UNTIL_UNDERSCORE
#endif
#ifdef t_BEFORE
#endif
#ifdef t_UNTIL_EXCL
#endif
#ifdef t_SEQUENCE_IMPLICATION
#endif
#ifdef t_FORALL
#endif
#ifdef t_ASSUME
#endif
#ifdef t_STRING
#endif
#ifdef t_STABLE
#endif
#ifdef t_HDLTYPE
#endif
#ifdef t_NONDET
#endif
#ifdef t_COUNTONES
#endif
#ifdef t_X_EXCL
#endif
#ifdef t_VPKG
#endif
#ifdef t_NEXT_EVENT_EXCL
#endif
#ifdef t_PROPERTY
#endif
#ifdef t_NEXT_EVENT_E
#endif
#ifdef t_EVENTUALLY_EXCL
#endif
#ifdef t_BOOLEAN_IMPLICATION
#endif
#ifdef t_NUMERIC
#endif
#ifdef t_AF
#endif
#ifdef t_AG
#endif
#ifdef t_AX
#endif
#ifdef t_EF
#endif
#ifdef t_EG
#endif
#ifdef t_EX
#endif
#ifdef t_NEVER
#endif
#ifdef t_DEFAULT
#endif
#ifdef t_AT
#endif
#ifdef t_Excl
#endif
#ifdef NOT_PREC
#endif
