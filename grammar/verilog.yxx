/// @file verilog.yxx
/// @brief
/// @copyright (c) 2024 Electronic Systems Design (ESD) Lab @ UniVR
/// This file is distributed under the BSD 2-Clause License.
/// See LICENSE.md for details.

%{

#include <iostream>
#include <string>

// HIF library
#include <hif/hif.hpp>

#include "verilog2hif/support.hpp"
#include "verilog2hif/verilog_parser.hpp"

// Bison
#define YYENABLE_NLS        0
#define YYLTYPE_IS_TRIVIAL  0
#define YYERROR_VERBOSE     1

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wreserved-id-macro"
#pragma clang diagnostic ignored "-Wmissing-variable-declarations"
#pragma clang diagnostic ignored "-Wunused-macros"
#pragma clang diagnostic ignored "-Wunreachable-code"
#endif

#ifdef __clang__
#pragma clang diagnostic ignored "-Wconversion"
#pragma clang diagnostic ignored "-Wstrict-overflow"
#pragma clang diagnostic ignored "-Wold-style-cast"
#pragma clang diagnostic ignored "-Wmissing-declarations"
#pragma clang diagnostic ignored "-Wswitch-default"
#pragma clang diagnostic ignored "-Wimplicit-fallthrough"
#pragma clang diagnostic ignored "-Wdeprecated-register"
#pragma clang diagnostic ignored "-Wunreachable-code-break"
#elif defined __GNUC__
#pragma GCC diagnostic ignored "-Wconversion"
#pragma GCC diagnostic ignored "-Wstrict-overflow"
#pragma GCC diagnostic ignored "-Wold-style-cast"
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#pragma GCC diagnostic ignored "-Wswitch-default"
#pragma GCC diagnostic ignored "-Wzero-as-null-pointer-constant"
#pragma GCC diagnostic ignored "-Wunsafe-loop-optimizations"
#ifndef _MSC_VER
// not MinGW
#pragma GCC diagnostic ignored "-Wsign-conversion"
#endif
#else
#pragma warning(disable:4244)
#pragma warning(disable:4127)
#pragma warning(disable:4065)
#pragma warning(disable:4702)
#endif

extern int yylex (void);
extern char *yytext;
extern int yyleng;
extern void lex_start_table();
extern void lex_end_table();
extern const char * HIF_ALL_SENSITIVITY;

using namespace hif;

extern VerilogParser * parserInstance;
VerilogParser * parserInstance = nullptr;

#define RULE_BREAK_MACRO        if (parserInstance->isParseOnly()) break;

%}

%union
{
    int     type_net;
    bool    flag;
    char *  undefined;
    char *  text;
    float   realtime;
    int     direction_port;
    char *  value;

    keyword_data_t    Keyword_data;
    identifier_data_t Identifier_data;
    number_t          number;
    realNum_t         realNum;

    module_item_t *                                            module_item_struct;
    module_or_generate_item_t *                                module_or_generate_item_struct;
    non_port_module_item_t *                                   non_port_module_item_struct;
    module_or_generate_item_declaration_t *                    module_or_generate_item_declaration_struct;
    task_item_declaration_t *                                  task_item_declaration_struct;
    block_item_declaration_t *                                 block_item_declaration_struct;
    function_item_declaration_t *                              function_item_declaration_struct;
    list_of_port_connections_t *                               list_of_port_connections_struct;
    list_of_parameter_assignment_t *                           list_of_parameter_assignment_struct;
    statement_t *                                              statement_struct;
    analog_statement_t *                                       analog_statement_struct;
    event_expression_t *                                       event_expression_struct;
    analog_event_expression_t *                                analog_event_expression_struct;
    event_control_t *                                          event_control_struct;
    analog_event_control_t *                                   analog_event_control_struct;
    procedural_timing_control_t *                              procedural_timing_control_struct;
    net_ams_decl_identifier_assignment_t *                     net_ams_decl_identifier_assignment_struct;
    discipline_and_modifiers_t *                               discipline_and_modifiers_struct;
    discipline_identifier_signed_range_t *                     discipline_identifier_signed_range_struct;
    module_instance_and_net_ams_decl_identifier_assignment_t * module_instance_and_net_ams_decl_identifier_assignment;
    analog_function_item_declaration_t *                       analog_function_item_declaration_struct;
    analog_filter_function_arg_t *                             analog_filter_function_arg_struct;
    specify_item_t *                                           specify_item_struct;
    specify_terminal_descriptor_t *                            specify_terminal_descriptor_struct;
    timing_check_event_control_t *                             timing_check_event_control_struct;
    generate_block_t *                                         generate_block_struct;

    hif::Operator                               hif_operator;
    hif::RangeDirection                         hif_range_direction;
    hif::PortDirection                          hif_port_direction;

    hif::Action *                               action_object;
    hif::Assign *                               assign_object;
    hif::Aggregate *                            aggregate_object;
    hif::AggregateAlt *                         aggregatealt_object;
    hif::Array *                                array_object;
    hif::Break *                                break_object;
    hif::Cast *                                 cast_object;
    hif::CompositeType *                        compositetype_object;
    hif::ConstValue *                           constvalue_object;
    hif::Contents *                             contents_object;
    hif::Declaration *                          decl_object;
    hif::DesignUnit *                           design_unit;
    hif::Enum *                                 enum_object;
    hif::EnumValue *                            enumvalue_object;
    hif::Break *                                exit_object;
    hif::FunctionCall *                         fcall_object;
    hif::Function *                             function_object;
    hif::FieldReference *                       fieldref_object;
    hif::For *                                  for_object;
    hif::Identifier *                           identifier_object;
    hif::If *                                   if_object;
    hif::IfGenerate *                           ifgenerate_object;
    hif::Instance *                             instance_object;
    hif::IntValue *                             intval_object;
    hif::Member *                               member_object;
    hif::Object *                               object_object;
    hif::ParameterAssign *                      paramassign_object;
    hif::Procedure *                            procedure_object;
    hif::ProcedureCall *                        pcall_object;
    hif::Port *                                 port_object;
    hif::PortAssign *                           portassign_object;
    hif::Range *                                range_object;
    hif::RealValue *                            realval_object;
    hif::Record *                               record_object;
    hif::Return *                               return_object;
    hif::StateTable *                           st_object;
    hif::SubProgram *                           subprogram_object;
    hif::Signal *                               signal_object;
    hif::Switch *                               switch_object;
    hif::SwitchAlt *                            switchalt_object;
    hif::TPAssign *                             tpassign_object;
    hif::TypeDef *                              typedef_object;
    hif::Type *                                 type_object;
    hif::Value *                                value_object;
    hif::ValueStatement *                       valuestatement_object;
    hif::ValueTPAssign *                        valuetpassign_object;
    hif::Variable *                             variable_object;
    hif::ViewReference *                        viewref_object;
    hif::Wait *                                 wait_object;
    hif::Const *                                const_object;
    hif::ValueTP *                              valuetp_object;


    hif::BList<hif::Assign> *                   assign_list;
    hif::BList<hif::Action> *                   action_list;
    hif::BList<hif::AggregateAlt> *             aggregatealt_list;
    hif::BList<hif::Const> *                    const_list;
    hif::BList<hif::Declaration> *              decl_list;
    hif::BList<hif::Field> *                    field_list;
    hif::BList<hif::FieldReference> *           fieldref_list;
    hif::BList<hif::EnumValue> *                enumvalue_list;
    hif::BList<hif::Library> *                  library_list;
    hif::BList<hif::Identifier> *               identifier_list;
    hif::BList<hif::IfAlt> *                    ifalt_list;
    hif::BList<hif::Generate> *                 generate_list;
    hif::BList<hif::Instance> *                 instance_list;
    hif::BList<hif::Object> *                   object_list;
    hif::BList<hif::Parameter> *                param_list;
    hif::BList<hif::ParameterAssign> *          paramassign_list;
    hif::BList<hif::PortAssign> *               portassign_list;
    hif::BList<hif::Port> *                     port_list;
    hif::BList<hif::PPAssign> *                 ppassign_list;
    hif::BList<hif::Range> *                    range_list;
    hif::BList<hif::Scope> *                    scope_list;
    hif::BList<hif::Signal> *                   signal_list;
    hif::BList<hif::SwitchAlt> *                switchalt_list;
    hif::BList<hif::TPAssign> *                 tpassign_list;
    hif::BList<hif::Value> *                    value_list;
    hif::BList<hif::Variable> *                 variable_list;
    hif::BList<hif::ValueTP> *                  valuetp_list;
    hif::BList<hif::ValueTPAssign> *            valuetpassign_list;
    hif::BList<hif::ViewReference> *            viewref_list;
    
    std::list<module_item_t*> *                                            module_item_struct_list;
    std::list<non_port_module_item_t*> *                                   non_port_module_item_struct_list;
    std::list<task_item_declaration_t*> *                                  task_item_declaration_struct_list;
    std::list<block_item_declaration_t*> *                                 block_item_declaration_struct_list;
    std::list<function_item_declaration_t*> *                              function_item_declaration_struct_list;
    std::list<std::string> *                                                            string_list;
    std::list<statement_t*> *                                              statement_struct_list;
    std::list<analog_statement_t*> *                                       analog_statement_struct_list;
    std::list<net_ams_decl_identifier_assignment_t*> *                     net_ams_decl_identifier_assignment_struct_list;
    std::list<event_expression_t*> *                                       event_expression_struct_list;
    std::list<module_instance_and_net_ams_decl_identifier_assignment_t*> * module_instance_and_net_ams_decl_identifier_assignment_list;
    std::list<specify_item_t*> *                                           specify_item_struct_list;
    std::list<module_or_generate_item_t*> *                                module_or_generate_list;
}


/*
 * List of non-terminal symbols
 * ------------------------------------------------------------------------------ */
%token<Keyword_data>
K_always
K_assign
K_automatic
K_begin
K_buf
K_bufif0
K_bufif1
K_case
K_casex
K_casez
K_cell
K_cmos
K_config
K_deassign
K_default
K_defparam
K_design
K_disable
K_edge
K_end
K_endcase
K_endconfig
K_endfunction
K_endgenerate
K_endmodule
K_endprimitive
K_endspecify
K_endtable
K_endtask
K_event
K_for
K_force
K_forever
K_fork
K_function
K_generate
K_genvar
K_highz0
K_highz1
K_if
K_ifnone
K_incdir
K_include
K_initial
K_inout
K_input
K_instance
K_integer
K_join
K_large
K_liblist
K_library
K_localparam
K_macromodule
K_medium
K_module
K_negedge
K_nmos
K_noshowcancelled
K_not
K_notif0
K_notif1
K_output
K_parameter
K_pathpulse
K_pmos
K_posedge
K_primitive
K_pull0
K_pull1
K_pulldown
K_pullup
K_pulsestyle_onevent
K_pulsestyle_ondetect
K_rcmos
K_real
K_realtime
K_reg
K_release
K_repeat
K_rnmos
K_rpmos
K_rtran
K_rtranif0
K_rtranif1
K_scalared
K_showcancelled
K_signed
K_small
K_specify
K_specparam
K_strong0
K_strong1
K_supply0
K_supply1
K_table
K_task
K_time
K_tran
K_tranif0
K_tranif1
K_tri
K_tri0
K_tri1
K_triand
K_trior
K_trireg
// reserved for possible future usage
K_unsigned
K_use
K_uwire
K_vectored
K_wait
K_wand
K_weak0
K_weak1
K_while
K_wire
K_wor


// ** VERILOG_AMS **
%token<Keyword_data>
K_above
K_abs
K_absdelay
K_absdelta
K_abstol
K_access
K_acos
K_acosh
K_ac_stim
K_aliasparam
K_analog
K_analysis
K_asin
K_asinh
K_atan
K_atan2
K_atanh
K_branch
K_ceil
K_connect
K_connectmodule
K_connectrules
K_continuous
K_cos
K_cosh
K_cross
K_ddt
K_ddt_nature
K_ddx
K_discipline
K_discrete
K_domain
K_driver_update
K_endconnectrules
K_enddiscipline
K_endnature
K_endparamset
K_exclude
K_exp
K_final_step
K_flicker_noise
K_floor
K_flow
K_from
K_ground
K_hypot
K_idt
K_idtmod
K_idt_nature
K_inf
K_initial_step
K_laplace_nd
K_laplace_np
K_laplace_zd
K_laplace_zp
K_last_crossing
K_limexp
K_ln
K_log
K_max
K_merged
K_min
K_nature
K_net_resolution
K_noise_table
K_paramset
K_potential
K_pow
K_resolveto
K_sin
K_sinh
K_slew
K_split
K_sqrt
K_string
K_tan
K_tanh
K_timer
K_transition
K_units
K_white_noise
K_wreal
K_zi_nd
K_zi_np
K_zi_zd
K_zi_zp

/* Token for inclusion management */
STD_LIB_INCLUDE

%left K_and K_nand K_or K_nor K_xnor K_xor

/* to resolve dangling else ambiguity. */
%nonassoc less_than_K_else
%nonassoc K_else

%nonassoc LOW
%nonassoc MEDIUM1
%nonassoc MEDIUM2
%nonassoc MEDIUM3
%nonassoc MEDIUM4
%nonassoc MEDIUM5
%nonassoc MEDIUM6
%nonassoc HIGH

/*
 * Tokens recognized by the Lexical Analyzer (terminal symbols)
 * ------------------------------------------------------------------------------ */
%token K_EG K_SG 
%token K_PO_POS K_PO_NEG
%token K_TRIGGER
%token K_CONTRIB
%token K_EQ
%token K_DOT
%token K_QUOTE
%left K_COMMA

/*
 * Tokens starting with $
 * ------------------------------------------------------------------------------ */
%token 
K_Ssetuphold 
K_Sattribute
K_Shold
K_Speriod
K_Srecovery
K_Srecrem
K_Ssetup
K_Swidth
K_Snochange
K_Sfullskew
K_Stimeskew
K_Sskew
K_Sremoval

%token K_AT K_ATSTAR

%token K_SHARP

%token K_PSTAR K_STARP K_PSTARP
%token K_LPAREN K_LBRACKET K_LBRACE
%token K_RPAREN K_RBRACKET K_RBRACE
%token K_SEMICOLON


/*
 * PRECEDENCES OF OPERANDS
 * ------------------------------------------------------------------------------ */
%right K_QUEST K_COLON
%left K_LOR
%left K_LAND K_TAND
%left K_BAR
%left K_NXOR K_CAP
%left K_AMPERSAND
%left K_EQEQ K_CNE K_NE K_CEQ
%left K_GT K_LT K_LE K_GE
%left K_LS K_LSS K_RSS K_RS
%left K_PLUS K_MINUS
%left K_PERC K_STAR K_SLASH
%left K_POW
%left K_TILDE K_EXCL K_NOR K_NAND


%left UNARY_PREC
//%left TILDE_PREC



/* 
 * Object representation of tokens (non-terminal symbols)
 * ------------------------------------------------------------------------------ */

%type   <design_unit>                                   module_declaration_start
%type   <design_unit>                                   module_declaration

%type   <contents_object>                               initial_construct

%type   <assign_list>                                   list_of_net_assignments
%type   <assign_list>                                   continuous_assign

%type   <assign_object>                                 assignment
%type   <assign_object>                                 blocking_assignment
%type   <assign_object>                                 nonblocking_assignment

%type   <port_object>                                   input_declaration
%type   <port_object>                                   output_declaration
%type   <port_object>                                   inout_declaration
%type   <port_object>                                   port_declaration
%type   <port_object>                                   port_reference
%type   <port_object>                                   tf_input_declaration

%type   <port_list>                                     list_of_port_declarations_or_null
%type   <port_list>                                     list_of_port_declarations
%type   <port_list>                                     port_declaration_identifiers
%type   <port_list>                                     port_reference_list port_reference_list_paren
%type   <port_list>                                     input_declaration_identifiers
%type   <port_list>                                     output_declaration_identifiers
%type   <port_list>                                     inout_declaration_identifiers
%type   <port_list>                                     list_of_variable_port_identifiers
%type   <port_list>                                     tf_input_declaration_identifiers
%type   <port_list>                                     tf_output_declaration_identifiers
%type   <port_list>                                     tf_inout_declaration_identifiers
%type   <port_list>                                     task_port_item task_port_list
%type   <port_list>                                     function_port_list

%type   <portassign_list>                               named_port_connection_list

%type   <identifier_object>                             identifier_opt
%type   <identifier_object>                             name_of_instance
%type   <identifier_object>                             notifier_opt
%type   <identifier_object>                             comma_notifier_opt_opt
%type   <identifier_list>                               list_of_identifiers

%type   <module_instance_and_net_ams_decl_identifier_assignment>      module_instance
%type   <module_instance_and_net_ams_decl_identifier_assignment_list> module_instance_list
%type   <module_instance_and_net_ams_decl_identifier_assignment_list> module_instantiation

%type   <range_object>                                  range range_opt
%type   <range_list>                                    dimension_list non_empty_dimension_list

%type   <type_object>                                   output_variable_type

%type   <action_object>                                 loop_statement analog_loop_statement
                                 
%type   <assign_object>                                 param_assignment

%type   <valuetp_list>                                  parameter_declaration parameter_declaration_identifiers

%type   <valuetpassign_object>                          named_parameter_assignment
%type   <valuetpassign_list>                            parameter_value_assignment
%type   <valuetpassign_list>                            parameter_value_assignment_opt
%type   <valuetpassign_list>                            named_parameter_assignment_list

%type   <assign_list>                                   list_of_param_assignments

%type   <const_list>                                    local_parameter_declaration

%type   <value_object>                                  hierarchical_identifier hierarchical_identifier_item nature_attribute_identifier
%type   <value_object>                                  eq_constant_expression_opt
%type   <value_object>                                  expression
%type   <value_object>                                  constant_arrayinit
%type   <value_object>                                  timing_check_condition
%type   <value_object>                                  primary
%type   <value_object>                                  analog_expression_or_null
%type   <value_object>                                  analog_reference
%type   <value_object>                                  unsigned_number number
%type   <value_object>                                  range_expression value_range_expression
%type   <value_object>                                  constant_bracket_range_expression_opt
%type   <value_object>                                  expression_opt branch_terminal
%type   <value_object>                                  mintypmax_expression mintypmax_expression_opt
%type   <value_object>                                  multiple_concatenation
%type   <value_object>                                  lvalue
%type   <value_object>                                  timing_check_event

%type   <value_list>                                    concatenation
%type   <value_list>                                    bracket_range_expression_list
%type   <value_list>                                    ordered_port_connection_list 
%type   <value_list>                                    comma_expression_list
%type   <value_list>                                    comma_expression_opt_list
%type   <value_list>                                    task_enable_expression_opt
%type   <value_list>                                    expression_comma_list branch_terminal_list
%type   <value_list>                                    bracket_expression_list
%type   <value_list>                                    constant_optional_arrayinit

%type   <signal_object>                                 block_type
%type   <signal_object>                                 type

%type   <signal_list>                                   list_of_variable_identifiers
%type   <signal_list>                                   list_of_block_identifiers
%type   <signal_list>                                   list_of_real_identifiers

%type   <type_net>                                      net_type

%type   <value_object>                                  real_number

%type   <type_object>                                   function_range_or_type function_range_or_type_opt

%type   <decl_list>                                     module_parameter_port_list module_parameter_port_list_opt
%type   <decl_list>                                     parameter_declaration_list
%type   <decl_list>                                     reg_declaration
%type   <decl_list>                                     integer_declaration
%type   <decl_list>                                     net_declaration
%type   <decl_list>                                     real_declaration
%type   <decl_list>                                     time_declaration
%type   <decl_list>                                     realtime_declaration
%type   <decl_list>                                     analog_block_item_declaration
%type   <decl_list>                                     analog_block_item_declaration_list
%type   <decl_list>                                     branch_declaration
%type   <decl_list>                                     genvar_declaration

//%type   <hif_operator>                                  binary_op_set_1 unary_binary_op_set unary_op_set_1
//%type   <hif_operator>                                  unary_operator binary_operator

%type   <text>                                          generate_block_identifier_opt
%type   <generate_block_struct>                         generate_block
%type   <generate_block_struct>                         generate_block_or_null
%type   <generate_list>                                 if_generate_construct
%type   <generate_list>                                 conditional_generate_construct
%type   <module_or_generate_list>                       generate_region
%type   <assign_object>                                 genvar_initialization
%type   <assign_object>                                 genvar_iteration
%type   <generate_list>                                 loop_generate_construct

%type   <module_or_generate_item_struct>                module_or_generate_item
%type   <module_or_generate_list>                       module_or_generate_item_list
%type   <module_or_generate_item_declaration_struct>    module_or_generate_item_declaration
%type   <module_item_struct_list>                       module_item_list 
%type   <module_item_struct>                            module_item

%type   <switchalt_list>                                case_item_list analog_case_item_list
%type   <switch_object>                                 case_statement analog_case_statement
%type   <switchalt_object>                              case_item analog_case_item

%type   <if_object>                                     conditional_statement
%type   <if_object>                                     analog_conditional_statement
%type   <if_object>                                     analog_function_conditional_statement
//%type   <ifalt_list>                                    elseif_statement_or_null_list

%type   <procedure_object>                              task_declaration

%type   <discipline_and_modifiers_struct>               discipline_and_modifiers
%type   <discipline_identifier_signed_range_struct>     discipline_identifier_signed_range

%type   <task_item_declaration_struct>                  task_item_declaration
%type   <task_item_declaration_struct_list>             task_item_declaration_list

%type   <block_item_declaration_struct>                 block_item_declaration
%type   <block_item_declaration_struct_list>            block_item_declaration_list

%type   <function_object>                               function_declaration

%type   <st_object>                                     always_construct
%type   <st_object>                                     analog_construct

%type   <function_item_declaration_struct>              function_item_declaration
%type   <function_item_declaration_struct_list>         function_item_declaration_list

%type   <statement_struct>                              statement statement_or_null
%type   <statement_struct>                              seq_block
//%type   <statement_struct>                              else_statement_or_null_opt
%type   <statement_struct>                              procedural_timing_control_statement wait_statement
%type   <event_expression_struct_list>                  event_expression_list
%type   <event_expression_struct>                       event_expression
%type   <event_control_struct>                          event_control
%type   <analog_event_control_struct>                   analog_event_control
%type   <analog_event_expression_struct>                analog_event_expression

%type   <procedural_timing_control_struct>              procedural_timing_control
%type   <net_ams_decl_identifier_assignment_struct>     net_ams_decl_identifier_assignment

%type   <non_port_module_item_struct>                   non_port_module_item
%type   <non_port_module_item_struct_list>              non_port_module_item_list

%type   <list_of_parameter_assignment_struct>           list_of_parameter_assignments

%type   <statement_struct_list>                         statement_no_empty_list
%type   <net_ams_decl_identifier_assignment_struct_list>     net_ams_decl_identifier_assignment_list
%type   <type_object>                                   parameter_type

%type   <text>                                          noise_table_input_arg
%type   <fcall_object>                                  branch_probe_function_call
%type   <fcall_object>                                  indirect_expression
%type   <value_object>                                  analog_built_in_function_call
%type   <fcall_object>                                  analog_filter_function_call
%type   <fcall_object>                                  analog_small_signal_function_call
%type   <pcall_object>                                  contribution_statement
%type   <pcall_object>                                  indirect_contribution_statement
%type   <pcall_object>                                  system_task_enable
%type   <pcall_object>                                  task_enable

%type   <identifier_object>                             analog_built_in_function_name
%type   <value_object>                                  analog_variable_lvalue
%type   <assign_object>                                 analog_variable_assignment
%type   <assign_object>                                 analog_procedural_assignment

%type   <value_object>                                  delay_control
%type   <value_object>                                  delay_value
%type   <value_object>                                  delay2_opt
%type   <value_object>                                  delay2
%type   <value_object>                                  delay3_opt
%type   <value_object>                                  delay3
%type   <value_object>                                  delay_or_event_control

%type   <undefined>                                     pulldown_strength
%type   <undefined>                                     charge_strength
%type   <undefined>                                     drive_strength_opt
%type   <undefined>                                     drive_strength

%type   <string_list>                                   string_list

%type   <variable_object>                                nature_binding
%type   <variable_object>                                discipline_item
%type   <variable_list>                                  discipline_item_list

%type   <analog_function_item_declaration_struct>       analog_function_item_declaration
%type   <analog_function_item_declaration_struct>       analog_function_item_declaration_list

%type   <function_object>                               analog_function_declaration

%type   <analog_statement_struct>                       analog_statement
%type   <analog_statement_struct>                       analog_function_statement
%type   <analog_statement_struct>                       analog_function_statement_or_null
%type   <analog_statement_struct>                       analog_statement_or_null
%type   <analog_statement_struct>                       analog_event_statement
%type   <analog_statement_struct>                       analog_seq_block
%type   <analog_statement_struct>                       analog_event_seq_block
%type   <analog_statement_struct>                       analog_function_seq_block
%type   <analog_statement_struct>                       analog_event_control_statement

%type   <analog_statement_struct_list>                  analog_function_statement_no_empty_list
%type   <analog_statement_struct_list>                  analog_statement_no_empty_list
%type   <analog_statement_struct_list>                  analog_event_statement_no_empty_list

%type   <specify_item_struct>                           specify_item
%type   <specify_item_struct_list>                      specify_item_list
%type   <specify_item_struct_list>                      specify_block

%type   <value_object>                                  constant_expression_or_null
%type   <value_object>                                  analog_event_functions
%type   <value_object>                                  analysis_function_call
%type   <analog_filter_function_arg_struct>             analog_filter_function_arg

%type   <specify_terminal_descriptor_struct>            specify_input_terminal_descriptor
%type   <specify_terminal_descriptor_struct>            specify_output_terminal_descriptor
%type   <specify_terminal_descriptor_struct>            specify_terminal_descriptor

%type   <timing_check_event_control_struct>             timing_check_event_control
%type   <timing_check_event_control_struct>             timing_check_event_control_opt

%type   <pcall_object>                                  system_timing_check
%type   <pcall_object>                                  setup_timing_check
%type   <pcall_object>                                  hold_timing_check
%type   <pcall_object>                                  recovery_timing_check
%type   <pcall_object>                                  removal_timing_check
%type   <pcall_object>                                  skew_timing_check
%type   <pcall_object>                                  period_timing_check

%type   <text>                                          laplace_filter_name
%type   <text>                                          zi_filter_name
%type   <decl_list>                                     event_declaration
%type   <variable_list>                                 list_of_event_identifiers
%type   <valuestatement_object>                         event_trigger
%type   <break_object>                                  disable_statement
%type   <type_object>                                   task_port_type

%type   <range_object>                                  discipline_identifier_range
%type   <assign_object>                                 procedural_continuous_assignments

/*
 * Type of tokens recognized by the Lexical Analyzer (terminal symbols)
 * ------------------------------------------------------------------------------ */
%type   <flag>                                          K_signed_opt
%type   <flag>                                          K_automatic_opt
%type   <flag>                                          K_reg_opt

%token  <text>                                          IDENTIFIER SYSTEM_IDENTIFIER STRING 
%token  <number>                                        BASED_NUMBER DEC_NUMBER SCALAR_CONSTANT
%token  <realNum>                                       REALTIME

%verbose

%parse-param { VerilogParser * parser }

%initial-action
{
    parserInstance = parser;
}


%%
/* -----------------------------------------------------------------------
 *  VERILOG SOURCE TEXT
 * -----------------------------------------------------------------------
 */

source_text:
/* A degenerate source file can be completely empty */ 
{

}
| description source_text
{
    yydebug("source_text: source_text description.");
};

description:
module_declaration
{
    yydebug("description: module_declaration.");
}
| udp_declaration
{
    yydebug("description: udp_declaration.");
    yyerror("description: udp_declaration is not supported.");
}
| config_declaration
{
    yydebug("description: config_declaration.");
    yyerror("description: config_declaration is not supported.");
}
// ** VERILOG_AMS **
| paramset_declaration
{
    yyerror("VERILOG-AMS IS NOT YET SUPPORTED: paramset_declaration");
}
| nature_declaration
{
    yyerror("VERILOG-AMS IS NOT YET SUPPORTED: nature_declaration");
}
| discipline_declaration
{
    yydebug("description: discipline_declaration");
}
| connectrules_declaration
{
    yydebug("description: connectrules_declaration");
    // ignored
};

module_declaration:
module_declaration_start module_parameter_port_list_opt K_SEMICOLON non_port_module_item_list K_endmodule
{
    yydebug("module_declaration: module_declaration_start module_parameter_port_list_opt"
            " K_SEMICOLON module_item_list K_endmodule.");
    RULE_BREAK_MACRO
    parserInstance->parse_ModuleDeclaration( $1, $2, $4 );
}
| module_declaration_start module_parameter_port_list_opt list_of_port_declarations_or_null K_SEMICOLON module_item_list K_endmodule
{
    yydebug("module_declaration: module_declaration_start module_parameter_port_list_opt "
            "list_of_port_declarations_or_null K_SEMICOLON module_item_list K_endmodule.");
    RULE_BREAK_MACRO
    parserInstance->parse_ModuleDeclaration( $1, $2, $3, false, $5 );
}
| module_declaration_start module_parameter_port_list_opt /*list_of_ports*/ port_reference_list_paren K_SEMICOLON module_item_list K_endmodule
{
    yydebug("module_declaration: module_declaration_start module_parameter_port_list_opt "
            "/*list_of_ports*/ port_reference_list_paren K_SEMICOLON module_item_list K_endmodule.");
    RULE_BREAK_MACRO
    parserInstance->parse_ModuleDeclaration( $1, $2, $3, true, $5 );
};

/*
 *  Production introduced to reduce the code size in the previous rule.
 *  SEE module_declaration
 */
module_declaration_start:
attribute_instance_list K_module /* module_identifier */ IDENTIFIER
{
    yydebug("module_declaration_start: attribute_instance_list K_module /* module_identifier */ IDENTIFIER.");
    RULE_BREAK_MACRO
    parserInstance->setCurrentBlockCodeInfo( $2 );
    $$ = parserInstance->parse_ModuleDeclarationStart( $3 );
}
| attribute_instance_list K_macromodule /* module_identifier */ IDENTIFIER
{
    yydebug("module_declaration_start: attribute_instance_list K_macromodule /* module_identifier */ IDENTIFIER.");
    RULE_BREAK_MACRO
    parserInstance->setCurrentBlockCodeInfo( $2 );
    $$ = parserInstance->parse_ModuleDeclarationStart( $3 );
}
| attribute_instance_list K_connectmodule /* module_identifier */ IDENTIFIER
{
    yydebug("module_declaration_start: attribute_instance_list K_connectmodule /* module_identifier */ IDENTIFIER.");
    RULE_BREAK_MACRO
    parserInstance->setCurrentBlockCodeInfo( $2 );
    $$ = parserInstance->parse_ModuleDeclarationStart( $3 );
};



/* -----------------------------------------------------------------------
 *  MODULE PARAMETERS AND PORTS
 * -----------------------------------------------------------------------
 */

module_parameter_port_list:
K_SHARP K_LPAREN parameter_declaration_list K_RPAREN
{
    yydebug("module_parameter_port_list: K_SHARP K_LPAREN parameter_declaration_list K_RPAREN.");
    RULE_BREAK_MACRO $$ = $3;
};


module_parameter_port_list_opt:
/* empty */
{
    yydebug("module_parameter_port_list_opt: /* empty */");
    RULE_BREAK_MACRO $$ = nullptr;
}
| module_parameter_port_list
{
    yydebug("module_parameter_port_list_opt: module_parameter_port_list.");
    RULE_BREAK_MACRO $$ = $1;
}

parameter_declaration_list:
parameter_declaration
{
    yydebug("parameter_declaration_list: parameter_declaration");
    RULE_BREAK_MACRO
    $$ = blist_scast<Declaration>( $1 );
}
| parameter_declaration_list K_COMMA param_assignment
{
    yydebug("parameter_declaration_list: K_COMMA param_assignment.");
    yyerror("parameter_declaration_list: K_COMMA param_assignment is not supported.");
}
| parameter_declaration_list K_COMMA parameter_declaration
{
    yydebug("parameter_declaration_list: K_COMMA parameter_declaration.");
    RULE_BREAK_MACRO
    $$ = $1;
    $$->merge( *blist_scast<Declaration>($3) );
    delete $3;
}; 



list_of_port_declarations_or_null:
K_LPAREN list_of_port_declarations K_RPAREN
{
    yydebug("list_of_port_declarations_or_null: K_LPAREN list_of_port_declarations K_RPAREN.");
    RULE_BREAK_MACRO $$ = $2;
}
| K_LPAREN K_RPAREN
{
    yydebug("list_of_port_declarations_or_null: K_LPAREN K_RPAREN.");
    RULE_BREAK_MACRO $$ = new BList<Port>();
};


list_of_port_declarations:
port_declaration
{
    yydebug("list_of_port_declarations: port_declaration.");
    RULE_BREAK_MACRO
    $$ = new BList<Port>();
    $$->push_back( $1 );
}
| list_of_port_declarations K_COMMA port_declaration
{
    yydebug("list_of_port_declarations: list_of_port_declarations K_COMMA port_declaration.");
    RULE_BREAK_MACRO
    $$ = $1;
    $$->push_back( $3 );
}
| list_of_port_declarations K_COMMA IDENTIFIER
{
    yydebug("list_of_port_declarations: list_of_port_declarations K_COMMA IDENTIFIER.");
    RULE_BREAK_MACRO
    Port * port_o = hif::copy( $1->back() );
    port_o->setName( $3 );
    $1->push_back( port_o );
    free($3);
};


port_reference_list_paren:
K_LPAREN port_reference_list K_RPAREN
{
    yydebug("port_reference_list_paren: K_LPAREN port_reference_list K_RPAREN.");
    RULE_BREAK_MACRO $$ = $2;
}
// WARNING: this syntax is accepted by vlog
| K_LPAREN port_reference_list K_COMMA K_RPAREN
{
    yydebug("port_reference_list_paren: K_LPAREN port_reference_list K_COMMA K_RPAREN.");
    RULE_BREAK_MACRO $$ = $2;
};

port_reference_list:
port_reference
{    
    yydebug("port_reference_list: port_reference.");
    RULE_BREAK_MACRO
    $$ = new BList<Port>();
    $$->push_back( $1 );
}
| port_reference_list K_COMMA port_reference
{
    yydebug("port_reference_list: port_reference_list K_COMMA port_reference.");
    RULE_BREAK_MACRO
    $$ = $1;
    $$->push_back( $3 );
};

port_reference:
/* port_identifier */ IDENTIFIER
{    
    yydebug("port_reference: /* port_identifier */ IDENTIFIER.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_PortReference( $1 );
}
| /* port_identifier */ IDENTIFIER K_LBRACKET /*constant_range_expression*/ range_expression K_RBRACKET
{    
    yydebug("port_reference: /* port_identifier */ IDENTIFIER K_LBRACKET /*constant_range_expression*/ range_expression K_RBRACKET.");
    yyerror("port_reference: /* port_identifier */ IDENTIFIER K_LBRACKET /*constant_range_expression*/ range_expression K_RBRACKET is not supported.");
    //RULE_BREAK_MACRO $$ = parserInstance->parse_PortReference( $1, $2 );
};

port_declaration:
attribute_instance_list inout_declaration
{
    yydebug("port_declaration: attribute_instance_list inout_declaration.");
    RULE_BREAK_MACRO $$ = $2;
}
| attribute_instance_list input_declaration
{
    yydebug("port_declaration: attribute_instance_list input_declaration.");
    RULE_BREAK_MACRO $$ = $2;
}
| attribute_instance_list output_declaration
{
    yydebug("port_declaration: attribute_instance_list output_declaration.");
    RULE_BREAK_MACRO $$ = $2;
};


port_declaration_identifiers:
attribute_instance_list inout_declaration_identifiers
{
    yydebug("port_declaration_identifiers: attribute_instance_list inout_declaration_identifiers.");
    RULE_BREAK_MACRO $$ = $2;
}
| attribute_instance_list input_declaration_identifiers
{
    yydebug("port_declaration_identifiers: attribute_instance_list input_declaration_identifiers.");
    RULE_BREAK_MACRO $$ = $2;
}
| attribute_instance_list output_declaration_identifiers
{
    yydebug("port_declaration_identifiers: attribute_instance_list output_declaration_identifiers.");
    RULE_BREAK_MACRO $$ = $2;
};


/* -----------------------------------------------------------------------
 *  MODULE ITEMS
 * -----------------------------------------------------------------------
 */

module_item:
port_declaration_identifiers K_SEMICOLON
{
    yydebug("module_item: port_declaration_identifiers K_SEMICOLON.");
    RULE_BREAK_MACRO
    $$ = new module_item_t();
    $$->port_declaration_identifiers = $1;
}
| non_port_module_item
{
    yydebug("module_item: non_port_module_item.");
    RULE_BREAK_MACRO
    $$ = new module_item_t();
    $$->non_port_module_item = $1;
};

module_item_list:
/* empty */
{
    yydebug("module_item_list: /* empty */.");
    RULE_BREAK_MACRO
    $$ = new std::list<module_item_t*>();
}
| module_item_list module_item
{
    yydebug("module_item_list: module_item_list module_item.");
    RULE_BREAK_MACRO
    $$ = $1;
    $$->push_back( $2 );
};

module_or_generate_item:
attribute_instance_list module_or_generate_item_declaration
{
    yydebug("module_or_generate_item: attribute_instance_list module_or_generate_item_declaration.");
    RULE_BREAK_MACRO
    $$ = new module_or_generate_item_t();
    $$->module_or_generate_item_declaration = $2;
}
| attribute_instance_list local_parameter_declaration K_SEMICOLON
{
    yydebug("module_or_generate_item: attribute_instance_list local_parameter_declaration.");
    RULE_BREAK_MACRO
    $$ = new module_or_generate_item_t();
    $$->local_parameter_declaration = $2;
}
| attribute_instance_list parameter_override
{
    yydebug("module_or_generate_item: attribute_instance_list parameter_override.");
    yyerror("module_or_generate_item: attribute_instance_list parameter_override is not supported.");
}
| attribute_instance_list continuous_assign
{
    yydebug("module_or_generate_item: attribute_instance_list continuous_assign.");
    RULE_BREAK_MACRO
    $$ = new module_or_generate_item_t();
    $$->continuous_assign = $2;
}
| attribute_instance_list gate_instantiation
{
    yydebug("module_or_generate_item: attribute_instance_list gate_instantiation.");
    yyerror("module_or_generate_item: attribute_instance_list gate_instantiation is not supported.");
}
//| attribute_instance_list udp_instantiation
//{
//    yydebug("module_or_generate_item: attribute_instance_list udp_instantiation.");
//    yyerror("module_or_generate_item: attribute_instance_list udp_instantiation is not supported.");
//}
| attribute_instance_list module_instantiation
{
    yydebug("module_or_generate_item: attribute_instance_list module_instantiation.");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_ModuleOrGenerateItem( $2 );
}
| attribute_instance_list initial_construct
{
    yydebug("module_or_generate_item: attribute_instance_list initial_construct.");
    RULE_BREAK_MACRO
    $$ = new module_or_generate_item_t();
    $$->initial_construct = $2;
}
| attribute_instance_list always_construct
{
    yydebug("module_or_generate_item: attribute_instance_list always_construct.");
    RULE_BREAK_MACRO
    $$ = new module_or_generate_item_t();
    $$->always_construct = $2;
}
| attribute_instance_list loop_generate_construct
{
    yydebug("module_or_generate_item: attribute_instance_list loop_generate_construct.");
    RULE_BREAK_MACRO
    $$ = new module_or_generate_item_t();
    $$->module_or_generate_item_declaration = new module_or_generate_item_declaration_t();
    $$->module_or_generate_item_declaration->generate_declaration = $2;
}
| attribute_instance_list conditional_generate_construct
{
    yydebug("module_or_generate_item: attribute_instance_list conditional_generate_construct.");
    RULE_BREAK_MACRO
    $$ = new module_or_generate_item_t();
    $$->module_or_generate_item_declaration = new module_or_generate_item_declaration_t();
    $$->module_or_generate_item_declaration->generate_declaration = $2;
}
// ** VERILOG_AMS **
| attribute_instance_list analog_construct
{
    yydebug("module_or_generate_item: attribute_instance_list analog_construct.");
    RULE_BREAK_MACRO
    $$ = new module_or_generate_item_t();
    $$->analog_construct = $2;
};


module_or_generate_item_declaration:
net_declaration
{
    yydebug("module_or_generate_item_declaration: net_declaration.");
    RULE_BREAK_MACRO
    $$ = new module_or_generate_item_declaration_t();
    $$->net_declaration = $1;
}
| reg_declaration
{
    yydebug("module_or_generate_item_declaration: reg_declaration.");
    RULE_BREAK_MACRO
    $$ = new module_or_generate_item_declaration_t();
    $$->reg_declaration = $1;
}
| integer_declaration
{
    yydebug("module_or_generate_item_declaration: integer_declaration.");
    RULE_BREAK_MACRO
    $$ = new module_or_generate_item_declaration_t();
    $$->integer_declaration = $1;
}
| real_declaration
{
    yydebug("module_or_generate_item_declaration: real_declaration.");
    RULE_BREAK_MACRO
    $$ = new module_or_generate_item_declaration_t();
    $$->real_declaration = $1;
}
| time_declaration
{
    yydebug("module_or_generate_item_declaration: time_declaration.");
    RULE_BREAK_MACRO
    $$ = new module_or_generate_item_declaration_t();
    $$->time_declaration = $1;
}
| realtime_declaration
{
    yydebug("module_or_generate_item_declaration: realtime_declaration.");
    RULE_BREAK_MACRO
    $$ = new module_or_generate_item_declaration_t();
    $$->time_declaration = $1;
}
| event_declaration
{
    yydebug("module_or_generate_item_declaration: event_declaration.");
    RULE_BREAK_MACRO
    $$ = new module_or_generate_item_declaration_t();
    $$->event_declaration = $1;
}
| genvar_declaration
{
    yydebug("module_or_generate_item_declaration: genvar_declaration.");
    RULE_BREAK_MACRO
    $$ = new module_or_generate_item_declaration_t();
    $$->genvar_declaration = $1;
}
| task_declaration
{
    yydebug("module_or_generate_item_declaration: task_declaration.");
    RULE_BREAK_MACRO
    $$ = new module_or_generate_item_declaration_t();
    $$->task_declaration = $1;
}
| function_declaration
{
    yydebug("module_or_generate_item_declaration: function_declaration.");
    RULE_BREAK_MACRO
    $$ = new module_or_generate_item_declaration_t();
    $$->function_declaration = $1;
}
// ** VERILOG_AMS **
| branch_declaration
{
    yydebug("module_or_generate_item_declaration: branch_declaration.");
    RULE_BREAK_MACRO
    // TODO: Giulio ref design: vams_dg_va_basic_models_ideal_opamp_verilog2hif
    module_or_generate_item_declaration_t * ret = new module_or_generate_item_declaration_t();
    ret->branch_declaration = $1;
    $$ = ret;
}
| analog_function_declaration
{
    yydebug("module_or_generate_item_declaration: analog_function_declaration");
    RULE_BREAK_MACRO
    $$ = new module_or_generate_item_declaration_t();
    $$->function_declaration = $1;
};


non_port_module_item:
module_or_generate_item
{
    yydebug("non_port_module_item: module_or_generate_item.");
    RULE_BREAK_MACRO
    $$ = new non_port_module_item_t();
    $$->module_or_generate_item = $1;
}
| generate_region
{
    yydebug("non_port_module_item: generate_region.");
    RULE_BREAK_MACRO
    messageAssert($1->size() == 1, "Unexpected number of generates inside region", nullptr, nullptr);
    $$ = new non_port_module_item_t();
    $$->module_or_generate_item = $1->front();
    delete $1;
}
| specify_block
{
    yydebug("non_port_module_item: specify_block.");
    RULE_BREAK_MACRO
    $$ = new non_port_module_item_t();
    $$->specify_block = $1;
}
| attribute_instance_list parameter_declaration_identifiers K_SEMICOLON
{
    yydebug("non_port_module_item: attribute_instance_list parameter_declaration_identifiers K_SEMICOLON.");
    RULE_BREAK_MACRO
    $$ = new non_port_module_item_t();
    $$->parameter_declaration = $2;
}
| attribute_instance_list specparam_declaration
{
    yydebug("non_port_module_item: attribute_instance_list specparam_declaration.");
    yyerror("non_port_module_item: attribute_instance_list specparam_declaration is not supported.");
}
// ** VERILOG_AMS **
| aliasparam_declaration
{
    yydebug("non_port_module_item: aliasparam_declaration");
    yyerror("non_port_module_item: aliasparam_declaration is not supported.");
};


non_port_module_item_list:
/* empty */
{
    yydebug("non_port_module_item_list: /* empty */");
    RULE_BREAK_MACRO $$ = new std::list<non_port_module_item_t*>();
}
| non_port_module_item_list non_port_module_item
{
    yydebug("non_port_module_item_list: non_port_module_item_list non_port_module_item.");
    RULE_BREAK_MACRO
    $$ = $1;
    $$->push_back( $2 );
};


parameter_override:
K_defparam list_of_defparam_assignments K_SEMICOLON
{
    yydebug("parameter_override: list_of_defparam_assignments.");
    yyerror("parameter_override: list_of_defparam_assignments is not supported.");
};


/* -----------------------------------------------------------------------
 *  CONFIGURATION SOURCE TEXT
 * -----------------------------------------------------------------------
 */

config_declaration:
K_config /* config_identifier */ IDENTIFIER K_SEMICOLON design_statement config_rule_statement_list K_endconfig
{
    yydebug("config_declaration: K_config /* config_identifier */ IDENTIFIER K_SEMICOLON "
            "design_statement config_rule_statement_list K_endconfig.");
    yyerror("config_declaration: K_config /* config_identifier */ IDENTIFIER K_SEMICOLON "
            "design_statement config_rule_statement_list K_endconfig is not supported.");
};

config_rule_statement_list:
/* empty */
{
    yydebug("config_rule_statement_list: /* empty */");
    yyerror("config_rule_statement_list: /* empty */ is not supported.");
}
| config_rule_statement_list config_rule_statement
{
    yydebug("config_rule_statement_list: config_rule_statement_list config_rule_statement.");
    yyerror("config_rule_statement_list: config_rule_statement_list config_rule_statement is not supported.");
};

design_statement:
K_design cell_identifier_list
{
    yydebug("design_statement: K_design cell_identifier_list.");
    yyerror("design_statement: K_design cell_identifier_list is not supported.");
};

cell_identifier_list:
/* empty */
{
    yydebug("cell_identifier_list: /* empty */");
    yyerror("cell_identifier_list: /* empty */ is not supported.");
}
| cell_identifier_list /* cell_identifier */ IDENTIFIER
{
    yydebug("cell_identifier_list: cell_identifier_list /* cell_identifier */ IDENTIFIER.");
    yyerror("cell_identifier_list: cell_identifier_list /* cell_identifier */ IDENTIFIER is not supported.");
}
| cell_identifier_list /* library_identifier */ IDENTIFIER K_DOT /* cell_identifier */ IDENTIFIER
{
    yydebug("cell_identifier_list: cell_identifier_list /* library_identifier */ IDENTIFIER "
            "K_DOT /* cell_identifier */ IDENTIFIER.");
    yyerror("cell_identifier_list: cell_identifier_list /* library_identifier */ IDENTIFIER "
            "K_DOT /* cell_identifier */ IDENTIFIER is not supported.");
};


config_rule_statement:
K_default liblist_clause K_SEMICOLON
{
    yydebug("config_rule_statement: K_default liblist_clause K_SEMICOLON.");
    yyerror("config_rule_statement: K_default liblist_clause K_SEMICOLON is not supported.");
}
| inst_clause liblist_clause K_SEMICOLON
{
    yydebug("config_rule_statement: inst_clause liblist_clause K_SEMICOLON.");
    yyerror("config_rule_statement: inst_clause liblist_clause K_SEMICOLON is not supported.");
}
| inst_clause use_clause K_SEMICOLON
{
    yydebug("config_rule_statement: inst_clause use_clause K_SEMICOLON.");
    yyerror("config_rule_statement: inst_clause use_clause K_SEMICOLON is not supported.");
}
| cell_clause liblist_clause K_SEMICOLON
{
    yydebug("config_rule_statement: cell_clause liblist_clause K_SEMICOLON.");
    yyerror("config_rule_statement: cell_clause liblist_clause K_SEMICOLON is not supported.");
}
| cell_clause use_clause K_SEMICOLON
{
    yydebug("config_rule_statement: cell_clause use_clause K_SEMICOLON.");
    yyerror("config_rule_statement: cell_clause use_clause K_SEMICOLON is not supported.");
};


inst_clause:
K_instance inst_name
{
    yydebug("inst_clause: K_instance inst_name.");
    yyerror("inst_clause: K_instance inst_name is not supported.");
};

inst_name:
/* topmodule_identifier */ IDENTIFIER identifier_list
{
    yydebug("inst_name: /* topmodule_identifier */ IDENTIFIER identifier_list.");
    yyerror("inst_name: /* topmodule_identifier */ IDENTIFIER identifier_list is not supported.");
};

identifier_list:
/* empty */
{
    yydebug("identifier_list: /* empty */");
    yyerror("identifier_list: /* empty */ is not supported.");
}
| identifier_list K_DOT /* instance_identifier */ IDENTIFIER
{
    yydebug("identifier_list: identifier_list K_DOT /* instance_identifier */ IDENTIFIER.");
    yyerror("identifier_list: identifier_list K_DOT /* instance_identifier */ IDENTIFIER is not supported.");
};


cell_clause:
K_cell IDENTIFIER %prec LOW
{
    yydebug("cell_clause: K_cell IDENTIFIER.");
    yyerror("cell_clause: K_cell IDENTIFIER is not supported.");
}
| K_cell library_identifier IDENTIFIER %prec HIGH
{
    yydebug("cell_clause: K_cell library_identifier IDENTIFIER.");
    yyerror("cell_clause: K_cell library_identifier IDENTIFIER is not supported.");
};


liblist_clause:
K_liblist /* library_identifier list */ identifier_list
{
    yydebug("liblist_clause: K_liblist /* library_identifier list */ identifier_list.");
    yyerror("liblist_clause: K_liblist /* library_identifier list */ identifier_list is not supported.");
};


use_clause:
K_use K_config_opt
{
    yydebug("use_clause: K_use K_config_opt");
    yyerror("use_clause: K_use K_config_opt is not supported.");  
}
| K_use library_identifier K_config_opt
{
    yydebug("use_clause: K_use library_identifier K_config_opt.");
    yyerror("use_clause: K_use library_identifier K_config_opt is not supported.");
};

library_identifier:
/* cell_identifier */ IDENTIFIER
{
    yydebug("library_identifier_opt: /* cell_identifier */ IDENTIFIER");
    yyerror("library_identifier_opt: /* cell_identifier */ IDENTIFIER is not supported.");
}
| /* library_identifier */ IDENTIFIER K_DOT /* cell_identifier */ IDENTIFIER
{
    yydebug("library_identifier_opt: /* library_identifier */ IDENTIFIER K_DOT /* cell_identifier */ IDENTIFIER.");
    yyerror("library_identifier_opt: /* library_identifier */ IDENTIFIER K_DOT /* cell_identifier */ IDENTIFIER is not supported.");
};


K_config_opt:
/* empty */
{
    yydebug("K_config_opt: /* empty */");
    yyerror("K_config_opt: /* empty */ is not supported.");
}
| K_COLON K_config
{
    yydebug("K_config_opt: K_COLON K_COLON K_config.");
    yyerror("K_config_opt: K_COLON K_COLON K_config is not supported.");
};


/* -----------------------------------------------------------------------
 *  NATURE DECLARATION ( ** VERILOG_AMS ** )
 * -----------------------------------------------------------------------
 */

nature_declaration:
K_nature /* nature_identifier */ IDENTIFIER semicolon_opt nature_item_list K_endnature
{
    yyerror("VERILOG-AMS IS NOT YET SUPPORTED: K_nature /* nature_identifier */ IDENTIFIER semicolon_opt nature_item_list K_endnature");
}
| K_nature /* nature_identifier */ IDENTIFIER K_COLON parent_nature semicolon_opt nature_item_list K_endnature
{
    yyerror("VERILOG-AMS IS NOT YET SUPPORTED: K_nature /* nature_identifier */ IDENTIFIER K_COLON parent_nature semicolon_opt nature_item_list K_endnature");
};

semicolon_opt:
/* empty */
{
    yydebug("semicolon_opt: /* empty */");
}
| K_SEMICOLON
{
    yydebug("semicolon_opt");
};

parent_nature:
/* nature_identifier */ IDENTIFIER %prec LOW
{
    yyerror("VERILOG-AMS IS NOT YET SUPPORTED: /* nature_identifier */ IDENTIFIER %prec LOW");
}
| /* discipline_identifier */ IDENTIFIER K_DOT K_potential %prec MEDIUM1
{
    yyerror("VERILOG-AMS IS NOT YET SUPPORTED: /* discipline_identifier */ IDENTIFIER K_DOT K_potential %prec MEDIUM1");
}
| /* discipline_identifier */ IDENTIFIER K_DOT K_flow %prec MEDIUM2
{
    yyerror("VERILOG-AMS IS NOT YET SUPPORTED: /* discipline_identifier */ IDENTIFIER K_DOT K_flow %prec MEDIUM2");
};

nature_item:
nature_attribute
{
    yyerror("VERILOG-AMS IS NOT YET SUPPORTED: nature_attribute");
};

nature_item_list:
/* empty */
{
    yydebug("nature_item_list: /* empty */");
    yyerror("nature_item_list: /* empty */ is not supported");
}
| nature_item_list nature_item
{
    yydebug("nature_item_list: nature_item_list nature_item");
    yyerror("nature_item_list: nature_item_list nature_item is not supported");
};

nature_attribute:
nature_attribute_identifier K_EQ /* nature_attribute_expression */ /* constant_expression */ expression K_SEMICOLON
{
    yydebug("nature_attribute: nature_attribute_identifier K_EQ /* nature_attribute_expression */ /* constant_expression */ expression K_SEMICOLON");
    yyerror("nature_attribute: nature_attribute_identifier K_EQ /* nature_attribute_expression */ /* constant_expression */ expression K_SEMICOLON is not supported");
};



/* -----------------------------------------------------------------------
 *  DISCIPLINE DECLARATION ( ** VERILOG_AMS ** )
 * -----------------------------------------------------------------------
 */

discipline_declaration:
K_discipline /* discipline_identifier */ IDENTIFIER semicolon_opt discipline_item_list K_enddiscipline
{
    yydebug("discipline_declaration: IDENTIFIER semicolon_opt discipline_item_list K_enddiscipline");
    RULE_BREAK_MACRO parserInstance->parse_DisciplineDeclaration( $2, $4 );
};

discipline_item:
nature_binding
{
    yydebug("discipline_item - nature_binding");
    RULE_BREAK_MACRO $$ = $1;
}
| discipline_domain_binding
{
    yyerror("VERILOG-AMS IS NOT YET SUPPORTED: discipline_item - discipline_domain_binding ");
}
| nature_attribute_override
{
    yyerror("VERILOG-AMS IS NOT YET SUPPORTED: discipline_item - nature_attribute_override ");
};

discipline_item_list:
/* empty */
{
    yydebug("discipline_item_list: /* empty */");
    RULE_BREAK_MACRO $$ = new BList<Variable>();
}
| discipline_item_list discipline_item
{
    yydebug("discipline_item_list: discipline_item_list discipline_item");
    RULE_BREAK_MACRO
    $$ = $1;
    $$->push_back( $2 );
};

nature_binding:
K_potential /* nature_identifier */ IDENTIFIER K_SEMICOLON
{
    yydebug("K_potential /* nature_identifier */ IDENTIFIER K_SEMICOLON");
    RULE_BREAK_MACRO $$ = parserInstance->parse_NatureBinding( $2, true );
}
| K_flow /* nature_identifier */ IDENTIFIER K_SEMICOLON
{
    yydebug("K_flow /* nature_identifier */ IDENTIFIER K_SEMICOLON");
    RULE_BREAK_MACRO $$ = parserInstance->parse_NatureBinding( $2, false );
};

discipline_domain_binding:
K_domain K_discrete
{    yyerror("VERILOG-AMS IS NOT YET SUPPORTED: K_domain K_discrete");     }
| K_domain K_continuous
{    yyerror("VERILOG-AMS IS NOT YET SUPPORTED: K_domain K_continuous");     };

nature_attribute_override:
K_potential K_DOT nature_attribute
{
    yyerror("VERILOG-AMS IS NOT YET SUPPORTED: K_potential K_DOT nature_attribute");
}
| K_flow K_DOT nature_attribute
{
    yyerror("VERILOG-AMS IS NOT YET SUPPORTED: K_flow K_DOT nature_attribute");
};



/* -----------------------------------------------------------------------
 *  CONNECTRULES DECLARATION ( ** VERILOG_AMS ** )
 * -----------------------------------------------------------------------
 */

connectrules_declaration:
K_connectrules /* connectrules_identifier */ IDENTIFIER K_SEMICOLON connectrules_item_list K_endconnectrules
{
    yydebug("connectrules_declaration: connectrules_declaration");
    RULE_BREAK_MACRO
    Identifier id($2);
    free($2);

    parserInstance->setCodeInfo(&id);
    messageWarning("Connect specification statements are ignored", &id, nullptr);
};

connectrules_item:
connect_insertion
{
    yydebug("connectrules_item: connect_insertion");
    // ignored
}
| connect_resolution
{
    yydebug("connectrules_item: connect_resolution");
    // ignored
};

connectrules_item_list:
/* empty */
{
    yydebug("connectrules_item_list: empty");
    // ignored
}
| connectrules_item_list connectrules_item
{
   yydebug("connectrules_item_list: connectrules_item_list connectrules_item");
   // ignored
};

connect_insertion:
K_connect /* connectmodule_identifier */ IDENTIFIER connect_mode_opt parameter_value_assignment_opt K_SEMICOLON
{
    yydebug("connect_insertion: K_connect /* connectmodule_identifier */ IDENTIFIER connect_mode_opt parameter_value_assignment_opt K_SEMICOLON");
    // ignored
}
| K_connect /* connectmodule_identifier */ IDENTIFIER connect_mode_opt parameter_value_assignment_opt connect_port_overrides K_SEMICOLON
{
    yydebug("connect_insertion: K_connect /* connectmodule_identifier */ IDENTIFIER connect_mode_opt parameter_value_assignment_opt connect_port_overrides K_SEMICOLON");
    // ignored
};

connect_mode:
K_merged
{
    yydebug("connect_mode: K_merged");
    // ignored
}
| K_split
{
    yydebug("connect_mode: K_split");
    // ignored
};

connect_mode_opt:
/* empty */
{
    yydebug("connect_mode_opt: empty");
    // ignored
}
| connect_mode
{
    yydebug("connect_mode_opt: connect_mode");
    // ignored
};

connect_port_overrides:
/* discipline_identifier */ IDENTIFIER K_COMMA /* discipline_identifier */ IDENTIFIER
{
    yydebug("connect_port_overrides: /* discipline_identifier */ IDENTIFIER K_COMMA /* discipline_identifier */ IDENTIFIER");
    // ignored
    free($1);
    free($3);
}
| K_input /* discipline_identifier */ IDENTIFIER K_COMMA K_output /* discipline_identifier */ IDENTIFIER
{
    yydebug("connect_port_overrides: K_input /* discipline_identifier */ IDENTIFIER K_COMMA K_output /* discipline_identifier */ IDENTIFIER");
    // ignored
    free($2);
    free($5);
}
| K_output /* discipline_identifier */ IDENTIFIER K_COMMA K_input /* discipline_identifier */ IDENTIFIER
{
    yydebug("connect_port_overrides: K_output /* discipline_identifier */ IDENTIFIER K_COMMA K_input /* discipline_identifier */ IDENTIFIER");
    // ignored
    free($2);
    free($5);
}
| K_inout /* discipline_identifier */ IDENTIFIER K_COMMA K_inout /* discipline_identifier */ IDENTIFIER
{
    yydebug("connect_port_overrides: K_inout /* discipline_identifier */ IDENTIFIER K_COMMA K_inout /* discipline_identifier */ IDENTIFIER");
    // ignored
    free($2);
    free($5);
};


connect_resolution:
K_connect list_of_identifiers K_resolveto /* discipline_identifier */ IDENTIFIER K_SEMICOLON
{
    yydebug("connect_resolution: K_connect list_of_identifiers K_resolveto /* discipline_identifier */ IDENTIFIER");
    // ignored
}
| K_exclude K_SEMICOLON
{
    yydebug("connect_resolution: K_exclude K_SEMICOLON");
    // ignored
};


/* -----------------------------------------------------------------------
 *  PARAMSET DECLARATION ( ** VERILOG_AMS ** )
 * -----------------------------------------------------------------------
 */

paramset_declaration:
attribute_instance_list K_paramset /* paramset_identifier */ IDENTIFIER /* module_or_paramset_identifier */ IDENTIFIER K_SEMICOLON
paramset_item_declaration_list paramset_statement_list K_endparamset
{    yyerror("VERILOG-AMS IS NOT YET SUPPORTED: paramset_declaration");     };

paramset_item_declaration:
attribute_instance_list parameter_declaration_identifiers K_SEMICOLON
{    yyerror("VERILOG-AMS IS NOT YET SUPPORTED: paramset_item_declaration 1");     }
| attribute_instance_list local_parameter_declaration K_SEMICOLON
{    yyerror("VERILOG-AMS IS NOT YET SUPPORTED: paramset_item_declaration 2");     }
| aliasparam_declaration
{    yyerror("VERILOG-AMS IS NOT YET SUPPORTED: paramset_item_declaration 3");     }
| attribute_instance_list integer_declaration
{    yyerror("VERILOG-AMS IS NOT YET SUPPORTED: paramset_item_declaration 4");     }
| attribute_instance_list real_declaration
{    yyerror("VERILOG-AMS IS NOT YET SUPPORTED: paramset_item_declaration 5");     };


paramset_item_declaration_list:
paramset_item_declaration
{    yyerror("VERILOG-AMS IS NOT YET SUPPORTED: paramset_item_declaration_list 1");     }
| paramset_item_declaration_list paramset_item_declaration
{    yyerror("VERILOG-AMS IS NOT YET SUPPORTED: paramset_item_declaration_list 2");     };

paramset_statement:
K_DOT /* module_parameter_identifier */ IDENTIFIER K_EQ /* paramset_constant_expression */ /* constant_expression */ expression K_SEMICOLON
{    yyerror("VERILOG-AMS IS NOT YET SUPPORTED: paramset_statement 1");     }
| K_DOT /* system_parameter_identifier */ SYSTEM_IDENTIFIER K_EQ /* paramset_constant_expression */ /* constant_expression */ expression K_SEMICOLON
{    yyerror("VERILOG-AMS IS NOT YET SUPPORTED: paramset_statement 2");     }
| analog_function_statement
{    yyerror("VERILOG-AMS IS NOT YET SUPPORTED: paramset_statement 3");     };

paramset_statement_list:
paramset_statement
{    yyerror("VERILOG-AMS IS NOT YET SUPPORTED: paramset_statement_list 1");     }
| paramset_statement_list paramset_statement
{    yyerror("VERILOG-AMS IS NOT YET SUPPORTED: paramset_statement_list 2");     };


/* -----------------------------------------------------------------------
 *  MODULE PARAMETER DECLARATIONS
 * -----------------------------------------------------------------------
 */

local_parameter_declaration:
K_localparam K_signed_opt range_opt list_of_param_assignments
{
    yydebug("local_parameter_declaration: K_localparam K_signed_opt range_opt list_of_param_assignments.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_LocalParameterDeclaration( $2, $3, $4, nullptr );
}
| K_localparam parameter_type list_of_param_assignments
{
    yydebug("local_parameter_declaration: K_localparam parameter_type list_of_param_assignments.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_LocalParameterDeclaration(false, nullptr, $3, $2 );
};


parameter_declaration:
K_parameter K_signed_opt range_opt param_assignment
{
    yydebug("parameter_declaration: parameter K_signed_opt range_opt list_of_param_assignments.");
    RULE_BREAK_MACRO
    BList<Assign> * paramAssignList = new BList<Assign>();
    paramAssignList->push_back( $4 );
    $$ = parserInstance->parse_ParameterDeclaration( $2, $3, paramAssignList, nullptr );
}
| K_parameter parameter_type param_assignment
{
    yydebug("parameter_declaration: K_parameter parameter_type list_of_param_assignments.");
    RULE_BREAK_MACRO
    BList<Assign> * paramAssignList = new BList<Assign>();
    paramAssignList->push_back( $3 );
    $$ = parserInstance->parse_ParameterDeclaration(false, nullptr, paramAssignList, $2 );
};


parameter_declaration_identifiers:
K_parameter K_signed_opt range_opt list_of_param_assignments
{
    yydebug("parameter_declaration_identifiers: parameter K_signed_opt range_opt list_of_param_assignments.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ParameterDeclaration( $2, $3, $4, nullptr );
}
| K_parameter parameter_type list_of_param_assignments
{
    yydebug("parameter_declaration_identifiers: K_parameter parameter_type list_of_param_assignments.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ParameterDeclaration(false, nullptr, $3, $2 );
};


specparam_declaration:
K_specparam range_opt list_of_specparam_assignments K_SEMICOLON
{
    yydebug("specparam_declaration: K_specparam range_opt list_of_specparam_assignments K_SEMICOLON.");
    yyerror("specparam_declaration: K_specparam range_opt list_of_specparam_assignments K_SEMICOLON is not supported.");
};


parameter_type:
K_integer
{
    yydebug("parameter_type: K_integer.");
    // e.g. design: verilog/vams_std_bedm/ideal_switch : 19 
    RULE_BREAK_MACRO
    $$ = makeVerilogIntegerType();
}
| K_real
{
    yydebug("parameter_type: K_real.");
    RULE_BREAK_MACRO
    Range* span = new Range(63, 0);
    Real* ret = new Real();
    ret->setSpan(span);
    $$ = ret;
}
| K_realtime
{
    yydebug("parameter_type: K_realtime.");
    yyerror("parameter_type: K_realtime is not supported.");
}
| K_time
{
    yydebug("parameter_type: K_time.");
    RULE_BREAK_MACRO
    $$ = new hif::Time();
}
| K_string
{
    yydebug("parameter_type: K_string.");
    RULE_BREAK_MACRO
    $$ = new hif::String();
};

// ** VERILOG_AMS **
aliasparam_declaration:
K_aliasparam /* parameter_identifier */ IDENTIFIER K_EQ /* parameter_identifier */ IDENTIFIER K_SEMICOLON
{
    yydebug("aliasparam_declaration: K_aliasparam IDENTIFIER K_EQ IDENTIFIER K_SEMICOLON");
    yyerror("aliasparam_declaration: K_aliasparam IDENTIFIER K_EQ IDENTIFIER K_SEMICOLON is not supported");
};



/* -----------------------------------------------------------------------
 *  PORT_DECLARATIONS
 * -----------------------------------------------------------------------
 */

discipline_and_modifiers:
// ** VERILOG_AMS ** -->
IDENTIFIER
{
    yydebug("discipline_and_modifiers: IDENTIFIER");
    yyerror("discipline_and_modifiers: IDENTIFIER is not supported");
    RULE_BREAK_MACRO
    $$ = new discipline_and_modifiers_t();
    $$->discipline_identifier = parserInstance->parse_Identifier( $1 );
}
| IDENTIFIER net_type
{
    yydebug("discipline_and_modifiers: IDENTIFIER net_type");
    yyerror("discipline_and_modifiers: IDENTIFIER net_type is not supported");
    RULE_BREAK_MACRO
    $$ = new discipline_and_modifiers_t();
    $$->discipline_identifier = parserInstance->parse_Identifier( $1 );
    $$->net_type = $2;
}
| IDENTIFIER net_type K_signed
{
    yydebug("discipline_and_modifiers: IDENTIFIER net_type K_signed");
    yyerror("discipline_and_modifiers: IDENTIFIER net_type K_signed is not supported");
    RULE_BREAK_MACRO
    $$ = new discipline_and_modifiers_t();
    $$->discipline_identifier = parserInstance->parse_Identifier( $1 );
    $$->net_type = $2;
    $$->k_signed = true;
}
| IDENTIFIER net_type range
{
    yydebug("discipline_and_modifiers: IDENTIFIER net_type range");
    yyerror("discipline_and_modifiers: IDENTIFIER net_type range is not supported");
    RULE_BREAK_MACRO
    $$ = new discipline_and_modifiers_t();
    $$->discipline_identifier = parserInstance->parse_Identifier( $1 );
    $$->net_type = $2;
    $$->range = $3;
}
| IDENTIFIER net_type K_signed range
{
    yydebug("discipline_and_modifiers: IDENTIFIER net_type K_signed range");
    yyerror("discipline_and_modifiers: IDENTIFIER net_type K_signed range is not supported");
    RULE_BREAK_MACRO
    $$ = new discipline_and_modifiers_t();
    $$->discipline_identifier = parserInstance->parse_Identifier( $1 );
    $$->net_type = $2;
    $$->k_signed = true;
    $$->range = $4;
}
| IDENTIFIER K_wreal
{
    yydebug("discipline_and_modifiers: IDENTIFIER K_wreal");
    yyerror("discipline_and_modifiers: IDENTIFIER K_wreal is not supported");
    RULE_BREAK_MACRO
    $$ = new discipline_and_modifiers_t();
    $$->discipline_identifier = parserInstance->parse_Identifier( $1 );
    $$->k_wreal = true;
}
| IDENTIFIER K_wreal K_signed
{
    yydebug("discipline_and_modifiers: IDENTIFIER K_wreal K_signed");
    yyerror("discipline_and_modifiers: IDENTIFIER K_wreal K_signed is not supported");
    RULE_BREAK_MACRO
    $$ = new discipline_and_modifiers_t();
    $$->discipline_identifier = parserInstance->parse_Identifier( $1 );
    $$->k_wreal = true;
    $$->k_signed = true;
}
| IDENTIFIER K_wreal range
{
    yydebug("discipline_and_modifiers: IDENTIFIER K_wreal range");
    yyerror("discipline_and_modifiers: IDENTIFIER K_wreal range is not supported");
    RULE_BREAK_MACRO
    $$ = new discipline_and_modifiers_t();
    $$->discipline_identifier = parserInstance->parse_Identifier( $1 );
    $$->k_wreal = true;
    $$->range = $3;
}
| IDENTIFIER K_wreal K_signed range
{
    yydebug("discipline_and_modifiers: IDENTIFIER K_wreal K_signed range");
    yyerror("discipline_and_modifiers: IDENTIFIER K_wreal K_signed range is not supported");
    RULE_BREAK_MACRO
    $$ = new discipline_and_modifiers_t();
    $$->discipline_identifier = parserInstance->parse_Identifier( $1 );
    $$->k_wreal = true;
    $$->k_signed = true;
    $$->range = $4;
}
| IDENTIFIER K_signed
{
    yydebug("discipline_and_modifiers: IDENTIFIER K_signed");
    yyerror("discipline_and_modifiers: IDENTIFIER K_signed is not supported");
    RULE_BREAK_MACRO
    $$ = new discipline_and_modifiers_t();
    $$->discipline_identifier = parserInstance->parse_Identifier( $1 );
    $$->k_signed = true;
}
| IDENTIFIER K_signed range
{
    yydebug("discipline_and_modifiers: IDENTIFIER K_signed range");
    yyerror("discipline_and_modifiers: IDENTIFIER K_signed range is not supported");
    RULE_BREAK_MACRO
    $$ = new discipline_and_modifiers_t();
    $$->discipline_identifier = parserInstance->parse_Identifier( $1 );
    $$->k_signed = true;
    $$->range = $3;
}
| IDENTIFIER range
{
    yydebug("discipline_and_modifiers: IDENTIFIER range");
    yyerror("discipline_and_modifiers: IDENTIFIER range is not supported");
    RULE_BREAK_MACRO
    $$ = new discipline_and_modifiers_t();
    $$->discipline_identifier = parserInstance->parse_Identifier( $1 );
    $$->range = $2;
}
| net_type
{
    yydebug("discipline_and_modifiers: net_type");
    RULE_BREAK_MACRO
    $$ = new discipline_and_modifiers_t();
    $$->net_type = $1;
}
| net_type K_signed
{
    yydebug("discipline_and_modifiers: net_type K_signed");
    RULE_BREAK_MACRO
    $$ = new discipline_and_modifiers_t();
    $$->net_type = $1;
    $$->k_signed = true;
}
| net_type range
{
    yydebug("discipline_and_modifiers: net_type range");
    RULE_BREAK_MACRO
    $$ = new discipline_and_modifiers_t();
    $$->net_type = $1;
    $$->range = $2;
}
| net_type K_signed range
{
    yydebug("discipline_and_modifiers: net_type K_signed range");
    RULE_BREAK_MACRO
    $$ = new discipline_and_modifiers_t();
    $$->net_type = $1;
    $$->k_signed = true;
    $$->range = $3;
}
| K_signed
{
    yydebug("discipline_and_modifiers: K_signed");
    RULE_BREAK_MACRO
    $$ = new discipline_and_modifiers_t();
    $$->k_signed = true;
}
| K_signed range
{
    yydebug("discipline_and_modifiers: K_signed range");
    RULE_BREAK_MACRO
    $$ = new discipline_and_modifiers_t();
    $$->range = $2;
    $$->k_signed = true;
}
| range
{
    yydebug("discipline_and_modifiers: range");
    RULE_BREAK_MACRO
    $$ = new discipline_and_modifiers_t();
    $$->range = $1;
};


inout_declaration:
K_inout /* list_of_port_identifiers */ IDENTIFIER
{
    yydebug("inout_declaration: K_inout /* list_of_port_identifiers */ IDENTIFIER.");
    RULE_BREAK_MACRO 
    $$ = parserInstance->parse_InoutDeclaration(
            new discipline_and_modifiers_t(), 
            parserInstance->parse_Identifier( $2 ) );
}
| K_inout discipline_and_modifiers /* list_of_port_identifiers */ IDENTIFIER
{
    yydebug("inout_declaration: K_inout discipline_and_modifiers /* list_of_port_identifiers */ IDENTIFIER.");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_InoutDeclaration( $2, parserInstance->parse_Identifier( $3 ) );
}
| K_inout /* list_of_port_identifiers */ attribute_instance_list_no_empty IDENTIFIER
{
    yydebug("inout_declaration: K_inout /* list_of_port_identifiers */ attribute_instance_list_no_empty IDENTIFIER.");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_InoutDeclaration(
            new discipline_and_modifiers_t(),
            parserInstance->parse_Identifier( $3 ) );
}
| K_inout discipline_and_modifiers /* list_of_port_identifiers */ attribute_instance_list_no_empty IDENTIFIER
{
    yydebug("inout_declaration: K_inout discipline_and_modifiers /* list_of_port_identifiers */ attribute_instance_list_no_empty IDENTIFIER.");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_InoutDeclaration( $2, parserInstance->parse_Identifier( $4 ) );
};


inout_declaration_identifiers:
K_inout /* list_of_port_identifiers */ list_of_identifiers
{
    yydebug("inout_declaration_identifiers: K_inout /* list_of_port_identifiers */ list_of_identifiers.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_InoutDeclaration( new discipline_and_modifiers_t(), $2 );
}
| K_inout discipline_and_modifiers /* list_of_port_identifiers */ list_of_identifiers
{
    yydebug("inout_declaration_identifiers: K_inout discipline_and_modifiers /* list_of_port_identifiers */ list_of_identifiers.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_InoutDeclaration( $2, $3 );
}
| K_inout /* list_of_port_identifiers */ attribute_instance_list_no_empty list_of_identifiers
{
    yydebug("inout_declaration_identifiers: K_inout /* list_of_port_identifiers */ list_of_identifiers.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_InoutDeclaration( new discipline_and_modifiers_t(), $3 );
}
| K_inout discipline_and_modifiers /* list_of_port_identifiers */ attribute_instance_list_no_empty list_of_identifiers
{
    yydebug("inout_declaration_identifiers: K_inout discipline_and_modifiers /* list_of_port_identifiers */ list_of_identifiers.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_InoutDeclaration( $2, $4 );
};



input_declaration:
K_input /* list_of_port_identifiers */ attribute_instance_list_no_empty IDENTIFIER
{
    yydebug("input_declaration: K_input /* list_of_port_identifiers */ attribute_instance_list_no_empty IDENTIFIER.");
    RULE_BREAK_MACRO 
    $$ = parserInstance->parse_InputDeclaration(
            new discipline_and_modifiers_t(), 
            new Identifier($3) );
    free($3);
}
| K_input discipline_and_modifiers /* list_of_port_identifiers */ attribute_instance_list_no_empty IDENTIFIER
{
    yydebug("input_declaration: K_input discipline_and_modifiers /* attribute_instance_list_no_empty list_of_port_identifiers */ IDENTIFIER.");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_InputDeclaration( $2, new Identifier($4) );
    free($4);
}
| K_input /* list_of_port_identifiers */ IDENTIFIER
{
    yydebug("input_declaration: K_input /* list_of_port_identifiers */  IDENTIFIER.");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_InputDeclaration(
            new discipline_and_modifiers_t(),
            new Identifier($2) );
    free($2);
}
| K_input discipline_and_modifiers /* list_of_port_identifiers */  IDENTIFIER
{
    yydebug("input_declaration: K_input discipline_and_modifiers /*  list_of_port_identifiers */ IDENTIFIER.");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_InputDeclaration( $2, new Identifier($3) );
    free($3);
};


input_declaration_identifiers:
K_input /* list_of_port_identifiers */ list_of_identifiers
{
    yydebug("input_declaration_identifiers: K_input /* list_of_port_identifiers */ list_of_identifiers.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_InputDeclaration( new discipline_and_modifiers_t(), $2 );
}
| K_input /* list_of_port_identifiers */ attribute_instance_list_no_empty list_of_identifiers
{
    yydebug("input_declaration_identifiers: K_input /* list_of_port_identifiers */ attribute_instance_list_no_empty list_of_identifiers.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_InputDeclaration( new discipline_and_modifiers_t(), $3 );
}
| K_input discipline_and_modifiers /* list_of_port_identifiers */ list_of_identifiers
{
    yydebug("input_declaration_identifiers: K_input discipline_and_modifiers /* list_of_port_identifiers */ list_of_identifiers.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_InputDeclaration( $2, $3 );
}
| K_input discipline_and_modifiers /* list_of_port_identifiers */ attribute_instance_list_no_empty list_of_identifiers
{
    yydebug("input_declaration_identifiers: K_input discipline_and_modifiers /* list_of_port_identifiers */ attribute_instance_list_no_empty list_of_identifiers.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_InputDeclaration( $2, $4 );
};


output_declaration:
K_output /* list_of_port_identifiers */ IDENTIFIER
{
    yydebug("output_declaration: K_output IDENTIFIER.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_OutputDeclaration(
            new discipline_and_modifiers_t(), 
            new Identifier($2) );
    free($2);
}
| K_output discipline_and_modifiers /* list_of_port_identifiers */ IDENTIFIER
{
    yydebug("output_declaration: K_output discipline_and_modifiers IDENTIFIER.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_OutputDeclaration( $2, new Identifier($3) );
    free($3);
}
| K_output K_reg K_signed_opt range_opt IDENTIFIER eq_constant_expression_opt
{
    yydebug("output_declaration: K_output K_reg K_signed_opt range_opt "
            "IDENTIFIER eq_constant_expression_opt.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_OutputDeclaration( $3, $4, $5, $6, true );
}
| K_output output_variable_type IDENTIFIER eq_constant_expression_opt
{
    yydebug("output_declaration: K_output output_variable_type IDENTIFIER eq_constant_expression_opt.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_OutputDeclaration( $2, $3, $4 );
}
// ** VERILOG_AMS **
| K_output /* discipline_identifier */ IDENTIFIER K_reg K_signed_opt range_opt IDENTIFIER eq_constant_expression_opt
{
    yydebug("output_declaration: K_output /* discipline_identifier */ IDENTIFIER K_reg K_signed_opt "
            "range_opt IDENTIFIER eq_constant_expression_opt");
    yyerror("output_declaration: K_output /* discipline_identifier */ IDENTIFIER K_reg K_signed_opt "
            "range_opt IDENTIFIER eq_constant_expression_opt is not supported");
}
// duplicate for attributes
| K_output /* list_of_port_identifiers */ attribute_instance_list_no_empty IDENTIFIER
{
    yydebug("output_declaration: K_output attribute_instance_list_no_empty IDENTIFIER.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_OutputDeclaration(
            new discipline_and_modifiers_t(),
            new Identifier($3) );
    free($3);
}
| K_output discipline_and_modifiers /* list_of_port_identifiers */ attribute_instance_list_no_empty IDENTIFIER
{
    yydebug("output_declaration: K_output discipline_and_modifiers attribute_instance_list_no_empty IDENTIFIER.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_OutputDeclaration( $2, new Identifier($4) );
    free($4);
}
| K_output K_reg K_signed_opt range_opt attribute_instance_list_no_empty IDENTIFIER eq_constant_expression_opt
{
    yydebug("output_declaration: K_output K_reg K_signed_opt range_opt "
            "attribute_instance_list_no_empty IDENTIFIER eq_constant_expression_opt.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_OutputDeclaration( $3, $4, $6, $7, true );
}
| K_output output_variable_type attribute_instance_list_no_empty IDENTIFIER eq_constant_expression_opt
{
    yydebug("output_declaration: K_output output_variable_type attribute_instance_list_no_empty IDENTIFIER eq_constant_expression_opt.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_OutputDeclaration( $2, $4, $5 );
}
// ** VERILOG_AMS **
| K_output /* discipline_identifier */ attribute_instance_list_no_empty IDENTIFIER K_reg K_signed_opt range_opt IDENTIFIER eq_constant_expression_opt
{
    yydebug("output_declaration: K_output /* discipline_identifier */ attribute_instance_list_no_empty IDENTIFIER K_reg K_signed_opt "
            "range_opt IDENTIFIER eq_constant_expression_opt");
    yyerror("output_declaration: K_output /* discipline_identifier */ attribute_instance_list_no_empty IDENTIFIER K_reg K_signed_opt "
            "range_opt IDENTIFIER eq_constant_expression_opt is not supported");
};

output_declaration_identifiers:
K_output /* list_of_port_identifiers */ list_of_identifiers
{
    yydebug("output_declaration_identifiers: K_output /* list_of_port_identifiers */ list_of_identifiers.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_OutputDeclaration( new discipline_and_modifiers_t(), $2 );
}
| K_output discipline_and_modifiers /* list_of_port_identifiers */ list_of_identifiers
{
    yydebug("output_declaration_identifiers: K_output discipline_and_modifiers /* list_of_port_identifiers */ list_of_identifiers");
    RULE_BREAK_MACRO $$ = parserInstance->parse_OutputDeclaration( $2, $3 );
}
| K_output K_reg K_signed_opt range_opt list_of_variable_port_identifiers
{
    yydebug("output_declaration_identifiers: K_output K_reg K_signed_opt range_opt "
            "list_of_variable_port_identifiers.");
    
    RULE_BREAK_MACRO $$ = parserInstance->parse_OutputDeclaration( $3, $4, $5, true );
    
}
| K_output output_variable_type list_of_variable_port_identifiers
{
    yydebug("output_declaration_identifiers: K_output output_variable_type list_of_variable_port_identifiers.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_OutputDeclaration( $2, $3 );
}
// ** VERILOG_AMS **
| K_output /* discipline_identifier */ IDENTIFIER K_reg K_signed_opt range_opt list_of_variable_port_identifiers
{
    yydebug("output_declaration_identifiers: K_output /* discipline_identifier */ IDENTIFIER K_reg K_signed_opt range_opt list_of_variable_port_identifiers");
    yyerror("output_declaration_identifiers: K_output /* discipline_identifier */ IDENTIFIER K_reg K_signed_opt range_opt list_of_variable_port_identifiers is not supported");
}
// duplicates for attributes
| K_output /* list_of_port_identifiers */ attribute_instance_list_no_empty list_of_identifiers
{
    yydebug("output_declaration_identifiers: K_output /* list_of_port_identifiers */ attribute_instance_list_no_empty list_of_identifiers.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_OutputDeclaration( new discipline_and_modifiers_t(), $3 );
}
| K_output discipline_and_modifiers /* list_of_port_identifiers */ attribute_instance_list_no_empty list_of_identifiers
{
    yydebug("output_declaration_identifiers: K_output discipline_and_modifiers /* attribute_instance_list_no_empty list_of_port_identifiers */ list_of_identifiers");
    RULE_BREAK_MACRO $$ = parserInstance->parse_OutputDeclaration( $2, $4 );
}
| K_output K_reg K_signed_opt range_opt attribute_instance_list_no_empty list_of_variable_port_identifiers
{
    yydebug("output_declaration_identifiers: K_output K_reg K_signed_opt range_opt "
            "attribute_instance_list_no_empty list_of_variable_port_identifiers.");

    RULE_BREAK_MACRO $$ = parserInstance->parse_OutputDeclaration( $3, $4, $6, true );

}
| K_output output_variable_type attribute_instance_list_no_empty list_of_variable_port_identifiers
{
    yydebug("output_declaration_identifiers: K_output output_variable_type list_of_variable_port_identifiers.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_OutputDeclaration( $2, $4 );
}
// ** VERILOG_AMS **
| K_output /* discipline_identifier */ IDENTIFIER K_reg K_signed_opt range_opt attribute_instance_list_no_empty list_of_variable_port_identifiers
{
    yydebug("output_declaration_identifiers: K_output /* discipline_identifier */ IDENTIFIER K_reg K_signed_opt range_opt attribute_instance_list_no_empty list_of_variable_port_identifiers");
    yyerror("output_declaration_identifiers: K_output /* discipline_identifier */ IDENTIFIER K_reg K_signed_opt range_opt attribute_instance_list_no_empty list_of_variable_port_identifiers is not supported");
};


list_of_identifiers:
IDENTIFIER
{
    yydebug("list_of_identifiers: IDENTIFIER");
    RULE_BREAK_MACRO
    $$ = new BList<Identifier>();
    $$->push_back( new Identifier( $1) );
    free($1);
}
| list_of_identifiers K_COMMA IDENTIFIER
{
    yydebug("list_of_identifiers: list_of_identifiers K_COMMA IDENTIFIER");
    RULE_BREAK_MACRO
    $$ = $1;
    $$->push_back( new Identifier( $3) );
    free($3);
};



/* -----------------------------------------------------------------------
 *  TYPE DECLARATIONS
 * -----------------------------------------------------------------------
 */

// ** VERILOG_AMS ** -->
branch_declaration:
K_branch K_LPAREN branch_terminal_list K_RPAREN list_of_identifiers K_SEMICOLON
{
    yydebug("branch_declaration: K_branch K_LPAREN branch_terminal_list K_RPAREN list_of_identifiers K_SEMICOLON");
    RULE_BREAK_MACRO $$ = parserInstance->parse_BranchDeclaration( $3, $5 );
};

branch_terminal:
/* net_identifier */ IDENTIFIER
{
    yydebug("branch_terminal: IDENTIFIER.");
    RULE_BREAK_MACRO 
    $$ = new Identifier($1);
    free($1);
}
// ** sub-case of the next one **
//| /* net_identifier */ IDENTIFIER K_LBRACKET /* constant_expression */ expression K_RBRACKET
| /* net_identifier */ IDENTIFIER K_LBRACKET /*constant_range_expression*/ range_expression K_RBRACKET
{
    yydebug("branch_terminal: IDENTIFIER K_LBRACKET range_expression K_RBRACKET");
    RULE_BREAK_MACRO $$ = parserInstance->parse_BranchTerminal( $1, $3 );
};

branch_terminal_list:
branch_terminal
{
    yydebug("branch_terminal_list: branch_terminal.");
    RULE_BREAK_MACRO
    $$ = new BList<Value>();
    $$->push_back( $1 );
}
| branch_terminal_list K_COMMA branch_terminal
{
    yydebug("branch_terminal_list: branch_terminal_list K_COMMA branch_terminal.");
    RULE_BREAK_MACRO
    $$ = $1;
    $$->push_back( $3 );
};

// <-- ** VERILOG_AMS **

event_declaration:
K_event list_of_event_identifiers K_SEMICOLON
{
    yydebug("event_declaration: K_event list_of_event_identifiers K_SEMICOLON.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_EventDeclaration( $2 );
};


integer_declaration:
K_integer list_of_variable_identifiers K_SEMICOLON
{
    yydebug("integer_declaration: K_integer list_of_variable_identifiers K_SEMICOLON.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_IntegerDeclaration( $2 );
};

net_declaration:
net_type net_ams_decl_identifier_assignment_list K_SEMICOLON
{
    yydebug("net_declaration: net_type net_ams_decl_identifier_assignment_list K_SEMICOLON");
    RULE_BREAK_MACRO $$ = parserInstance->parse_NetDeclaration( false, nullptr, $2 );
}
| net_type drive_strength_opt range net_ams_decl_identifier_assignment_list K_SEMICOLON
{
    yydebug("net_declaration: net_type drive_strength_opt range net_ams_decl_identifier_assignment_list K_SEMICOLON");
    RULE_BREAK_MACRO $$ = parserInstance->parse_NetDeclaration( false, $3, $4 );
}
| net_type drive_strength_opt K_signed net_ams_decl_identifier_assignment_list K_SEMICOLON
{
    yydebug("net_declaration: net_type drive_strength_opt K_signed net_ams_decl_identifier_assignment_list K_SEMICOLON");
    yyerror("net_declaration: net_type drive_strength_opt K_signed net_ams_decl_identifier_assignment_list K_SEMICOLON is not supported");
}
| net_type drive_strength_opt K_signed range net_ams_decl_identifier_assignment_list K_SEMICOLON
{
    yydebug("net_declaration: net_type drive_strength_opt K_signed range net_ams_decl_identifier_assignment_list K_SEMICOLON");
    RULE_BREAK_MACRO $$ = parserInstance->parse_NetDeclaration( true, $4, $5 );
}
| net_type drive_strength_opt delay3 net_ams_decl_identifier_assignment_list K_SEMICOLON
{
    yydebug("net_declaration: net_type drive_strength_opt delay3 net_ams_decl_identifier_assignment_list K_SEMICOLON");
    yyerror("net_declaration: net_type drive_strength_opt delay3 net_ams_decl_identifier_assignment_list K_SEMICOLON is not supported");
}
| net_type drive_strength_opt K_signed delay3 net_ams_decl_identifier_assignment_list K_SEMICOLON
{
    yydebug("net_declaration: net_type drive_strength_opt K_signed delay3 net_ams_decl_identifier_assignment_list K_SEMICOLON");
    yyerror("net_declaration: net_type drive_strength_opt K_signed delay3 net_ams_decl_identifier_assignment_list K_SEMICOLON is not supported");
}
| net_type drive_strength_opt K_signed range delay3 net_ams_decl_identifier_assignment_list K_SEMICOLON
{
    yydebug("net_declaration: net_type drive_strength_opt K_signed range delay3 net_ams_decl_identifier_assignment_list K_SEMICOLON");
    yyerror("net_declaration: net_type drive_strength_opt K_signed range delay3 net_ams_decl_identifier_assignment_list K_SEMICOLON is not supported");
}
| net_type drive_strength_opt vector_scale range net_ams_decl_identifier_assignment_list K_SEMICOLON
{
    yydebug("net_declaration: net_type drive_strength_opt vector_scale range net_ams_decl_identifier_assignment_list K_SEMICOLON");
    yyerror("net_declaration: net_type drive_strength_opt vector_scale range net_ams_decl_identifier_assignment_list K_SEMICOLON is not supported");
}
| net_type drive_strength_opt vector_scale K_signed range net_ams_decl_identifier_assignment_list K_SEMICOLON
{
    yydebug("net_declaration: net_type drive_strength_opt vector_scale K_signed range net_ams_decl_identifier_assignment_list K_SEMICOLON");
    yyerror("net_declaration: net_type drive_strength_opt vector_scale K_signed range net_ams_decl_identifier_assignment_list K_SEMICOLON is not supported");
}
| net_type drive_strength_opt vector_scale K_signed range delay3 net_ams_decl_identifier_assignment_list K_SEMICOLON
{
    yydebug("net_declaration: net_type drive_strength_opt vector_scale K_signed range delay3 net_ams_decl_identifier_assignment_list K_SEMICOLON");
    yyerror("net_declaration: net_type drive_strength_opt vector_scale K_signed range delay3 net_ams_decl_identifier_assignment_list K_SEMICOLON is not supported");
}
| net_type drive_strength_opt vector_scale range delay3 net_ams_decl_identifier_assignment_list K_SEMICOLON
{
    yydebug("net_declaration: net_type drive_strength_opt vector_scale range delay3 net_ams_decl_identifier_assignment_list K_SEMICOLON");
    yyerror("net_declaration: net_type drive_strength_opt vector_scale range delay3 net_ams_decl_identifier_assignment_list K_SEMICOLON is not supported");
}

| K_trireg net_ams_decl_identifier_assignment_list K_SEMICOLON
{
    yydebug("net_declaration: K_trireg net_ams_decl_identifier_assignment_list K_SEMICOLON");
    yyerror("net_declaration: K_trireg net_ams_decl_identifier_assignment_list K_SEMICOLON is not supported");
}
| K_trireg K_signed net_ams_decl_identifier_assignment_list K_SEMICOLON
{
    yydebug("net_declaration: K_trireg K_signed net_ams_decl_identifier_assignment_list K_SEMICOLON");
    yyerror("net_declaration: K_trireg K_signed net_ams_decl_identifier_assignment_list K_SEMICOLON is not supported");
}
| K_trireg delay3 net_ams_decl_identifier_assignment_list K_SEMICOLON
{
    yydebug("net_declaration: K_trireg delay3 net_ams_decl_identifier_assignment_list K_SEMICOLON");
    yyerror("net_declaration: K_trireg delay3 net_ams_decl_identifier_assignment_list K_SEMICOLON is not supported");
}
| K_trireg K_signed delay3 net_ams_decl_identifier_assignment_list K_SEMICOLON
{
    yydebug("net_declaration: K_trireg K_signed delay3 net_ams_decl_identifier_assignment_list K_SEMICOLON");
    yyerror("net_declaration: K_trireg K_signed delay3 net_ams_decl_identifier_assignment_list K_SEMICOLON is not supported");
}
| K_trireg range net_ams_decl_identifier_assignment_list K_SEMICOLON
{
    yydebug("net_declaration: K_trireg range net_ams_decl_identifier_assignment_list K_SEMICOLON");
    yyerror("net_declaration: K_trireg range net_ams_decl_identifier_assignment_list K_SEMICOLON is not supported");
}
| K_trireg vector_scale range net_ams_decl_identifier_assignment_list K_SEMICOLON
{
    yydebug("net_declaration: K_trireg vector_scale range net_ams_decl_identifier_assignment_list K_SEMICOLON");
    yyerror("net_declaration: K_trireg vector_scale range net_ams_decl_identifier_assignment_list K_SEMICOLON is not supported");
}
| K_trireg vector_scale K_signed range net_ams_decl_identifier_assignment_list K_SEMICOLON
{
    yydebug("net_declaration: K_trireg vector_scale K_signed range net_ams_decl_identifier_assignment_list K_SEMICOLON");
    yyerror("net_declaration: K_trireg vector_scale K_signed range net_ams_decl_identifier_assignment_list K_SEMICOLON is not supported");
}
| K_trireg vector_scale K_signed range delay3 net_ams_decl_identifier_assignment_list K_SEMICOLON
{
    yydebug("net_declaration: K_trireg vector_scale K_signed range delay3 net_ams_decl_identifier_assignment_list K_SEMICOLON");
    yyerror("net_declaration: K_trireg vector_scale K_signed range delay3 net_ams_decl_identifier_assignment_list K_SEMICOLON is not supported");
}
| K_trireg charge_strength net_ams_decl_identifier_assignment_list K_SEMICOLON
{
    yydebug("net_declaration: K_trireg charge_strength net_ams_decl_identifier_assignment_list K_SEMICOLON");
    yyerror("net_declaration: K_trireg charge_strength net_ams_decl_identifier_assignment_list K_SEMICOLON is not supported");
}
| K_trireg charge_strength K_signed net_ams_decl_identifier_assignment_list K_SEMICOLON
{
    yydebug("net_declaration: K_trireg charge_strength K_signed net_ams_decl_identifier_assignment_list K_SEMICOLON");
    yyerror("net_declaration: K_trireg charge_strength K_signed net_ams_decl_identifier_assignment_list K_SEMICOLON is not supported");
}
| K_trireg charge_strength delay3 net_ams_decl_identifier_assignment_list K_SEMICOLON
{
    yydebug("net_declaration: K_trireg charge_strength delay3 net_ams_decl_identifier_assignment_list K_SEMICOLON");
    yyerror("net_declaration: K_trireg charge_strength delay3 net_ams_decl_identifier_assignment_list K_SEMICOLON is not supported");
}
| K_trireg charge_strength K_signed delay3 net_ams_decl_identifier_assignment_list K_SEMICOLON
{
    yydebug("net_declaration: K_trireg charge_strength K_signed delay3 net_ams_decl_identifier_assignment_list K_SEMICOLON");
    yyerror("net_declaration: K_trireg charge_strength K_signed delay3 net_ams_decl_identifier_assignment_list K_SEMICOLON is not supported");
}
| K_trireg charge_strength range net_ams_decl_identifier_assignment_list K_SEMICOLON
{
    yydebug("net_declaration: K_trireg charge_strength range net_ams_decl_identifier_assignment_list K_SEMICOLON");
    yyerror("net_declaration: K_trireg charge_strength range net_ams_decl_identifier_assignment_list K_SEMICOLON is not supported");
}
| K_trireg charge_strength vector_scale range net_ams_decl_identifier_assignment_list K_SEMICOLON
{
    yydebug("net_declaration: K_trireg charge_strength vector_scale range net_ams_decl_identifier_assignment_list K_SEMICOLON");
    yyerror("net_declaration: K_trireg charge_strength vector_scale range net_ams_decl_identifier_assignment_list K_SEMICOLON is not supported");
}
| K_trireg charge_strength vector_scale K_signed range net_ams_decl_identifier_assignment_list K_SEMICOLON
{
    yydebug("net_declaration: K_trireg charge_strength vector_scale K_signed range net_ams_decl_identifier_assignment_list K_SEMICOLONN");
    yyerror("net_declaration: K_trireg charge_strength vector_scale K_signed range net_ams_decl_identifier_assignment_list K_SEMICOLON is not supported");
}
| K_trireg charge_strength vector_scale K_signed range delay3 net_ams_decl_identifier_assignment_list K_SEMICOLON
{
    yydebug("net_declaration: K_trireg charge_strength vector_scale K_signed range delay3 net_ams_decl_identifier_assignment_list K_SEMICOLON");
    yyerror("net_declaration: K_trireg charge_strength vector_scale K_signed range delay3 net_ams_decl_identifier_assignment_list K_SEMICOLON is not supported");
}
// ** VERILOG-AMS ** -->
| K_wreal net_ams_decl_identifier_assignment_list K_SEMICOLON
{
    yydebug("net_declaration: K_wreal net_ams_decl_identifier_assignment_list K_SEMICOLON");
    RULE_BREAK_MACRO
    Real * tr = new Real();
    tr->setSpan(new Range(63,0));
    parserInstance->setCodeInfo(tr, true);
    $$ = parserInstance->parse_NetDeclaration( false, nullptr, $2, tr );
}
| K_wreal discipline_identifier_range net_ams_decl_identifier_assignment_list K_SEMICOLON
{
    yydebug("net_declaration: K_wreal discipline_identifier_range net_ams_decl_identifier_assignment_list K_SEMICOLON");
    RULE_BREAK_MACRO
    Real * tr = new Real();
    tr->setSpan(new Range(63,0));
    parserInstance->setCodeInfo(tr, true);
    $$ = parserInstance->parse_NetDeclaration( false, $2, $3, tr );
}
| K_ground net_ams_decl_identifier_assignment_list K_SEMICOLON
{
    yydebug("net_declaration: net_ams_decl_identifier_assignment_list K_SEMICOLON");
    RULE_BREAK_MACRO
    TypeReference * tr = new TypeReference();
    tr->setName("ground");
    parserInstance->setCodeInfo(tr);
    $$ = parserInstance->parse_NetDeclaration( false, nullptr, $2, tr );
}
| K_ground discipline_identifier_range net_ams_decl_identifier_assignment_list K_SEMICOLON
{
    yydebug("net_declaration: discipline_identifier_range net_ams_decl_identifier_assignment_list K_SEMICOLON");
    RULE_BREAK_MACRO
    TypeReference * tr = new TypeReference();
    tr->setName("ground");
    parserInstance->setCodeInfo(tr);
    $$ = parserInstance->parse_NetDeclaration( false, $2, $3, tr );
}
// NOTE: see module_instance and module_instantiation
//| discipline_identifier_range net_ams_decl_identifier_assignment_list K_SEMICOLON
//{
//    yydebug("net_declaration: discipline_identifier_range net_ams_decl_identifier_assignment_list K_SEMICOLON");
//    yyerror("net_declaration: discipline_identifier_range net_ams_decl_identifier_assignment_list K_SEMICOLON is not supported");
//}
// <-- ** VERILOG-AMS **
;

discipline_identifier_range:
hierarchical_identifier
{
    yydebug("discipline_identifier_range: hierarchical_identifier.");
    yyerror("discipline_identifier_range: hierarchical_identifier is not supported.");
}
| range
{
    yydebug("discipline_identifier_range: range.");
    $$ = $1;
}
| hierarchical_identifier range
{
    yydebug("discipline_identifier_range: hierarchical_identifier range.");
    yyerror("discipline_identifier_range: hierarchical_identifier range is not supported.");
};

vector_scale:
K_vectored
{
    yydebug("vector_scale_opt: K_vectored.");
    yyerror("vector_scale_opt: K_vectored is not supported.");
}
| K_scalared
{
    yydebug("vector_scale_opt: K_scalared.");
    yyerror("vector_scale_opt: K_scalared is not supported.");
};


real_declaration:
K_real list_of_real_identifiers K_SEMICOLON
{
    yydebug("real_declaration: K_real list_of_real_identifiers K_SEMICOLON.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_RealDeclaration( $2 );
};


realtime_declaration:
K_realtime list_of_real_identifiers K_SEMICOLON
{
    yydebug("realtime_declaration: K_realtime list_of_real_identifiers K_SEMICOLON.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_TimeDeclaration( $2 );
};


discipline_identifier_signed_range:
IDENTIFIER
{
    yydebug("discipline_identifier_signed_range: IDENTIFIER");
    RULE_BREAK_MACRO
    $$ = new discipline_identifier_signed_range_t();
    $$->discipline_identifier = new Identifier( $1 );
    parserInstance->setCodeInfo( $$->discipline_identifier );
    free( $1 );
}
| K_signed
{
    yydebug("discipline_identifier_signed_range: K_signed");
    RULE_BREAK_MACRO
    $$ = new discipline_identifier_signed_range_t();
    $$->k_signed = true;
}
| range
{
    yydebug("discipline_identifier_signed_range: range");
    RULE_BREAK_MACRO
    $$ = new discipline_identifier_signed_range_t();
    $$->range = $1;
}
| IDENTIFIER K_signed
{
    yydebug("discipline_identifier_signed_range: IDENTIFIER K_signed");
    RULE_BREAK_MACRO
    $$ = new discipline_identifier_signed_range_t();
    $$->discipline_identifier = new Identifier( $1 );
    parserInstance->setCodeInfo( $$->discipline_identifier );
    free( $1 );
    $$->k_signed = true;
}
| IDENTIFIER range
{
    yydebug("discipline_identifier_signed_range: IDENTIFIER range");
    RULE_BREAK_MACRO
    $$ = new discipline_identifier_signed_range_t();
    $$->discipline_identifier = new Identifier( $1 );
    parserInstance->setCodeInfo( $$->discipline_identifier );
    free( $1 );
    $$->range = $2;
}
| IDENTIFIER K_signed range
{
    yydebug("discipline_identifier_signed_range: IDENTIFIER K_signed range");
    RULE_BREAK_MACRO
    $$ = new discipline_identifier_signed_range_t();
    $$->discipline_identifier = new Identifier( $1 );
    parserInstance->setCodeInfo( $$->discipline_identifier );
    free( $1 );
    $$->range = $3;
    $$->k_signed = true;
}
| K_signed range
{
    yydebug("discipline_identifier_signed_range: K_signed range");
    RULE_BREAK_MACRO
    $$ = new discipline_identifier_signed_range_t();
    $$->range = $2;
    $$->k_signed = true;
};


reg_declaration:
//K_reg K_signed_opt range_opt list_of_variable_identifiers K_SEMICOLON %prec LOW
K_reg list_of_variable_identifiers K_SEMICOLON
{
    yydebug("reg_declaration: list_of_variable_identifiers K_SEMICOLON.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_RegDeclaration(
            new discipline_identifier_signed_range_t(), $2 );
}
| K_reg discipline_identifier_signed_range list_of_variable_identifiers K_SEMICOLON
// ** VERILOG_AMS **
{
    yydebug("reg_declaration: K_reg discipline_identifier_signed_range list_of_variable_identifiers K_SEMICOLON.");    
    RULE_BREAK_MACRO $$ = parserInstance->parse_RegDeclaration( $2, $3 );
};

time_declaration:
K_time list_of_variable_identifiers K_SEMICOLON
{
    yydebug("time_declaration: K_time list_of_variable_identifiers K_SEMICOLON.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_TimeDeclaration( $2 );
};




/* -----------------------------------------------------------------------
 *  NET AND VARIABLE TYPES
 * -----------------------------------------------------------------------
 */

net_type:
K_supply0
{
    yydebug("net_type: K_supply0.");
    RULE_BREAK_MACRO $$ = 1;
}
| K_supply1
{
    yydebug("net_type: K_supply1.");
    RULE_BREAK_MACRO $$ = 2;
}
| K_tri
{
    yydebug("net_type: K_tri.");
    RULE_BREAK_MACRO $$ = 3;
}
| K_triand
{
    yydebug("net_type: K_triand.");
    RULE_BREAK_MACRO $$ = 4;
}
| K_trior
{
    yydebug("net_type: K_trior.");
    RULE_BREAK_MACRO $$ = 5;
}
| K_tri0
{
    yydebug("net_type: K_tri0.");
    RULE_BREAK_MACRO $$ = 6;
}
| K_tri1
{
    yydebug("net_type: K_tri1.");
    RULE_BREAK_MACRO $$ = 7;
}
| K_wire
{
    yydebug("net_type: K_wire.");
    RULE_BREAK_MACRO $$ = 8;
}
| K_uwire
{
    yydebug("net_type: K_uwire.");
    RULE_BREAK_MACRO $$ = 9;
}
| K_wand
{
    yydebug("net_type: K_wand.");
    RULE_BREAK_MACRO $$ = 10;
}
| K_wor
{
    yydebug("net_type: K_wor.");
    RULE_BREAK_MACRO $$ = 11;
};



output_variable_type:
K_integer
{
    yydebug("output_variable_type: K_integer.");
    RULE_BREAK_MACRO $$ = makeVerilogIntegerType();
}
| K_time
{
    yydebug("output_variable_type: K_time.");
    yyerror("output_variable_type: K_time is not supported.");
};

//
// variable_type and real_type
//
//type:
//IDENTIFIER dimension_list %prec LOW
//{
//    yydebug("type: IDENTIFIER dimension_list.");
//    $$ = new Variable();
//    $$->setName( $1 );
//}
//// ** VERILOG_AMS **
//| IDENTIFIER dimension_list K_EQ constant_arrayinit %prec HIGH
//{
//    yydebug("type: IDENTIFIER dimension_list K_EQ constant_arrayinit.");
//    $$ = new Variable();
//    $$->setName( $1 );
//}
//| IDENTIFIER K_EQ /* constant_expression */ expression
//{
//    yydebug("type: IDENTIFIER K_EQ /* constant_expression */ expression.");
//    $$ = new Variable();
//    $$->setName( $1 );
//    $$->setValue($3);
//    delete $1;
//};

type:
IDENTIFIER %prec LOW
{
    yydebug("type: IDENTIFIER.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_Type( $1 );
}
| IDENTIFIER non_empty_dimension_list %prec MEDIUM1
{
    yydebug("type: IDENTIFIER non_empty_dimension_list.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_Type( $1, $2 );
}
// ** VERILOG_AMS **
| IDENTIFIER non_empty_dimension_list K_EQ constant_arrayinit %prec HIGH
{
    yydebug("type: IDENTIFIER non_empty_dimension_list K_EQ constant_arrayinit");
    yyerror("type: IDENTIFIER non_empty_dimension_list K_EQ constant_arrayinit is not supported");
}
| IDENTIFIER K_EQ constant_arrayinit
{
    yydebug("type: IDENTIFIER K_EQ constant_arrayinit.");
    yyerror("type: IDENTIFIER K_EQ constant_arrayinit is not supported.");
}
| IDENTIFIER K_EQ /* constant_expression */ expression
{
    yydebug("type: IDENTIFIER K_EQ /* constant_expression */ expression.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_Type( $1, $3 );
};




/* -----------------------------------------------------------------------
 *  NET AND VARIABLE TYPES
 * -----------------------------------------------------------------------
 */


drive_strength:
K_LPAREN strength0 K_COMMA strength1 K_RPAREN
{
    yydebug("drive_strength: K_LPAREN strength0 K_COMMA strength1 K_RPAREN.");
    yyerror("drive_strength: K_LPAREN strength0 K_COMMA strength1 K_RPAREN is not supported.");
}
| K_LPAREN strength1 K_COMMA strength0 K_RPAREN
{
    yydebug("drive_strength: K_LPAREN strength1 K_COMMA strength0 K_RPAREN.");
    yyerror("drive_strength: K_LPAREN strength1 K_COMMA strength0 K_RPAREN is not supported.");
}
| K_LPAREN strength0 K_COMMA K_highz1 K_RPAREN
{
    yydebug("drive_strength: K_LPAREN strength0 K_COMMA K_highz1 K_RPAREN.");
    yyerror("drive_strength: K_LPAREN strength0 K_COMMA K_highz1 K_RPAREN is not supported.");
}
| K_LPAREN strength1 K_COMMA K_highz0 K_RPAREN
{
    yydebug("drive_strength: K_LPAREN strength1 K_COMMA K_highz0 K_RPAREN.");
    yyerror("drive_strength: K_LPAREN strength1 K_COMMA K_highz0 K_RPAREN is not supported.");
}
| K_LPAREN K_highz0 K_COMMA strength1 K_RPAREN
{
    yydebug("drive_strength: K_LPAREN K_highz0 K_COMMA strength1 K_RPAREN.");
    yyerror("drive_strength: K_LPAREN K_highz0 K_COMMA strength1 K_RPAREN is not supported.");
}
| K_LPAREN K_highz1 K_COMMA strength0 K_RPAREN
{
    yydebug("drive_strength: K_LPAREN K_highz1 K_COMMA strength0 K_RPAREN.");
    yyerror("drive_strength: K_LPAREN K_highz1 K_COMMA strength0 K_RPAREN is not supported.");
};


drive_strength_opt:
/* empty */
{    
    yydebug("drive_strength_opt: /* empty */");
    RULE_BREAK_MACRO $$ = nullptr;
}
| drive_strength
{    
    yydebug("drive_strength_opt: drive_strength");
    RULE_BREAK_MACRO $$ = $1;
};


strength0:
K_supply0
{
    yydebug("strength0: K_supply0.");
    yyerror("strength0: K_supply0 is not supported.");
}
| K_strong0
{
    yydebug("strength0: K_strong0.");
    yyerror("strength0: K_strong0 is not supported.");
}
| K_pull0
{
    yydebug("strength0: K_pull0.");
    yyerror("strength0: K_pull0 is not supported.");
}
| K_weak0
{
    yydebug("strength0: K_weak0.");
    yyerror("strength0: K_weak0 is not supported.");
};

strength1:
K_supply1
{
    yydebug("strength1: K_supply1.");
    yyerror("strength1: K_supply1 is not supported.");
}
| K_strong1
{
    yydebug("strength1: K_strong1.");
    yyerror("strength1: K_strong1 is not supported.");
}
| K_pull1
{
    yydebug("strength1: K_pull1.");
    yyerror("strength1: K_pull1 is not supported.");
}
| K_weak1
{
    yydebug("strength1: K_weak1.");
    yyerror("strength1: K_weak1 is not supported.");
};


charge_strength:
K_LPAREN K_small K_RPAREN
{
    yydebug("charge_strength: K_LPAREN K_small K_RPAREN.");
    yyerror("charge_strength: K_LPAREN K_small K_RPAREN is not supported.");
}
| K_LPAREN K_medium K_RPAREN
{
    yydebug("charge_strength: K_LPAREN K_medium K_RPAREN.");
    yyerror("charge_strength: K_LPAREN K_medium K_RPAREN is not supported.");
}
| K_LPAREN K_large K_RPAREN
{
    yydebug("charge_strength: K_LPAREN K_large K_RPAREN.");
    yyerror("charge_strength: K_LPAREN K_large K_RPAREN is not supported.");
};







/* -----------------------------------------------------------------------
 *  DELAYS
 * -----------------------------------------------------------------------
 */

delay3:
K_SHARP delay_value
{
    yydebug("delay3: K_SHARP delay_value.");
    RULE_BREAK_MACRO $$ = $2;
}
| K_SHARP K_LPAREN mintypmax_expression K_RPAREN
{
    yydebug("delay3: K_SHARP K_LPAREN mintypmax_expression mintypmax_expression_opt2 K_RPAREN.");
    RULE_BREAK_MACRO $$ = $3;
}
| K_SHARP K_LPAREN mintypmax_expression K_COMMA mintypmax_expression K_RPAREN
{
    yydebug("delay3: K_SHARP K_LPAREN mintypmax_expression mintypmax_expression_opt2 K_RPAREN.");
    yyerror("delay3: K_SHARP K_LPAREN mintypmax_expression mintypmax_expression_opt2 K_RPAREN is not supported.");
}
| K_SHARP K_LPAREN mintypmax_expression K_COMMA mintypmax_expression K_COMMA mintypmax_expression K_RPAREN
{
    yydebug("delay3: K_SHARP K_LPAREN mintypmax_expression mintypmax_expression_opt2 K_RPAREN.");
    yyerror("delay3: K_SHARP K_LPAREN mintypmax_expression mintypmax_expression_opt2 K_RPAREN is not supported.");
}
;


delay3_opt:
/* empty */
{
    yydebug("delay3_opt: /* empty */");
    RULE_BREAK_MACRO $$ = nullptr;
}
| delay3
{
    yydebug("delay3_opt: delay3");
    RULE_BREAK_MACRO $$ = $1;
}


delay2:
K_SHARP delay_value
{
    yydebug("delay2: K_SHARP delay_value.");
    RULE_BREAK_MACRO $$ = $2;
}
| K_SHARP K_LPAREN mintypmax_expression K_RPAREN %prec LOW
{
    yydebug("delay2: K_SHARP K_LPAREN mintypmax_expression mintypmax_expression_opt1 K_RPAREN.");
    yyerror("delay2: K_SHARP K_LPAREN mintypmax_expression mintypmax_expression_opt1 K_RPAREN is not supported.");
}
| K_SHARP K_LPAREN mintypmax_expression K_COMMA mintypmax_expression K_RPAREN %prec HIGH
{
    yydebug("delay2: K_SHARP K_LPAREN mintypmax_expression mintypmax_expression_opt1 K_RPAREN.");
    yyerror("delay2: K_SHARP K_LPAREN mintypmax_expression mintypmax_expression_opt1 K_RPAREN is not supported.");
}
;


delay2_opt:
/* empty */
{
    yydebug("delay2_opt: /* empty */");
    RULE_BREAK_MACRO $$ = nullptr;
}
| delay2
{
    yydebug("delay2_opt: delay2");
    RULE_BREAK_MACRO $$ = $1;
};


delay_value:
unsigned_number
{
    yydebug("delay_value: unsigned_number.");
    RULE_BREAK_MACRO $$ = $1;
}
| real_number
{
    yydebug("delay_value: real_number.");
    RULE_BREAK_MACRO $$ = $1;
}
| IDENTIFIER
{
    yydebug("delay_value: IDENTIFIER.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_Identifier( $1 );
};





/* -----------------------------------------------------------------------
 *  DECLARATION LISTS
 * -----------------------------------------------------------------------
 */
// ** VERILOG_AMS **
list_of_branch_identifiers:
IDENTIFIER range_opt
{
    yydebug("list_of_branch_identifiers: IDENTIFIER range_opt");
    yyerror("list_of_branch_identifiers: IDENTIFIER range_opt is not supported");
}
| list_of_branch_identifiers K_COMMA IDENTIFIER range_opt
{
    yydebug("list_of_branch_identifiers: list_of_branch_identifiers K_COMMA IDENTIFIER range_opt");
    yyerror("list_of_branch_identifiers: list_of_branch_identifiers K_COMMA IDENTIFIER range_opt is not supported");
};

list_of_defparam_assignments:
defparam_assignment
{
    yydebug("list_of_defparam_assignments: defparam_assignment.");
    yyerror("list_of_defparam_assignments: defparam_assignment is not supported.");
}
| list_of_defparam_assignments K_COMMA defparam_assignment
{
    yydebug("list_of_defparam_assignments: list_of_defparam_assignments K_COMMA defparam_assignment.");
    yyerror("list_of_defparam_assignments: list_of_defparam_assignments K_COMMA defparam_assignment is not supported.");
};


list_of_event_identifiers:
/* event_identifier */ IDENTIFIER dimension_list
{
    yydebug("list_of_event_identifiers: /* event_identifier */ IDENTIFIER dimension_list.");
    RULE_BREAK_MACRO
    $$ = new BList<Variable>();
    $$->push_back( parserInstance->parse_EventIdentifier( $1, $2 ) );
}
| list_of_event_identifiers K_COMMA /* event_identifier */ IDENTIFIER dimension_list
{
    yydebug("list_of_event_identifiers: list_of_event_identifiers K_COMMA "
            "/* event_identifier */ IDENTIFIER dimension_list.");
    RULE_BREAK_MACRO
    $$ = $1;
    $$->push_back( parserInstance->parse_EventIdentifier( $3, $4 ) );
};


// ** VERILOG_AMS **
//list_of_net_identifiers:
//ams_net_identifier
//{
//    yydebug("list_of_net_identifiers: ams_net_identifier.");
//    yyerror("list_of_net_identifiers: ams_net_identifier is not supported.");
//}
//| list_of_net_identifiers K_COMMA ams_net_identifier
//{
//    yydebug("list_of_net_identifiers: list_of_net_identifiers K_COMMA ams_net_identifier.");
//    yyerror("list_of_net_identifiers: list_of_net_identifiers K_COMMA ams_net_identifier is not supported.");
//};


list_of_param_assignments:
param_assignment
{
    yydebug("list_of_param_assignments: param_assignment.");
    RULE_BREAK_MACRO
    $$ = new BList<Assign>();
    $$->push_back( $1 );
} 
| list_of_param_assignments K_COMMA param_assignment
{
    yydebug("list_of_param_assignments: list_of_param_assignments K_COMMA param_assignment.");
    RULE_BREAK_MACRO
    $$ = $1;
    $$->push_back( $3 );
};


list_of_real_identifiers:
/* real_type */ type
{
    yydebug("list_of_real_identifiers: /* real_type */ type.");
    RULE_BREAK_MACRO
    $$ = new BList<Signal>();
    $$->push_back( $1 );
}
| list_of_real_identifiers K_COMMA /* real_type */ type
{
    yydebug("list_of_real_identifiers: list_of_real_identifiers /* real_type */ type.");
    RULE_BREAK_MACRO
    $$ = $1;
    $$->push_back( $3 );
};


list_of_specparam_assignments:
specparam_assignment
{
    yydebug("list_of_specparam_assignments: specparam_assignment.");
    yyerror("list_of_specparam_assignments: specparam_assignment is not supported.");
}
| list_of_specparam_assignments K_COMMA specparam_assignment
{
    yydebug("list_of_specparam_assignments: list_of_specparam_assignments K_COMMA specparam_assignment.");
    yyerror("list_of_specparam_assignments: list_of_specparam_assignments K_COMMA specparam_assignment is not supported.");
};


list_of_variable_identifiers:
/* variable_type */ type
{
    yydebug("list_of_variable_identifiers: /* variable_type */ type.");
    RULE_BREAK_MACRO
    $$ = new BList<Signal>();
    $$->push_back( $1 );
}
| list_of_variable_identifiers K_COMMA /* variable_type */ type
{
    yydebug("list_of_variable_identifiers: list_of_variable_identifiers K_COMMA /* variable_type */ type.");
    RULE_BREAK_MACRO
    $$ = $1;
    $$->push_back( $3 );
};


list_of_variable_port_identifiers:
/* port_identifier */ IDENTIFIER eq_constant_expression_opt
{
    yydebug("list_of_variable_port_identifiers: /* port_identifier */ IDENTIFIER eq_constant_expression_opt.");
    RULE_BREAK_MACRO
    $$ = new BList<Port>();
    $$->push_back( parserInstance->parse_VariablePortIdentifier( $1, $2 ) );
}
| list_of_variable_port_identifiers K_COMMA /* port_identifier */ IDENTIFIER eq_constant_expression_opt
{
    yydebug("list_of_variable_port_identifiers: list_of_variable_port_identifiers K_COMMA "
            "/* port_identifier */ IDENTIFIER eq_constant_expression_opt.");
    RULE_BREAK_MACRO
    $$ = $1;
    $$->push_back( parserInstance->parse_VariablePortIdentifier( $3, $4 ) );
};


eq_constant_expression_opt:
/* empty */
{
    yydebug("eq_constant_expression_opt.");
    RULE_BREAK_MACRO $$ = nullptr;
}
| K_EQ /* constant_expression */ expression
{
    yydebug("eq_constant_expression_opt: K_EQ /* constant_expression */ expression.");
    RULE_BREAK_MACRO $$ = $2;
};




/* -----------------------------------------------------------------------
 *  DECLARATION ASSIGNMENTS
 * -----------------------------------------------------------------------
 */

defparam_assignment:
/* hierarchical_parameter_identifier */ hierarchical_identifier K_EQ /*constant_mintypmax_expression*/ mintypmax_expression
{
    yydebug("defparam_assignment: /* hierarchical_parameter_identifier */ hierarchical_identifier K_EQ /*constant_mintypmax_expression*/ mintypmax_expression.");
    yyerror("defparam_assignment: /* hierarchical_parameter_identifier */ hierarchical_identifier K_EQ /*constant_mintypmax_expression*/ mintypmax_expression is not supported.");
};

net_ams_decl_identifier_assignment_list:
net_ams_decl_identifier_assignment
{
    yydebug("net_ams_decl_identifier_assignment_list: net_ams_decl_identifier_assignment.");
    RULE_BREAK_MACRO
    $$ = new std::list<net_ams_decl_identifier_assignment_t*>();
    $$->push_back( $1 );
}
| net_ams_decl_identifier_assignment_list K_COMMA net_ams_decl_identifier_assignment
{
    yydebug("net_ams_decl_identifier_assignment_list: net_ams_decl_identifier_assignment_list K_COMMA net_ams_decl_identifier_assignment.");
    RULE_BREAK_MACRO
    $$ = $1;
    $$->push_back( $3 );
};

net_ams_decl_identifier_assignment:
hierarchical_identifier
{
    yydebug("net_ams_decl_identifier_assignment: hierarchical_identifier.");
    RULE_BREAK_MACRO
    $$ = new net_ams_decl_identifier_assignment_t();
    $$->identifier = $1;
}
| /* net_identifier */ hierarchical_identifier non_empty_dimension_list
{
    yydebug("net_ams_decl_identifier_assignment: /* net_identifier */ IDENTIFIER non_empty_dimension_list.");
    RULE_BREAK_MACRO
    $$ = new net_ams_decl_identifier_assignment_t();
    $$->identifier = $1;
    $$->dimension_list = $2;
}
| /* net_identifier */ hierarchical_identifier K_EQ expression
{
    yydebug("net_ams_decl_identifier_assignment: /* net_identifier */ IDENTIFIER K_EQ expression.");
    RULE_BREAK_MACRO
    $$ = new net_ams_decl_identifier_assignment_t();
    $$->identifier = $1;
    $$->init_expression = $3;
}
// ** VERILOG_AMS **
// Disabled due to r/r conflicts between (expression -> concatenation) and (constant_optional_arrayinit -> concatenation)
//| /* net_identifier */ hierarchical_identifier K_EQ constant_optional_arrayinit
//{
//    yydebug("net_ams_decl_identifier_assignment: hierarchical_identifier K_EQ constant_optional_arrayinit");
//    yyerror("net_ams_decl_identifier_assignment: hierarchical_identifier K_EQ constant_optional_arrayinit is not supported");
//}
| /* net_identifier */ hierarchical_identifier non_empty_dimension_list K_EQ constant_optional_arrayinit
{
    yydebug("net_ams_decl_identifier_assignment: hierarchical_identifier non_empty_dimension_list K_EQ constant_optional_arrayinit");
    yyerror("net_ams_decl_identifier_assignment: hierarchical_identifier non_empty_dimension_list K_EQ constant_optional_arrayinit is not supported");
};

//net_decl_assignment:
///* net_identifier */ IDENTIFIER K_EQ expression
//{
//    yydebug("net_decl_assignment: /* net_identifier */ IDENTIFIER K_EQ expression.");
//    yyerror("net_decl_assignment: /* net_identifier */ IDENTIFIER K_EQ expression is not supported.");
//}
//// ** VERILOG_AMS **
//| /* net_identifier */ IDENTIFIER K_EQ constant_optional_arrayinit
//{
//    yyerror("VERILOG-AMS IS NOT YET SUPPORTED: net_decl_assignment 1");
//}
//| /* net_identifier */ IDENTIFIER non_empty_dimension_list K_EQ constant_optional_arrayinit
//{
//    yyerror("VERILOG-AMS IS NOT YET SUPPORTED: net_decl_assignment 2");
//};

// ** VERILOG_AMS **
//ams_net_identifier:
///* net_identifier */ IDENTIFIER non_empty_dimension_list %prec HIGH
//{
//    yydebug("ams_net_identifier: /* net_identifier */ IDENTIFIER non_empty_dimension_list.");
//    yyerror("ams_net_identifier: /* net_identifier */ IDENTIFIER non_empty_dimension_list is not supported.");
//}
//| hierarchical_identifier %prec LOW
//{
//    yydebug("ams_net_identifier: hierarchical_identifier.");
//    yyerror("ams_net_identifier: hierarchical_identifier is not supported.");
//};

param_assignment:
/* parameter_identifier */ IDENTIFIER K_EQ /*constant_mintypmax_expression*/ mintypmax_expression /* VERILOG_AMS -> */value_range_list
{
    yydebug("param_assignment: /* parameter_identifier */ IDENTIFIER K_EQ /*constant_mintypmax_expression*/ mintypmax_expression.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ParamAssignment( $1, $3 );
}
// ** VERILOG_AMS **
| /* parameter_identifier */ IDENTIFIER range K_EQ constant_arrayinit value_range_list
{
    yydebug("param_assignment: /* parameter_identifier */ IDENTIFIER range K_EQ constant_arrayinit value_range_list");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ParamAssignment( $1, $4, $2 );
};

specparam_assignment:
/* specparam_identifier */ IDENTIFIER K_EQ /*constant_mintypmax_expression*/ mintypmax_expression
{ 
    yydebug("specparam_assignment: /* specparam_identifier */ IDENTIFIER K_EQ /*constant_mintypmax_expression*/ mintypmax_expression.");
    yyerror("specparam_assignment: /* specparam_identifier */ IDENTIFIER K_EQ /*constant_mintypmax_expression*/ mintypmax_expression is not supported.");
}
| pulse_control_specparam
{
    yydebug("specparam_assignment: pulse_control_specparam.");
    yyerror("specparam_assignment: pulse_control_specparam is not supported.");
};

pulse_control_specparam:
K_pathpulse K_EQ K_LPAREN reject_limit_value error_limit_value_opt K_RPAREN
{
    yydebug("pulse_control_specparam: K_pathpulse K_EQ K_LPAREN reject_limit_value error_limit_value_opt K_RPAREN.");
    yyerror("pulse_control_specparam: K_pathpulse K_EQ K_LPAREN reject_limit_value error_limit_value_opt K_RPAREN is not supported.");
}
| K_pathpulse specify_input_terminal_descriptor '$' specify_output_terminal_descriptor K_EQ K_LPAREN reject_limit_value error_limit_value_opt K_RPAREN
{
    yydebug("pulse_control_specparam: K_pathpulse specify_input_terminal_descriptor '$' "
            "specify_output_terminal_descriptor K_EQ K_LPAREN reject_limit_value error_limit_value_opt K_RPAREN.");
    yyerror("pulse_control_specparam: K_pathpulse specify_input_terminal_descriptor '$' "
            "specify_output_terminal_descriptor K_EQ K_LPAREN reject_limit_value error_limit_value_opt K_RPAREN is not supported.");
};

error_limit_value_opt:
/* empty */
{
    yydebug("error_limit_value_opt: /* empty */");
    yyerror("error_limit_value_opt: /* empty */ is not supported.");
}
| error_limit_value
{
    yydebug("error_limit_value_opt: error_limit_value.");
    yyerror("error_limit_value_opt: error_limit_value is not supported.");
};


error_limit_value:
limit_value
{
    yydebug("error_limit_value: limit_value.");
    yyerror("error_limit_value: limit_value is not supported.");
};


reject_limit_value:
limit_value
{
    yydebug("reject_limit_value: limit_value.");
    yyerror("reject_limit_value: limit_value is not supported.");
};


limit_value:
/*constant_mintypmax_expression*/ mintypmax_expression
{
    yydebug("limit_value: /*constant_mintypmax_expression*/ mintypmax_expression.");
    yyerror("limit_value: /*constant_mintypmax_expression*/ mintypmax_expression is not supported.");
};



/* -----------------------------------------------------------------------
 *  DECLARATION RANGES
 * -----------------------------------------------------------------------
 */

// DUPLICATED RULE
//dimension:
//K_LBRACKET /* dimension_constant_expression */ constant_expression K_COLON /* dimension_constant_expression */ constant_expression K_RBRACKET
//{
//    yydebug("dimension: K_LBRACKET /* dimension_constant_expression */ constant_expression K_COLON /* dimension_constant_expression */ constant_expression K_RBRACKET.");
//};

dimension_list:
/* empty */
{
    yydebug("dimension_list: /*empty*/");
    RULE_BREAK_MACRO $$ = new BList<Range>();
}
| dimension_list range
{
    yydebug("dimension_list: dimension_list range");
    RULE_BREAK_MACRO
    $$ = $1;
    $$->push_back( $2 );
};

non_empty_dimension_list:
range
{
    yydebug("non_empty_dimension_list: range");
    RULE_BREAK_MACRO
    $$ = new BList<Range>();
    $$->push_back( $1 );
}
| non_empty_dimension_list range
{
    yydebug("non_empty_dimension_list: range");
    RULE_BREAK_MACRO
    $$ = $1;
    $$->push_back( $2 );
};

range:
K_LBRACKET /* msb_constant_expression */ /* constant_expression */ expression K_COLON /* lsb_constant_expression */ /* constant_expression */ expression K_RBRACKET
{
    yydebug("range: K_LBRACKET /* msb_constant_expression */ /* constant_expression */ expression K_COLON /* lsb_constant_expression */ /* constant_expression */ expression K_RBRACKET.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_Range( $2, $4 );
};

range_opt:
/* empty */
{
    yydebug("range_opt: /*empty*/");
    RULE_BREAK_MACRO $$ = nullptr;
}
| range
{   
    yydebug("range_opt: range");
    RULE_BREAK_MACRO $$ = $1;
};

// ** VERILOG_AMS ** -->
value_range:
value_range_type K_LPAREN value_range_expression K_COLON value_range_expression K_RPAREN
{    
    yywarning("Value ranges are ignored");
    yydebug("value_range: value_range_type K_LPAREN value_range_expression K_COLON value_range_expression K_RPAREN");
    RULE_BREAK_MACRO
    delete $3;
    delete $5;
}
| value_range_type K_LPAREN value_range_expression K_COLON value_range_expression K_RBRACKET
{    
    yywarning("Value ranges are ignored");
    yydebug("value_range: value_range_type K_LPAREN value_range_expression K_COLON value_range_expression K_RBRACKET");  
    RULE_BREAK_MACRO
    delete $3;
    delete $5;
}
| value_range_type K_LBRACKET value_range_expression K_COLON value_range_expression K_RPAREN
{
    yywarning("Value ranges are ignored");
    yydebug("value_range: value_range_type K_LBRACKET value_range_expression K_COLON value_range_expression K_RPAREN");  
    RULE_BREAK_MACRO   
    delete $3;
    delete $5;
}
| value_range_type K_LBRACKET value_range_expression K_COLON value_range_expression K_RBRACKET
{
    yywarning("Value ranges are ignored");
    yydebug("value_range: value_range_type K_LBRACKET value_range_expression K_COLON value_range_expression K_RBRACKET"); 
    RULE_BREAK_MACRO
    delete $3;
    delete $5;
}
| value_range_type K_QUOTE K_LBRACE string_list K_RBRACE
{    
    yywarning("Value ranges are ignored");
    yydebug("value_range: value_range_type K_QUOTE K_LBRACE string_list K_RBRACE");      
}
| K_exclude /* constant_expression */ expression
{
    yywarning("Value ranges are ignored");
    yydebug("value_range: K_exclude /* constant_expression */ expression");   
    RULE_BREAK_MACRO
    delete $2;
};

value_range_list:
/* empty */
{
    yydebug("value_range_list: /* empty */");
}
| value_range_list value_range
{
    yydebug("value_range_list: value_range_list value_range");
};

string_list:
STRING
{
    yydebug("string_list: STRING");
    RULE_BREAK_MACRO
    $$ = new std::list<std::string>();
    $$->push_back( std::string($1) );
}
| string_list K_COMMA STRING
{
    yydebug("string_list: string_list K_COMMA STRING");
    RULE_BREAK_MACRO
    $$ = $1;
    $$->push_back( std::string($3) );
};

value_range_type:
K_from
{
    yydebug("value_range_type: K_from");
}
| K_exclude
{
    yydebug("value_range_type: K_exclude");
};

value_range_expression:
/* constant_expression */ expression 
{ 
    yydebug("value_range_expression: /* constant_expression */ expression ");
    RULE_BREAK_MACRO $$ = $1;
}
| K_MINUS K_inf 
{
    yydebug("value_range_expression: K_MINUS K_inf  ");
    RULE_BREAK_MACRO $$ = nullptr;
}
| K_inf
{
    yydebug("value_range_expression: K_inf");
    RULE_BREAK_MACRO $$ = nullptr;
};

// <-- ** VERILOG_AMS **


/* -----------------------------------------------------------------------
 *  FUNCTION DECLARATIONS
 * -----------------------------------------------------------------------
 */

// ** VERILOG_AMS ** -->

analog_function_declaration:
K_analog K_function K_integer /* analog_function_identifier */ IDENTIFIER K_SEMICOLON
analog_function_item_declaration_list analog_function_statement K_endfunction
{
    yydebug("K_analog K_function K_integer IDENTIFIER K_SEMICOLON "
            "analog_function_item_declaration_list analog_function_statement K_endfunction");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AnalogFunctionDeclaration(true, $4, $6, $7);
}
| K_analog K_function K_real /* analog_function_identifier */ IDENTIFIER K_SEMICOLON
analog_function_item_declaration_list analog_function_statement K_endfunction
{
    yydebug("K_analog K_function K_real IDENTIFIER K_SEMICOLON "
            "analog_function_item_declaration_list analog_function_statement K_endfunction");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AnalogFunctionDeclaration(false, $4, $6, $7);
};

//analog_function_type:
//integer | real

analog_function_item_declaration:
analog_block_item_declaration
{
    yydebug("analog_function_item_declaration: analog_block_item_declaration");
    RULE_BREAK_MACRO
    analog_function_item_declaration_t * ret = new analog_function_item_declaration_t();
    ret->analog_block_item_declaration.merge(*$1);
    delete $1;
    $$ = ret;
}
| /*input_declaration*/ input_declaration_identifiers K_SEMICOLON
{
    yydebug("analog_function_item_declaration: input_declaration_identifiers K_SEMICOLON");
    RULE_BREAK_MACRO
    analog_function_item_declaration_t * ret = new analog_function_item_declaration_t();
    ret->input_declaration_identifiers.merge(*$1);
    delete $1;
    $$ = ret;
}
| /*output_declaration*/ output_declaration_identifiers K_SEMICOLON
{
    yydebug("analog_function_item_declaration: output_declaration_identifiers K_SEMICOLON");
    RULE_BREAK_MACRO
    analog_function_item_declaration_t * ret = new analog_function_item_declaration_t();
    ret->output_declaration_identifiers.merge(*$1);
    delete $1;
    $$ = ret;
}
| inout_declaration K_SEMICOLON
{
    yydebug("analog_function_item_declaration: inout_declaration K_SEMICOLON");
    RULE_BREAK_MACRO
    analog_function_item_declaration_t * ret = new analog_function_item_declaration_t();
    ret->inout_declaration_identifiers.push_back($1);
    $$ = ret;
};

analog_function_item_declaration_list:
analog_function_item_declaration
{
    yydebug("analog_function_item_declaration_list: analog_function_item_declaration");
    RULE_BREAK_MACRO
    $$ = $1;
}
| analog_function_item_declaration_list analog_function_item_declaration
{
    yydebug("analog_function_item_declaration_list: analog_function_item_declaration_list analog_function_item_declaration");
    RULE_BREAK_MACRO
    $$ = $1;
    $$->analog_block_item_declaration.merge($2->analog_block_item_declaration);
    $$->input_declaration_identifiers.merge($2->input_declaration_identifiers);
    $$->output_declaration_identifiers.merge($2->output_declaration_identifiers);
    $$->inout_declaration_identifiers.merge($2->inout_declaration_identifiers);
};

// <-- ** VERILOG_AMS **


function_declaration:
K_function K_automatic_opt function_range_or_type_opt /* function_identifier */ IDENTIFIER 
K_SEMICOLON function_item_declaration_list /* function_statement */ statement K_endfunction
{
    yydebug("function_declaration: K_function K_automatic_opt function_range_or_type_opt "
            "/* function_identifier */ IDENTIFIER K_SEMICOLON function_item_declaration "
            "function_item_declaration_list /* function_statement */ statement K_endfunction.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FunctionDeclaration( $3, $4, $6, $7 );
}
| K_function K_automatic_opt function_range_or_type_opt /* function_identifier */ IDENTIFIER 
K_LPAREN function_port_list K_RPAREN K_SEMICOLON block_item_declaration_list /* function_statement */ statement K_endfunction
{
    yydebug("function_declaration: K_function K_automatic_opt function_range_or_type_opt "
            "/* function_identifier */ IDENTIFIER K_LPAREN function_port_list K_RPAREN K_SEMICOLON "
            "block_item_declaration_list /* function_statement */ statement K_endfunction.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FunctionDeclaration( $3, $4, $6, $9, $10 );
};



function_item_declaration_list:
function_item_declaration
{
    yydebug("function_item_declaration_list.");
    RULE_BREAK_MACRO
    $$ = new std::list<function_item_declaration_t*> ();
    $$->push_back( $1 );
}
| function_item_declaration_list function_item_declaration
{
    yydebug("function_item_declaration_list: function_item_declaration_list function_item_declaration.");
    RULE_BREAK_MACRO
    $$ = $1;
    $$->push_back( $2 );
};


block_item_declaration_list:
/* empty */
{
    yydebug("block_item_declaration_list: /* empty */");
    RULE_BREAK_MACRO $$ = new std::list<block_item_declaration_t*> ();
}
| block_item_declaration_list block_item_declaration
{
    yydebug("block_item_declaration_list: block_item_declaration_list block_item_declaration.");
    RULE_BREAK_MACRO
    $$ = $1;
    $$->push_back( $2 );
};


function_item_declaration:
block_item_declaration
{
    yydebug("function_item_declaration: block_item_declaration.");
    RULE_BREAK_MACRO
    $$ = new function_item_declaration_t();
    $$->block_item_declaration = $1;
}
| attribute_instance_list tf_input_declaration_identifiers K_SEMICOLON
{
    yydebug("function_item_declaration: attribute_instance_list tf_input_declaration_identifiers K_SEMICOLON.");
    RULE_BREAK_MACRO
    $$ = new function_item_declaration_t();
    $$->tf_input_declaration = $2;
};


function_port_list:
attribute_instance_list tf_input_declaration
{
    yydebug("function_port_list: attribute_instance_list tf_input_declaration.");
    RULE_BREAK_MACRO
    $$ = new BList<Port>();
    $$->push_back($2);
}
| function_port_list K_COMMA IDENTIFIER
{
    yydebug("function_port_list K_COMMA attribute_instance_list tf_input_declaration.");
    RULE_BREAK_MACRO
    $$ = $1;
    messageAssert($1->size() > 0, "Unexpected empty function port list", nullptr, nullptr);
    Port * port_o = hif::copy($1->back());
    port_o->setName($3);
    free($3);
}
| function_port_list K_COMMA attribute_instance_list tf_input_declaration
{
    yydebug("function_port_list K_COMMA attribute_instance_list tf_input_declaration.");
    RULE_BREAK_MACRO
    $$ = $1;
    $$->push_back($4);
};


function_range_or_type:
K_signed range
{
    yydebug("function_range_or_type: K_signed range.");
    RULE_BREAK_MACRO
    $$ = getSemanticType( $2, true );
    delete $2;
}
| range
{
    yydebug("function_range_or_type: range.");
    RULE_BREAK_MACRO
    $$ = getSemanticType( $1 );
    delete $1;
}
| K_signed
{
    yydebug("function_range_or_type: K_signed.");
    yyerror("function_range_or_type: K_signed is not supported.");
}
| K_integer
{
    yydebug("function_range_or_type: K_integer.");
    RULE_BREAK_MACRO $$ = makeVerilogIntegerType();
}
| K_real
{
    yydebug("function_range_or_type: K_real.");
    RULE_BREAK_MACRO $$ = new Real();
}
| K_realtime
{
    yydebug("function_range_or_type: K_realtime.");
    yyerror("function_range_or_type: K_realtime is not supported.");
}
| K_time
{
    yydebug("function_range_or_type: K_time.");
    yyerror("function_range_or_type: K_time is not supported.");
};



function_range_or_type_opt:
/* empty */
{
    yydebug("function_range_or_type_opt: /*empty*/");
    RULE_BREAK_MACRO $$ = nullptr;
}
| function_range_or_type
{
    yydebug("function_range_or_type_opt: function_range_or_type");
    RULE_BREAK_MACRO $$ = $1;
};



/* -----------------------------------------------------------------------
 *  TASK DECLARATIONS
 * -----------------------------------------------------------------------
 */

task_declaration:
K_task K_automatic_opt /* task_identifier */ IDENTIFIER K_SEMICOLON task_item_declaration_list statement_or_null K_endtask
{
    yydebug("task_declaration: K_task K_automatic_opt /* task_identifier */ IDENTIFIER K_SEMICOLON "
            "task_item_declaration_list statement_or_null K_endtask.");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_TaskDeclaration( $2, $3, $5, $6 );
}
| K_task K_automatic_opt /* task_identifier */ IDENTIFIER K_LPAREN task_port_list K_RPAREN K_SEMICOLON block_item_declaration_list statement_or_null K_endtask
{
    yydebug("task_declaration: K_task K_automatic_opt /* task_identifier */ IDENTIFIER "
            "K_LPAREN task_port_list K_RPAREN K_SEMICOLON block_item_declaration_list statement_or_null K_endtask.");
    yyerror("task_declaration: K_task K_automatic_opt /* task_identifier */ IDENTIFIER "
            "K_LPAREN task_port_list K_RPAREN K_SEMICOLON block_item_declaration_list statement_or_null K_endtask is not supported.");
    //$$ = parserInstance->parse_TaskDeclaration( $3, $5, $8, $9 );
};


task_item_declaration:
block_item_declaration
{
    yydebug("task_item_declaration: block_item_declaration.");
    RULE_BREAK_MACRO
    $$ = new task_item_declaration_t();
    $$->block_item_declaration = $1;
}
| attribute_instance_list tf_input_declaration_identifiers K_SEMICOLON
{
    yydebug("task_item_declaration: attribute_instance_list tf_input_declaration_identifiers K_SEMICOLON.");
    RULE_BREAK_MACRO
    $$ = new task_item_declaration_t();
    $$->tf_declaration = $2;
}
| attribute_instance_list tf_output_declaration_identifiers K_SEMICOLON
{
    yydebug("task_item_declaration: attribute_instance_list tf_output_declaration_identifiers K_SEMICOLON.");
    RULE_BREAK_MACRO
    $$ = new task_item_declaration_t();
    $$->tf_declaration = $2;
}
| attribute_instance_list tf_inout_declaration_identifiers K_SEMICOLON
{
    yydebug("task_item_declaration: attribute_instance_list tf_inout_declaration_identifiers K_SEMICOLON.");
    RULE_BREAK_MACRO
    $$ = new task_item_declaration_t();
    $$->tf_declaration = $2;
};


task_item_declaration_list:
/* empty */
{
    yydebug("task_item_declaration_list: /*empty*/");
    RULE_BREAK_MACRO $$ = new std::list<task_item_declaration_t*> ();
}
| task_item_declaration_list task_item_declaration
{
    yydebug("task_item_declaration_list: task_item_declaration_list task_item_declaration");
    RULE_BREAK_MACRO
    $$ = $1;
    $$->push_back( $2 );
};


task_port_list:
task_port_item
{
    yydebug("task_port_list: task_port_item.");
    yyerror("task_port_list: task_port_item is not supported.");
}
| task_port_list K_COMMA IDENTIFIER
{
    yydebug("task_port_list: task_port_list K_COMMA IDENTIFIER.");
    yyerror("task_port_list: task_port_list K_COMMA IDENTIFIER is not supported.");
}
| task_port_list K_COMMA task_port_item
{
    yydebug("task_port_list: task_port_list K_COMMA task_port_item.");
    yyerror("task_port_list: task_port_list K_COMMA task_port_item is not supported.");
};


task_port_item:
attribute_instance_list tf_input_declaration
{
    yydebug("task_port_item: attribute_instance_list tf_input_declaration.");
    yyerror("task_port_item: attribute_instance_list tf_input_declaration is not supported.");
}
| attribute_instance_list tf_output_declaration
{
    yydebug("task_port_item: attribute_instance_list tf_output_declaration.");
    yyerror("task_port_item: attribute_instance_list tf_output_declaration is not supported.");
}
| attribute_instance_list tf_inout_declaration
{
    yydebug("task_port_item: attribute_instance_list tf_inout_declaration.");
    yyerror("task_port_item: attribute_instance_list tf_inout_declaration is not supported.");
};



tf_input_declaration:
K_input K_reg_opt K_signed_opt range_opt  /* list_of_port_identifiers */ IDENTIFIER
{
    yydebug("tf_input_declaration: K_input K_reg_opt K_signed_opt range_opt "
            "/* list_of_port_identifiers */ IDENTIFIER.");

    RULE_BREAK_MACRO
    $$ = parserInstance->parse_TfDeclaration(
             hif::dir_in, $3, $4, new Identifier($5), nullptr );
    free($5);
}
// ** VERILOG_AMS **
//| K_input /* discipline_identifier */ identifier_opt K_reg_opt K_signed_opt range_opt  /* list_of_port_identifiers */ IDENTIFIER
//{
//    yydebug("tf_input_declaration: K_input K_reg_opt K_signed_opt range_opt "
//            "/* list_of_port_identifiers */ list_of_identifiers.");
//    //$$ = parserInstance->parse_TfDeclaration( hif::dir_in, $5, $6 );
//}
| K_input task_port_type /* list_of_port_identifiers */ IDENTIFIER
{
    yydebug("tf_input_declaration: K_input task_port_type /* list_of_port_identifiers */ IDENTIFIER");

    RULE_BREAK_MACRO
    $$ = parserInstance->parse_TfDeclaration(
             hif::dir_in, false, nullptr, new Identifier($3), $2 );
    free($3);
};


tf_input_declaration_identifiers:
K_input K_reg_opt K_signed_opt range_opt  /* list_of_port_identifiers */ list_of_identifiers
{
    yydebug("tf_input_declaration_identifiers: K_input K_reg_opt K_signed_opt range_opt "
            "/* list_of_port_identifiers */ list_of_identifiers.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_TfDeclaration( hif::dir_in, $3, $4, $5, nullptr );
}
// ** VERILOG_AMS **
//| K_input /* discipline_identifier */ identifier_opt K_reg_opt K_signed_opt range_opt  /* list_of_port_identifiers */ list_of_identifiers
//{
//    yydebug("tf_input_declaration_identifiers: K_input K_reg_opt K_signed_opt range_opt "
//            "/* list_of_port_identifiers */ list_of_identifiers.");
//    //$$ = parserInstance->parse_TfDeclaration( hif::dir_in, $5, $6 );
//}
| K_input task_port_type /* list_of_port_identifiers */ list_of_identifiers
{
    yydebug("tf_input_declaration_identifiers: K_input task_port_type /* list_of_port_identifiers */ list_of_identifiers.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_TfDeclaration( hif::dir_in, false, nullptr, $3, $2 );
};


tf_output_declaration:
K_output K_reg_opt K_signed_opt range_opt /* list_of_port_identifiers */ IDENTIFIER
{
    yydebug("tf_output_declaration: K_output K_reg_opt K_signed_opt range_opt "
            "/* list_of_port_identifiers */ IDENTIFIER.");
    yyerror("tf_output_declaration: K_output K_reg_opt K_signed_opt range_opt "
            "/* list_of_port_identifiers */ IDENTIFIER is not supported.");
    //$$ = parserInstance->parse_TfDeclaration( hif::dir_out, $4, $5 );
}
// ** VERILOG_AMS **
//| K_output /* discipline_identifier */ identifier_opt K_reg_opt K_signed_opt range_opt /* list_of_port_identifiers */ IDENTIFIER
//{
//    yydebug("tf_output_declaration: K_output K_reg_opt K_signed_opt range_opt "
//            "/* list_of_port_identifiers */ IDENTIFIER.");
//    //$$ = parserInstance->parse_TfDeclaration( hif::dir_out, $5, $6 );
//}
| K_output task_port_type /* list_of_port_identifiers */ IDENTIFIER
{
    yydebug("tf_output_declaration: K_output task_port_type /* list_of_port_identifiers */ IDENTIFIER.");
    yyerror("tf_output_declaration: K_output task_port_type /* list_of_port_identifiers */ IDENTIFIER is not supported.");
};


tf_output_declaration_identifiers:
K_output K_reg_opt K_signed_opt range_opt /* list_of_port_identifiers */ list_of_identifiers
{
    yydebug("tf_output_declaration_identifiers: K_output K_reg_opt K_signed_opt range_opt "
            "/* list_of_port_identifiers */ list_of_identifiers.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_TfDeclaration( hif::dir_out, $3, $4, $5, nullptr );
}
// ** VERILOG_AMS **
//| K_output /* discipline_identifier */ identifier_opt K_reg_opt K_signed_opt range_opt /* list_of_port_identifiers */ list_of_identifiers
//{
//    yydebug("tf_output_declaration_identifiers: K_output K_reg_opt K_signed_opt range_opt "
//            "/* list_of_port_identifiers */ list_of_identifiers.");
//    //$$ = parserInstance->parse_TfDeclaration( hif::dir_out, $5, $6 );
//}
| K_output task_port_type /* list_of_port_identifiers */ list_of_identifiers
{
    yydebug("tf_output_declaration_identifiers: K_output task_port_type /* list_of_port_identifiers */ list_of_identifiers.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_TfDeclaration( hif::dir_out, false, nullptr, $3, $2 );
};


tf_inout_declaration:
K_inout K_reg_opt K_signed_opt range_opt /* list_of_port_identifiers */ IDENTIFIER
{
    yydebug("tf_inout_declaration: K_inout K_reg_opt K_signed_opt range_opt "
            "/* list_of_port_identifiers */ IDENTIFIER.");
    yyerror("tf_inout_declaration: K_inout K_reg_opt K_signed_opt range_opt "
            "/* list_of_port_identifiers */ IDENTIFIER is not supported.");
    //$$ = parserInstance->parse_TfDeclaration( hif::dir_inout, $4, $5 );
}
// ** VERILOG_AMS **
//| K_inout /* discipline_identifier */ identifier_opt K_reg_opt K_signed_opt range_opt /* list_of_port_identifiers */ IDENTIFIER
//{
//    yydebug("tf_inout_declaration: K_inout K_reg_opt K_signed_opt range_opt "
//            "/* list_of_port_identifiers */ IDENTIFIER.");
//    //$$ = parserInstance->parse_TfDeclaration( hif::dir_inout, $5, $6 );
//}
| K_inout task_port_type /* list_of_port_identifiers */ IDENTIFIER
{
    yydebug("tf_inout_declaration: K_inout task_port_type /* list_of_port_identifiers */ IDENTIFIER.");
    yyerror("tf_inout_declaration: K_inout task_port_type /* list_of_port_identifiers */ IDENTIFIER is not supported.");
};


tf_inout_declaration_identifiers:
K_inout K_reg_opt K_signed_opt range_opt /* list_of_port_identifiers */ list_of_identifiers
{
    yydebug("tf_inout_declaration_identifiers: K_inout K_reg_opt K_signed_opt range_opt "
            "/* list_of_port_identifiers */ list_of_identifiers.");
    yyerror("tf_inout_declaration_identifiers: K_inout K_reg_opt K_signed_opt range_opt "
            "/* list_of_port_identifiers */ list_of_identifiers is not supported.");
    //$$ = parserInstance->parse_TfDeclaration( hif::dir_inout, $4, $5 );
}
// ** VERILOG_AMS **
//| K_inout /* discipline_identifier */ identifier_opt K_reg_opt K_signed_opt range_opt /* list_of_port_identifiers */ list_of_identifiers
//{
//    yydebug("tf_inout_declaration_identifiers: K_inout K_reg_opt K_signed_opt range_opt "
//            "/* list_of_port_identifiers */ list_of_identifiers.");
//    //$$ = parserInstance->parse_TfDeclaration( hif::dir_inout, $5, $6 );
//}
| K_inout task_port_type /* list_of_port_identifiers */ list_of_identifiers
{
    yydebug("tf_inout_declaration_identifiers: K_inout task_port_type /* list_of_port_identifiers */ list_of_identifiers.");
    yyerror("tf_inout_declaration_identifiers: K_inout task_port_type /* list_of_port_identifiers */ list_of_identifiers is not supported.");
};


task_port_type:
K_integer
{
    yydebug("task_port_type: integer.");
    RULE_BREAK_MACRO
    $$ = makeVerilogIntegerType();
}
| K_real
{
    yydebug("task_port_type: real.");
    RULE_BREAK_MACRO
    $$ = parserInstance->getFactory()->real(nullptr, false);
}
| K_realtime
{
    yydebug("task_port_type: realtime.");
    RULE_BREAK_MACRO
    $$ = parserInstance->getFactory()->time(false);
}
| K_time
{
    yydebug("task_port_type: time.");
    RULE_BREAK_MACRO
    $$ = parserInstance->getFactory()->time(false);
};





/* -----------------------------------------------------------------------
 *  BLOCK ITEM DECLARATIONS
 * -----------------------------------------------------------------------
 */

// ** VERILOG_AMS **
analog_block_item_declaration:
attribute_instance_list parameter_declaration_identifiers K_SEMICOLON
{
    yydebug("analog_block_item_declaration: attribute_instance_list parameter_declaration_identifiers K_SEMICOLON");
    yyerror("analog_block_item_declaration: attribute_instance_list parameter_declaration_identifiers K_SEMICOLON is not supported");
}
| attribute_instance_list integer_declaration
{
    yydebug("analog_block_item_declaration: attribute_instance_list integer_declaration");
    RULE_BREAK_MACRO $$ = $2;
} 
| attribute_instance_list real_declaration
{
    yydebug("analog_block_item_declaration: attribute_instance_list real_declaration");
    RULE_BREAK_MACRO $$ = $2;
};

analog_block_item_declaration_list:
/* empty */
{
    yydebug("analog_block_item_declaration: /* empty */");
    RULE_BREAK_MACRO
    $$ = new BList<Declaration>();
}
| analog_block_item_declaration_list analog_block_item_declaration
{
    yydebug("analog_block_item_declaration: analog_block_item_declaration_list analog_block_item_declaration");
    RULE_BREAK_MACRO
    $$ = $1;
    $$->merge( *$2 );
};


block_item_declaration:
attribute_instance_list K_reg K_signed_opt range_opt /* list_of_block_variable_identifiers */ list_of_block_identifiers K_SEMICOLON
{
    yydebug("block_item_declaration: attribute_instance_list K_reg K_signed_opt "
            "range_opt /* list_of_block_variable_identifiers */ list_of_block_identifiers K_SEMICOLON.");
    RULE_BREAK_MACRO
    $$ = new block_item_declaration_t();
    $$->reg_variable_declaration = parserInstance->parse_BlockItemDeclaration_Reg( $3, $4, $5 );
}
// ** VERILOG_AMS **
//| attribute_instance_list K_reg /* discipline_identifier */ identifier_opt K_signed_opt range_opt /* list_of_block_variable_identifiers */ list_of_block_identifiers K_SEMICOLON
//{
//    yydebug("block_item_declaration: attribute_instance_list K_reg K_signed_opt "
//            "range_opt /* list_of_block_variable_identifiers */ list_of_block_identifiers K_SEMICOLON.");
//    //$$ = new block_item_declaration_t();
//    //$$->reg_variable_declaration = parserInstance->parse_BlockItemDeclaration_Reg( $4, $5, $6 );
//}
| attribute_instance_list K_integer /* list_of_block_variable_identifiers */ list_of_block_identifiers K_SEMICOLON
{
    yydebug("block_item_declaration: attribute_instance_list K_integer /* list_of_block_variable_identifiers */ list_of_block_identifiers K_SEMICOLON.");
    RULE_BREAK_MACRO
    $$ = new block_item_declaration_t();
    $$->integer_variable_declaration = parserInstance->parse_BlockItemDeclaration_Integer( $3 );
}
| attribute_instance_list K_time /* list_of_block_variable_identifiers */ list_of_block_identifiers K_SEMICOLON
{
    yydebug("block_item_declaration: attribute_instance_list K_time /* list_of_block_variable_identifiers */ list_of_block_identifiers K_SEMICOLON.");
    yyerror("block_item_declaration: attribute_instance_list K_time /* list_of_block_variable_identifiers */ list_of_block_identifiers K_SEMICOLON is not supported.");
}
| attribute_instance_list K_real /* list_of_block_real_identifiers */ list_of_block_identifiers K_SEMICOLON
{
    yydebug("block_item_declaration: attribute_instance_list K_real /* list_of_block_real_identifiers */ list_of_block_identifiers K_SEMICOLON.");
    yyerror("block_item_declaration: attribute_instance_list K_real /* list_of_block_real_identifiers */ list_of_block_identifiers K_SEMICOLON is not supported.");
}
| attribute_instance_list K_realtime /* list_of_block_real_identifiers */ list_of_block_identifiers K_SEMICOLON
{
    yydebug("block_item_declaration: attribute_instance_list K_realtime /* list_of_block_real_identifiers */ list_of_block_identifiers K_SEMICOLON.");
    yyerror("block_item_declaration: attribute_instance_list K_realtime /* list_of_block_real_identifiers */ list_of_block_identifiers K_SEMICOLON is not supported.");
}
| attribute_instance_list event_declaration
{
    yydebug("block_item_declaration: attribute_instance_list event_declaration.");
    yyerror("block_item_declaration: attribute_instance_list event_declaration is not supported.");
}
| attribute_instance_list local_parameter_declaration K_SEMICOLON
{
    yydebug("block_item_declaration: attribute_instance_list local_parameter_declaration K_SEMICOLON.");
    RULE_BREAK_MACRO
    $$ = new block_item_declaration_t();
    $$->local_parameter_declaration = $2;
}
| attribute_instance_list parameter_declaration_identifiers K_SEMICOLON
{
    yydebug("block_item_declaration: attribute_instance_list parameter_declaration_identifiers K_SEMICOLON.");
    yyerror("block_item_declaration: attribute_instance_list parameter_declaration_identifiers K_SEMICOLON is not supported.");
};

//
// list_of_block_variable_identifiers and list_of_block_real_identifiers
//
list_of_block_identifiers:
block_type
{
    yydebug("list_of_block_identifiers: block_type.");
    RULE_BREAK_MACRO
    $$ = new BList<Signal>();
    $$->push_back( $1 );
}
| list_of_block_identifiers K_COMMA block_type
{
    yydebug("list_of_block_identifiers: list_of_block_identifiers K_COMMA block_type.");
    RULE_BREAK_MACRO
    $$ = $1;
    $$->push_back( $3 );
};

//
// block_variable_type and block_real_type
//
block_type:
IDENTIFIER dimension_list
{
    yydebug("block_type: IDENTIFIER dimension_list.");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_BlockVariableType( $1, $2 );
};




/* -----------------------------------------------------------------------
 *  PRIMITIVE INSTANTIATION AND INSTANCES
 * -----------------------------------------------------------------------
 */

gate_instantiation:
cmos_switchtype delay3_opt cmos_switch_instance_list K_SEMICOLON
{
    yydebug("gate_instantiation: cmos_switchtype delay3_opt cmos_switch_instance_list K_SEMICOLON.");
    yyerror("gate_instantiation: cmos_switchtype delay3_opt cmos_switch_instance_list K_SEMICOLON is not supported.");
}
| enable_gatetype enable_gate_instance_list K_SEMICOLON
{
    yydebug("gate_instantiation: enable_gatetype enable_gate_instance_listK_SEMICOLON.");
    yyerror("gate_instantiation: enable_gatetype enable_gate_instance_listK_SEMICOLON is not supported.");
}
| enable_gatetype drive_strength enable_gate_instance_list K_SEMICOLON
{
    yydebug("gate_instantiation: enable_gatetype drive_strength enable_gate_instance_list K_SEMICOLON.");
    yyerror("gate_instantiation: enable_gatetype drive_strength enable_gate_instance_list K_SEMICOLON is not supported.");
}
| enable_gatetype delay3 enable_gate_instance_list K_SEMICOLON
{
    yydebug("gate_instantiation: enable_gatetype delay3 enable_gate_instance_list K_SEMICOLON.");
    yyerror("gate_instantiation: enable_gatetype delay3 enable_gate_instance_list K_SEMICOLON is not supported.");
}
| enable_gatetype drive_strength delay3 enable_gate_instance_list K_SEMICOLON
{
    yydebug("gate_instantiation: enable_gatetype drive_strength delay3 enable_gate_instance_list K_SEMICOLON.");
    yyerror("gate_instantiation: enable_gatetype drive_strength delay3 enable_gate_instance_list K_SEMICOLON is not supported.");
}
| mos_switchtype delay3_opt mos_switch_instance_list K_SEMICOLON
{
    yydebug("gate_instantiation: mos_switchtype delay3_opt mos_switch_instance_list K_SEMICOLON.");
    yyerror("gate_instantiation: mos_switchtype delay3_opt mos_switch_instance_list K_SEMICOLON is not supported.");
}
| n_input_gatetype n_input_gate_instance_list K_SEMICOLON
{
    yydebug("gate_instantiation: n_input_gatetype n_input_gate_instance_list K_SEMICOLON.");
    yyerror("gate_instantiation: n_input_gatetype n_input_gate_instance_list K_SEMICOLON is not supported.");
}
| n_input_gatetype drive_strength n_input_gate_instance_list K_SEMICOLON
{
    yydebug("gate_instantiation: n_input_gatetype drive_strength n_input_gate_instance_list K_SEMICOLON.");
    yyerror("gate_instantiation: n_input_gatetype drive_strength n_input_gate_instance_list K_SEMICOLON is not supported.");
}
| n_input_gatetype delay2 n_input_gate_instance_list K_SEMICOLON
{
    yydebug("gate_instantiation: n_input_gatetype delay2 n_input_gate_instance_list K_SEMICOLON.");
    yyerror("gate_instantiation: n_input_gatetype delay2 n_input_gate_instance_list K_SEMICOLON is not supported.");
}
| n_input_gatetype drive_strength delay2 n_input_gate_instance_list K_SEMICOLON
{
    yydebug("gate_instantiation: n_input_gatetype drive_strength delay2 n_input_gate_instance_list K_SEMICOLON.");
    yyerror("gate_instantiation: n_input_gatetype drive_strength delay2 n_input_gate_instance_list K_SEMICOLON is not supported.");
}
| n_output_gatetype n_output_gate_instance_list K_SEMICOLON
{
    yydebug("gate_instantiation: n_output_gatetype drive_strength delay2 n_output_gate_instance_list K_SEMICOLON.");
    yyerror("gate_instantiation: n_output_gatetype drive_strength delay2 n_output_gate_instance_list K_SEMICOLON is not supported.");
}
| n_output_gatetype drive_strength n_output_gate_instance_list K_SEMICOLON
{
    yydebug("gate_instantiation: n_output_gatetype drive_strength n_output_gate_instance_list K_SEMICOLON.");
    yyerror("gate_instantiation: n_output_gatetype drive_strength n_output_gate_instance_list K_SEMICOLON is not supported.");
}
| n_output_gatetype delay2 n_output_gate_instance_list K_SEMICOLON
{
    yydebug("gate_instantiation: n_output_gatetype delay2 n_output_gate_instance_list K_SEMICOLON.");
    yyerror("gate_instantiation: n_output_gatetype delay2 n_output_gate_instance_list K_SEMICOLON is not supported.");
}
| n_output_gatetype drive_strength delay2 n_output_gate_instance_list K_SEMICOLON
{
    yydebug("gate_instantiation: n_output_gatetype drive_strength delay2 n_output_gate_instance_list K_SEMICOLON.");
    yyerror("gate_instantiation: n_output_gatetype drive_strength delay2 n_output_gate_instance_list K_SEMICOLON is not supported.");
}
| pass_en_switchtype delay2_opt pass_enable_switch_instance_list K_SEMICOLON
{
    yydebug("gate_instantiation: pass_en_switchtype delay2_opt pass_enable_switch_instance_list K_SEMICOLON.");
    yyerror("gate_instantiation: pass_en_switchtype delay2_opt pass_enable_switch_instance_list K_SEMICOLON is not supported."); 
}
| pass_switchtype pass_switch_instance_list K_SEMICOLON
{
    yydebug("gate_instantiation: pass_switchtype pass_switch_instance_list K_SEMICOLON.");
    yyerror("gate_instantiation: pass_switchtype pass_switch_instance_list K_SEMICOLON is not supported.");
}
| K_pulldown pull_gate_instance_list K_SEMICOLON
{
    yydebug("gate_instantiation: K_pulldown pull_gate_instance_list K_SEMICOLON.");
    yyerror("gate_instantiation: K_pulldown pull_gate_instance_list K_SEMICOLON is not supported.");
}
| K_pulldown pulldown_strength pull_gate_instance_list K_SEMICOLON
{
    yydebug("gate_instantiation: K_pulldown pulldown_strength pull_gate_instance_list K_SEMICOLON.");
    yyerror("gate_instantiation: K_pulldown pulldown_strength pull_gate_instance_list K_SEMICOLON is not supported.");
}
| K_pullup pull_gate_instance_list K_SEMICOLON
{
    yydebug("gate_instantiation: K_pullup  ull_gate_instance_list K_SEMICOLON.");
    yyerror("gate_instantiation: K_pullup pull_gate_instance_list K_SEMICOLON is not supported.");
}
| K_pullup pullup_strength pull_gate_instance_list K_SEMICOLON
{
    yydebug("gate_instantiation: K_pullup pullup_strength pull_gate_instance_list K_SEMICOLON.");
    yyerror("gate_instantiation: K_pullup pullup_strength pull_gate_instance_list K_SEMICOLON is not supported.");
};






cmos_switch_instance:
name_of_gate_instance_opt K_LPAREN /* output_terminal */ lvalue K_COMMA /* input_terminal */ 
expression K_COMMA /* ncontrol_terminal */ expression K_COMMA /* pcontrol_terminal */ expression K_RPAREN
{
    yydebug("cmos_switch_instance: name_of_gate_instance_opt K_LPAREN /* output_terminal */ lvalue K_COMMA "
            "/* input_terminal */ expression K_COMMA /* ncontrol_terminal */ expression K_COMMA /* "
            "pcontrol_terminal */ expression K_RPAREN.");
    yyerror("cmos_switch_instance: name_of_gate_instance_opt K_LPAREN /* output_terminal */ lvalue K_COMMA "
            "/* input_terminal */ expression K_COMMA /* ncontrol_terminal */ expression K_COMMA /* "
            "pcontrol_terminal */ expression K_RPAREN is not supported.");
};


enable_gate_instance:
K_LPAREN /* output_terminal */ lvalue K_COMMA /* input_terminal */ expression K_COMMA /* enable_terminal */ expression K_RPAREN
{
    yydebug("enable_gate_instance: K_LPAREN /* output_terminal */ lvalue K_COMMA "
            "/* input_terminal */ expression K_COMMA /* enable_terminal */ expression K_RPAREN.");
    yyerror("enable_gate_instance: K_LPAREN /* output_terminal */ lvalue K_COMMA "
            "/* input_terminal */ expression K_COMMA /* enable_terminal */ expression K_RPAREN is not supported.");
} 
| name_of_gate_instance K_LPAREN /* output_terminal */ lvalue K_COMMA /* input_terminal */ expression 
K_COMMA /* enable_terminal */ expression K_RPAREN
{
    yydebug("enable_gate_instance: name_of_gate_instance K_LPAREN /* output_terminal */ lvalue K_COMMA "
            "/* input_terminal */ expression K_COMMA /* enable_terminal */ expression K_RPAREN.");
    yyerror("enable_gate_instance: name_of_gate_instance K_LPAREN /* output_terminal */ lvalue K_COMMA "
            "/* input_terminal */ expression K_COMMA /* enable_terminal */ expression K_RPAREN is not supported.");
};


mos_switch_instance:
K_LPAREN /* output_terminal */ lvalue K_COMMA /* input_terminal */ 
expression K_COMMA /* enable_terminal */ expression K_RPAREN
{
    yydebug("mos_switch_instance: K_LPAREN /* output_terminal */ lvalue K_COMMA "
            "/* input_terminal */ expression K_COMMA /* enable_terminal */ expression K_RPAREN.");
    yyerror("mos_switch_instance: K_LPAREN /* output_terminal */ lvalue K_COMMA "
            "/* input_terminal */ expression K_COMMA /* enable_terminal */ expression K_RPAREN is not supported.");
}
| name_of_gate_instance K_LPAREN /* output_terminal */ lvalue K_COMMA /* input_terminal */ 
expression K_COMMA /* enable_terminal */ expression K_RPAREN
{
    yydebug("mos_switch_instance: name_of_gate_instance K_LPAREN /* output_terminal */ lvalue K_COMMA "
            "/* input_terminal */ expression K_COMMA /* enable_terminal */ expression K_RPAREN.");
    yyerror("mos_switch_instance: name_of_gate_instance K_LPAREN /* output_terminal */ lvalue K_COMMA "
            "/* input_terminal */ expression K_COMMA /* enable_terminal */ expression K_RPAREN is not supported.");
};


n_input_gate_instance:
K_LPAREN /* output_terminal */ lvalue K_COMMA /* input_terminal_list */ comma_expression_list K_RPAREN
{
    yydebug("n_input_gate_instance: K_LPAREN /* output_terminal */ lvalue K_COMMA /* "
            "input_terminal_list */ comma_expression_list K_RPAREN.");
    yyerror("n_input_gate_instance: K_LPAREN /* output_terminal */ lvalue K_COMMA /* "
            "input_terminal_list */ comma_expression_list K_RPAREN is not supported.");
}
| name_of_gate_instance K_LPAREN /* output_terminal */ lvalue K_COMMA /* input_terminal_list */ comma_expression_list K_RPAREN
{
    yydebug("n_input_gate_instance: name_of_gate_instance K_LPAREN /* output_terminal */ lvalue K_COMMA /* "
            "input_terminal_list */ comma_expression_list K_RPAREN");
    yyerror("n_input_gate_instance: name_of_gate_instance K_LPAREN /* output_terminal */ lvalue K_COMMA /* "
            "input_terminal_list */ comma_expression_list K_RPAREN is not supported.");
};


n_output_gate_instance:
K_LPAREN output_terminal_list K_COMMA /* input_terminal */ expression K_RPAREN
{
    yydebug("n_output_gate_instance: K_LPAREN output_terminal_list K_COMMA "
            "/* input_terminal */ expression K_RPAREN.");
    yyerror("n_output_gate_instance: K_LPAREN output_terminal_list K_COMMA "
            "/* input_terminal */ expression K_RPAREN is not supported.");
}
| name_of_gate_instance K_LPAREN output_terminal_list K_COMMA /* input_terminal */ expression K_RPAREN
{
    yydebug("n_output_gate_instance: name_of_gate_instance K_LPAREN output_terminal_list K_COMMA "
            "/* input_terminal */ expression K_RPAREN.");
    yyerror("n_output_gate_instance: name_of_gate_instance K_LPAREN output_terminal_list K_COMMA "
            "/* input_terminal */ expression K_RPAREN is not supported.");
};


pass_switch_instance:
K_LPAREN /* inout_terminal */ lvalue K_COMMA /* inout_terminal */ lvalue K_RPAREN
{
    yydebug("pass_switch_instance: K_LPAREN /* inout_terminal */ lvalue K_COMMA "
            "/* inout_terminal */ lvalue K_RPAREN.");
    yyerror("pass_switch_instance: K_LPAREN /* inout_terminal */ lvalue K_COMMA "
            "/* inout_terminal */ lvalue K_RPAREN is not supported.");
}
| name_of_gate_instance K_LPAREN /* inout_terminal */ lvalue K_COMMA /* inout_terminal */ lvalue K_RPAREN
{
    yydebug("pass_switch_instance: name_of_gate_instance K_LPAREN /* inout_terminal */ lvalue K_COMMA "
            "/* inout_terminal */ lvalue K_RPAREN.");
    yyerror("pass_switch_instance: name_of_gate_instance K_LPAREN /* inout_terminal */ lvalue K_COMMA "
            "/* inout_terminal */ lvalue K_RPAREN is not supported.");
};


pass_enable_switch_instance: 
K_LPAREN /* inout_terminal */ lvalue K_COMMA /* inout_terminal */ 
lvalue K_COMMA /* enable_terminal */ expression K_RPAREN
{
    yydebug("pass_enable_switch_instance: K_LPAREN /* inout_terminal */ lvalue K_COMMA "
            "/* inout_terminal */ lvalue K_COMMA /* enable_terminal */ expression K_RPAREN.");
    yyerror("pass_enable_switch_instance: K_LPAREN /* inout_terminal */ lvalue K_COMMA "
            "/* inout_terminal */ lvalue K_COMMA /* enable_terminal */ expression K_RPAREN is not supported.");
}
| name_of_gate_instance K_LPAREN /* inout_terminal */ lvalue K_COMMA /* inout_terminal */ 
lvalue K_COMMA /* enable_terminal */ expression K_RPAREN
{
    yydebug("pass_enable_switch_instance: name_of_gate_instance K_LPAREN /* inout_terminal */ lvalue K_COMMA "
            "/* inout_terminal */ lvalue K_COMMA /* enable_terminal */ expression K_RPAREN.");
    yyerror("pass_enable_switch_instance: name_of_gate_instance K_LPAREN /* inout_terminal */ lvalue K_COMMA "
            "/* inout_terminal */ lvalue K_COMMA /* enable_terminal */ expression K_RPAREN is not supported.");
};


pull_gate_instance:
K_LPAREN /* output_terminal */ lvalue K_RPAREN
{
    yydebug("pull_gate_instance: K_LPAREN /* output_terminal */ lvalue K_RPAREN.");
    yyerror("pull_gate_instance: K_LPAREN /* output_terminal */ lvalue K_RPAREN is not supported.");
}
| name_of_gate_instance K_LPAREN /* output_terminal */ lvalue K_RPAREN
{
    yydebug("pull_gate_instance: name_of_gate_instance K_LPAREN /* output_terminal */ lvalue K_RPAREN.");
    yyerror("pull_gate_instance: name_of_gate_instance K_LPAREN /* output_terminal */ lvalue K_RPAREN is not supported.");
};


name_of_gate_instance:
/* gate_instance_identifier */ IDENTIFIER
{
    yydebug("name_of_gate_instance: /* gate_instance_identifier */ IDENTIFIER.");
    yyerror("name_of_gate_instance: /* gate_instance_identifier */ IDENTIFIER is not supported.");
}
| /* gate_instance_identifier */ IDENTIFIER range
{
    yydebug("name_of_gate_instance: /* gate_instance_identifier */ IDENTIFIER range.");
    yyerror("name_of_gate_instance: /* gate_instance_identifier */ IDENTIFIER range is not supported.");
};

name_of_gate_instance_opt:
/* empty */
{
    yydebug("name_of_gate_instance_opt: /* empty */");
    yyerror("name_of_gate_instance_opt: /* empty */ is not supported.");
}
| name_of_gate_instance
{
    yydebug("name_of_gate_instance_opt: name_of_gate_instance.");
    yyerror("name_of_gate_instance_opt: name_of_gate_instance is not supported.");
};


output_terminal_list:
/* output_terminal */ lvalue
{
    yydebug("output_terminal_list: /* output_terminal */ lvalue.");
    yyerror("output_terminal_list: /* output_terminal */ lvalue is not supported.");
}
| output_terminal_list K_COMMA /* output_terminal */ lvalue
{
    yydebug("output_terminal_list: output_terminal_list K_COMMA /* output_terminal */ lvalue.");
    yyerror("output_terminal_list: output_terminal_list K_COMMA /* output_terminal */ lvalue is not supported.");
};

                                                     
cmos_switch_instance_list:
cmos_switch_instance
{
    yydebug("cmos_switch_instance_list: cmos_switch_instance.");
    yyerror("cmos_switch_instance_list: cmos_switch_instance is not supported.");
}
| cmos_switch_instance_list K_COMMA cmos_switch_instance_list
{
    yydebug("cmos_switch_instance_list: cmos_switch_instance_list K_COMMA cmos_switch_instance_list.");
    yyerror("cmos_switch_instance_list: cmos_switch_instance_list K_COMMA cmos_switch_instance_list is not supported.");
};


enable_gate_instance_list:
enable_gate_instance
{
    yydebug("enable_gate_instance_list: enable_gate_instance.");
    yyerror("enable_gate_instance_list: enable_gate_instance is not supported.");
}
| enable_gate_instance_list K_COMMA enable_gate_instance
{
    yydebug("enable_gate_instance_list: enable_gate_instance_list K_COMMA enable_gate_instance.");
    yyerror("enable_gate_instance_list: enable_gate_instance_list K_COMMA enable_gate_instance is not supported.");
};

mos_switch_instance_list:
mos_switch_instance
{
    yydebug("mos_switch_instance_list: mos_switch_instance.");
    yyerror("mos_switch_instance_list: mos_switch_instance is not supported.");
}
| mos_switch_instance_list K_COMMA mos_switch_instance_list
{
    yydebug("mos_switch_instance_list: mos_switch_instance_list K_COMMA mos_switch_instance_list.");
    yyerror("mos_switch_instance_list: mos_switch_instance_list K_COMMA mos_switch_instance_list is not supported.");
};

n_input_gate_instance_list:
n_input_gate_instance
{
    yydebug("n_input_gate_instance_list: n_input_gate_instance.");
    yyerror("n_input_gate_instance_list: n_input_gate_instance is not supported.");
}
| n_input_gate_instance_list K_COMMA n_input_gate_instance
{
    yydebug("n_input_gate_instance_list: n_input_gate_instance_list K_COMMA n_input_gate_instance.");
    yyerror("n_input_gate_instance_list: n_input_gate_instance_list K_COMMA n_input_gate_instance is not supported.");
};


n_output_gate_instance_list:
n_output_gate_instance
{
    yydebug("n_output_gate_instance_list: n_output_gate_instance.");
    yyerror("n_output_gate_instance_list: n_output_gate_instance is not supported.");
}
| n_output_gate_instance_list K_COMMA n_output_gate_instance
{
    yydebug("n_output_gate_instance_list: n_output_gate_instance_list K_COMMA n_output_gate_instance.");
    yyerror("n_output_gate_instance_list: n_output_gate_instance_list K_COMMA n_output_gate_instance is not supported.");
};


pass_enable_switch_instance_list:
pass_enable_switch_instance
{
    yydebug("pass_enable_switch_instance_list: pass_enable_switch_instance.");
    yyerror("pass_enable_switch_instance_list: pass_enable_switch_instance is not supported.");
}
| pass_enable_switch_instance_list K_COMMA pass_enable_switch_instance
{
    yydebug("pass_enable_switch_instance_list: pass_enable_switch_instance_list K_COMMA pass_enable_switch_instance.");
    yyerror("pass_enable_switch_instance_list: pass_enable_switch_instance_list K_COMMA pass_enable_switch_instance is not supported.");
};


pass_switch_instance_list:
pass_switch_instance
{
    yydebug("pass_switch_instance_list: pass_switch_instance.");
    yyerror("pass_switch_instance_list: pass_switch_instance is not supported.");
}
| pass_switch_instance_list pass_switch_instance
{
    yydebug("pass_switch_instance_list: pass_switch_instance_list pass_switch_instance.");
    yyerror("pass_switch_instance_list: pass_switch_instance_list pass_switch_instance is not supported.");
};


pull_gate_instance_list:
pull_gate_instance
{
    yydebug("pull_gate_instance_list: pull_gate_instance.");
    yyerror("pull_gate_instance_list: pull_gate_instance is not supported.");
}
| pull_gate_instance_list K_COMMA pull_gate_instance
{
    yydebug("pull_gate_instance_list: pull_gate_instance_list K_COMMA pull_gate_instance.");
    yyerror("pull_gate_instance_list: pull_gate_instance_list K_COMMA pull_gate_instance is not supported.");
};






/* -----------------------------------------------------------------------
 *  PRIMITIVE STRENGTHS, TERMINALS, GATE AND SWITCH TYPES
 * -----------------------------------------------------------------------
 */

pulldown_strength:
K_LPAREN strength0 K_COMMA strength1 K_RPAREN
{
    yydebug("pulldown_strength: K_LPAREN strength0 K_COMMA strength1 K_RPAREN.");
    yyerror("pulldown_strength: K_LPAREN strength0 K_COMMA strength1 K_RPAREN is not supported.");
}
| K_LPAREN strength1 K_COMMA strength0 K_RPAREN
{
    yydebug("pulldown_strength: K_LPAREN strength1 K_COMMA strength0 K_RPAREN.");
    yyerror("pulldown_strength: K_LPAREN strength1 K_COMMA strength0 K_RPAREN is not supported.");
}
| K_LPAREN strength0 K_RPAREN
{
    yydebug("pulldown_strength: K_LPAREN strength0 K_RPAREN.");
    yyerror("pulldown_strength: K_LPAREN strength0 K_RPAREN is not supported."); 
};


pullup_strength:
K_LPAREN strength0 K_COMMA strength1 K_RPAREN
{
    yydebug("pullup_strength: K_LPAREN strength0 K_COMMA strength1 K_RPAREN.");
    yyerror("pullup_strength: K_LPAREN strength0 K_COMMA strength1 K_RPAREN is not supported.");
}
| K_LPAREN strength1 K_COMMA strength0 K_RPAREN
{
    yydebug("pullup_strength: K_LPAREN strength1 K_COMMA strength0 K_RPAREN.");
    yyerror("pullup_strength: K_LPAREN strength1 K_COMMA strength0 K_RPAREN is not supported.");
}
| K_LPAREN strength1 K_RPAREN
{
    yydebug("pullup_strength: K_LPAREN strength1 K_RPAREN.");
    yyerror("pullup_strength: K_LPAREN strength1 K_RPAREN is not supported.");
};


/*
 * enable_terminal ::= expression
 * inout_terminal ::= net_lvalue
 * input_terminal ::= expression
 * ncontrol_terminal ::= expression
 * output_terminal ::= net_lvalue
 * pcontrol_terminal ::= expression
 */


cmos_switchtype:
K_cmos
{
    yydebug("cmos_switchtype: K_cmos.");
    yyerror("cmos_switchtype: K_cmos is not supported.");
}
| K_rcmos
{
    yydebug("cmos_switchtype: K_rcmos.");
    yyerror("cmos_switchtype: K_rcmos is not supported.");
};

enable_gatetype:
K_bufif0 
| K_bufif1 
| K_notif0 
| K_notif1;

mos_switchtype:
K_nmos 
| K_pmos 
| K_rnmos 
| K_rpmos;

n_input_gatetype:
K_and 
| K_nand 
| K_or 
| K_nor 
| K_xor 
| K_xnor;

n_output_gatetype:
K_buf 
| K_not;


pass_en_switchtype:
K_tranif0 
| K_tranif1 
| K_rtranif1 
| K_rtranif0;

pass_switchtype:
K_tran 
| K_rtran;




/* -----------------------------------------------------------------------
 *  MODULE INSTANTIATION
 * -----------------------------------------------------------------------
 */

module_instantiation:
// /* module_identifier */ IDENTIFIER parameter_value_assignment_opt module_instance_list K_SEMICOLON
/* module_identifier */ IDENTIFIER range_opt module_instance_list K_SEMICOLON
{
    yydebug("module_instantiation: /* module_identifier */ IDENTIFIER module_instance_list K_SEMICOLON.");
    RULE_BREAK_MACRO

    if ($2 != nullptr)
        $$ = parserInstance->parse_ModuleInstantiation( $1, $2, $3 );
    else
        $$ = parserInstance->parse_ModuleInstantiation( $1, $3 );
}
| /* module_identifier */ IDENTIFIER parameter_value_assignment module_instance_list K_SEMICOLON
{
    yydebug("module_instantiation: /* module_identifier */ IDENTIFIER parameter_value_assignment module_instance_list K_SEMICOLON.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ModuleInstantiation( $1, $2, $3 );
};

parameter_value_assignment:
K_SHARP K_LPAREN list_of_parameter_assignments K_RPAREN
{
    yydebug("parameter_value_assignment: K_SHARP K_LPAREN list_of_parameter_assignments K_RPAREN.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ParameterValueAssignment( $3 );
};

parameter_value_assignment_opt:
/* empty */
{
    yydebug("parameter_value_assignment_opt: /* empty */.");
    $$ = nullptr;
}
| parameter_value_assignment
{
    yydebug("parameter_value_assignment_opt: parameter_value_assignment.");
    $$ = $1;
};

list_of_parameter_assignments:
/* ordered_parameter_assignment_list */ comma_expression_list
{
    yydebug("list_of_parameter_assignments: /* ordered_parameter_assignment_list */ comma_expression_list.");
    RULE_BREAK_MACRO
    $$ = new list_of_parameter_assignment_t();
    $$->ordered_parameter_assignment_list = $1;
}
| named_parameter_assignment_list
{
    yydebug("list_of_parameter_assignments: named_parameter_assignment_list.");
    RULE_BREAK_MACRO
    $$ = new list_of_parameter_assignment_t();
    $$->named_parameter_assignment_list = $1;
};

named_parameter_assignment_list:
named_parameter_assignment
{
    yydebug("named_parameter_assignment_list: named_parameter_assignment.");
    RULE_BREAK_MACRO
    $$ = new BList<ValueTPAssign>();
    $$->push_back($1);
}
| named_parameter_assignment_list K_COMMA named_parameter_assignment
{
    yydebug("named_parameter_assignment_list: named_parameter_assignment_list K_COMMA named_parameter_assignment.");
    RULE_BREAK_MACRO
    $$ = $1;
    $$->push_back( $3 );
};

/* ordered_parameter_assignment ::= expression */

named_parameter_assignment:
K_DOT /* parameter_identifier */ IDENTIFIER K_LPAREN mintypmax_expression_opt K_RPAREN
{
    yydebug("named_parameter_assignment: K_DOT /* parameter_identifier */ IDENTIFIER K_LPAREN mintypmax_expression_opt K_RPAREN.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_NamedParameterAssignment( $2, $4 );
}
// ** VERILOG_AMS **
| K_DOT /* system_parameter_identifier */ SYSTEM_IDENTIFIER K_LPAREN expression_opt K_RPAREN
{
    yydebug("named_parameter_assignment: K_DOT /* system_parameter_identifier */ SYSTEM_IDENTIFIER K_LPAREN expression_opt K_RPAREN");
    yyerror("named_parameter_assignment: K_DOT /* system_parameter_identifier */ SYSTEM_IDENTIFIER K_LPAREN expression_opt K_RPAREN is not supported");
};


module_instance:
// ** VERILOG-AMS ** -->  NOTE: see net_declaration
net_ams_decl_identifier_assignment_list %prec HIGH
{
    yydebug("module_instance: discipline_identifier_range net_ams_decl_identifier_assignment_list.");
    //yyerror("module_instance: discipline_identifier_range net_ams_decl_identifier_assignment_list is not supported.");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_ModuleInstance($1);
}
// <-- ** VERILOG-AMS **
| /* name_of_module_instance */ name_of_instance K_LPAREN K_RPAREN
{
    yydebug("module_instance: /* name_of_module_instance */ name_of_instance K_LPAREN K_RPAREN.");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_ModuleInstance($1, nullptr);
}
| /* name_of_module_instance */ name_of_instance K_LPAREN ordered_port_connection_list K_RPAREN
{
    yydebug("module_instance: /* name_of_module_instance */ name_of_instance K_LPAREN ordered_port_connection_list K_RPAREN.");
    RULE_BREAK_MACRO
    list_of_port_connections_t * l = new list_of_port_connections_t();
    l->ordered_port_connection_list = $3;
    $$ = parserInstance->parse_ModuleInstance($1, l);
}
| /* name_of_module_instance */ name_of_instance K_LPAREN named_port_connection_list K_RPAREN
{
    yydebug("module_instance: /* name_of_module_instance */ name_of_instance K_LPAREN named_port_connection_list K_RPAREN.");
    RULE_BREAK_MACRO
    list_of_port_connections_t * l = new list_of_port_connections_t();
    l->named_port_connection_list = $3;
    $$ = parserInstance->parse_ModuleInstance($1, l);
};


module_instance_list:
module_instance
{
    yydebug("module_instance_list: module_instance.");
    RULE_BREAK_MACRO 

    $$ = new std::list<module_instance_and_net_ams_decl_identifier_assignment_t*>();
    $$->push_back($1);
}
| module_instance_list K_COMMA module_instance
{
    yydebug("module_instance_list: module_instance_list K_COMMA module_instance.");
    RULE_BREAK_MACRO
    
    $$ = $1;
    $$->push_back($3);
};

name_of_instance:
/* module_instance_identifier */ hierarchical_identifier range_opt
{
    yydebug("name_of_instance: /* module_instance_identifier */ IDENTIFIER range_opt.");
    RULE_BREAK_MACRO

    Identifier * identifier = dynamic_cast<Identifier*>($1);
    if (identifier != nullptr)
        $$ = identifier;
    else
        yyerror("name_of_instance: wrong identifier object");

    if ($2 != nullptr)
        delete $2;
};


//list_of_port_connections_opt:
///* empty */
//{
//    yydebug("list_of_port_connections_opt: /* empty */");
//    RULE_BREAK_MACRO $$ = nullptr;
//}
//| ordered_port_connection_list
//{
//    yydebug("list_of_port_connections_opt: ordered_port_connection_list.");
//    RULE_BREAK_MACRO
//    $$ = new list_of_port_connections_t();
//    $$->ordered_port_connection_list = $1;
//}
//| named_port_connection_list
//{
//    yydebug("list_of_port_connections_opt: named_port_connection_list.");
//    RULE_BREAK_MACRO
//    $$ = new list_of_port_connections_t();
//    $$->named_port_connection_list = $1;
//};


ordered_port_connection_list:
attribute_instance_list expression_opt
{
    yydebug("ordered_port_connection_list: attribute_instance_list expression_opt.");
    RULE_BREAK_MACRO
    $$ = new BList<Value>();

    if ($2 != nullptr)
    {
        $$->push_back($2);
    }
    else
    {
        Identifier * unconnectedPort = new Identifier();
        unconnectedPort->setName(NameTable::getInstance()->none());
        $$->push_back(unconnectedPort);
    }
}
| ordered_port_connection_list K_COMMA attribute_instance_list expression_opt
{
    yydebug("ordered_port_connection_list: ordered_port_connection_list K_COMMAattribute_instance_list expression_opt.");
    RULE_BREAK_MACRO
    $$ = $1;

    if ($4 != nullptr)
    {
        $$->push_back($4);
    }
    else
    {
        Identifier * unconnectedPort = new Identifier();
        unconnectedPort->setName(NameTable::getInstance()->none());
        $$->push_back(unconnectedPort);
    }
};


named_port_connection_list:
attribute_instance_list K_DOT /* port_identifier */ IDENTIFIER K_LPAREN expression_opt K_RPAREN
{
    yydebug("named_port_connection_list: attribute_instance_list K_DOT /* port_identifier */ IDENTIFIER K_LPAREN expression_opt K_RPAREN.");
    RULE_BREAK_MACRO
    $$ = new BList<PortAssign>(); 
    $$->push_back( parserInstance->parse_NamedPortConnectionList( $3, $5) );
}
| named_port_connection_list K_COMMA attribute_instance_list K_DOT /* port_identifier */ IDENTIFIER K_LPAREN expression_opt K_RPAREN
{
    yydebug("named_port_connection_list: named_port_connection_list K_COMMA attribute_instance_list K_DOT "
            "/* port_identifier */ IDENTIFIER K_LPAREN expression_opt K_RPAREN.");
    RULE_BREAK_MACRO
    $$ = $1;
    $$->push_back( parserInstance->parse_NamedPortConnectionList( $5, $7) );
};



/* -----------------------------------------------------------------------
 *  GENERATE CONSTRUCT
 * -----------------------------------------------------------------------
 */

generate_region:
K_generate module_or_generate_item_list K_endgenerate
{
    yydebug("generate_region: K_generate module_or_generate_item_list K_endgenerate.");
    RULE_BREAK_MACRO
    $$ = $2;
};


genvar_declaration:
K_genvar /* list_of_genvar_identifiers */ list_of_identifiers K_SEMICOLON
{
    yydebug("genvar_declaration: K_genvar /* list_of_genvar_identifiers */ list_of_identifiers K_SEMICOLON.");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_GenvarDeclaration($2);
};

/* list_of_genvar_identifiers ::= genvar_identifier { , genvar_identifier } */


// ** VERILOG_AMS **
/* the same of 'analog_loop_statement' */
//analog_loop_generate_statement:
//K_for K_LPAREN genvar_initialization K_SEMICOLON /* genvar_expression */ expression K_SEMICOLON genvar_iteration K_RPAREN analog_statement
//{
//    yyerror("VERILOG-AMS IS NOT YET SUPPORTED: analog_loop_generate_statement");
//};

loop_generate_construct:
K_for K_LPAREN genvar_initialization K_SEMICOLON /* genvar_expression */ expression K_SEMICOLON genvar_iteration K_RPAREN generate_block
{
    yydebug("loop_generate_construct: K_for K_LPAREN genvar_initialization K_SEMICOLON /* genvar_expression */ expression K_SEMICOLON genvar_iteration K_RPAREN generate_block.");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_LoopGenerateConstruct($3, $5, $7, $9);
};


genvar_initialization:
/* genvar_identifier */ IDENTIFIER K_EQ /* constant_expression */ expression
{
    yydebug("genvar_initialization: /* genvar_identifier */ IDENTIFIER K_EQ /* constant_expression */ expression.");
    RULE_BREAK_MACRO
    $$ = parserInstance->getFactory()->assignment(
                parserInstance->getFactory()->identifier($1),
                $3
                );
    free($1);
};


genvar_iteration:
/* genvar_identifier */ IDENTIFIER K_EQ /* genvar_expression */ expression
{
    yydebug("genvar_iteration: /* genvar_identifier */ IDENTIFIER K_EQ /* genvar_expression */ expression.");
    RULE_BREAK_MACRO
    $$ = parserInstance->getFactory()->assignment(
                parserInstance->getFactory()->identifier($1),
                $3
                );
    free($1);
};


conditional_generate_construct:
if_generate_construct
{
    yydebug("conditional_generate_construct: if_generate_construct.");
    RULE_BREAK_MACRO
    $$ = $1;
}
| case_generate_construct
{
    yydebug("conditional_generate_construct: case_generate_construct.");
    yyerror("conditional_generate_construct: case_generate_construct is not supported.");
};


if_generate_construct:
K_if K_LPAREN /* constant_expression */ expression K_RPAREN generate_block_or_null %prec less_than_K_else
{
    yydebug("if_generate_construct: K_if K_LPAREN /* constant_expression */ expression K_RPAREN generate_block_or_null.");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_IfGenerateConstruct($3, $5, nullptr);
}
| K_if K_LPAREN /* constant_expression */ expression K_RPAREN generate_block_or_null K_else generate_block_or_null
{
    yydebug("if_generate_construct: K_if K_LPAREN /* constant_expression */ expression K_RPAREN generate_block_or_null K_else generate_block_or_null.");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_IfGenerateConstruct($3, $5, $7);
};


case_generate_construct:
K_case K_LPAREN /* constant_expression */ expression K_RPAREN case_generate_item case_generate_item_list K_endcase
{
    yydebug("case_generate_construct: K_case K_LPAREN /* constant_expression */ expression K_RPAREN case_generate_item case_generate_item_list K_endcase.");
    yyerror("case_generate_construct: K_case K_LPAREN /* constant_expression */ expression K_RPAREN case_generate_item case_generate_item_list K_endcase is not supported.");
};


case_generate_item:
comma_expression_list K_COLON generate_block_or_null
{
    yydebug("case_generate_item: comma_expression_list K_COLON generate_block_or_null.");
    yyerror("case_generate_item: comma_expression_list K_COLON generate_block_or_null is not supported.");
}
| K_default colon_opt generate_block_or_null
{
    yydebug("case_generate_item: K_default colon_opt generate_block_or_null.");
    yyerror("case_generate_item: K_default colon_opt generate_block_or_null is not supported.");
};


case_generate_item_list:
/* empty */
{
    yydebug("case_generate_item_list: /* empty */");
    yyerror("case_generate_item_list: /* empty */ is not supported.");
}
| case_generate_item_list case_generate_item
{
    yydebug("case_generate_item_list: case_generate_item_list case_generate_item.");
    yyerror("case_generate_item_list: case_generate_item_list case_generate_item is not supported.");
};


colon_opt:
/* empty */
{
    yydebug("colon_opt: /* empty */.");
}
| K_COLON 
{
    yydebug("colon_opt: K_COLON.");
};

generate_block:
module_or_generate_item
{
    yydebug("generate_block: module_or_generate_item.");
    RULE_BREAK_MACRO
    $$ = new generate_block_t();
    $$->module_or_generate_item_list = new std::list<module_or_generate_item_t*>();
    $$->module_or_generate_item_list->push_back($1);
}
| K_begin generate_block_identifier_opt module_or_generate_item_list K_end
{
    yydebug("generate_block: K_begin generate_block_identifier_opt module_or_generate_item_list K_end.");
    RULE_BREAK_MACRO
    std::string id;
    if ($2 != nullptr)
    {
        id = $2;
        free($2);
    }
    $$ = new generate_block_t();
    $$->generate_block_identifier_opt = id;
    $$->module_or_generate_item_list = $3;
};


module_or_generate_item_list:
/* empty */
{
    yydebug("module_or_generate_item_list: /* empty */");
    RULE_BREAK_MACRO
    $$ = new std::list<module_or_generate_item_t*>();
}
| module_or_generate_item_list module_or_generate_item
{
    yydebug("module_or_generate_item_list: module_or_generate_item_list module_or_generate_item.");
    RULE_BREAK_MACRO
    $1->push_back($2);
    $$ = $1;
};


generate_block_identifier_opt:
/* empty */
{
    yydebug("generate_block_identifier_opt: /* empty */");
    RULE_BREAK_MACRO
    $$ = nullptr;
}
| K_COLON IDENTIFIER
{
    yydebug("generate_block_identifier_opt: K_COLON IDENTIFIER.");
    RULE_BREAK_MACRO
    $$ = $2;
};


generate_block_or_null:
generate_block
{
    yydebug("generate_block_or_null: generate_block.");
    RULE_BREAK_MACRO
    $$ = $1;
}
| K_SEMICOLON
{
    yydebug("generate_block_or_null: K_SEMICOLON.");
    yyerror("generate_block_or_null: K_SEMICOLON is not supported.");
};





/* -----------------------------------------------------------------------
 *  UDP DECLARATIOIN AND INSTANTIATION
 * -----------------------------------------------------------------------
 */

udp_declaration:
attribute_instance_list K_primitive /* udp_identifier */ IDENTIFIER K_LPAREN udp_port_list K_RPAREN 
K_SEMICOLON udp_port_declaration_list udp_body K_endprimitive
{
    yydebug("udp_declaration: attribute_instance_list K_primitive /* udp_identifier */ IDENTIFIER "
            "K_LPAREN udp_port_list K_RPAREN K_SEMICOLON udp_port_declaration_list udp_body K_endprimitive.");
    yyerror("udp_declaration: attribute_instance_list K_primitive /* udp_identifier */ IDENTIFIER "
            "K_LPAREN udp_port_list K_RPAREN K_SEMICOLON udp_port_declaration_list udp_body K_endprimitive is not supported.");
}
| attribute_instance_list K_primitive /* udp_identifier */ IDENTIFIER K_LPAREN udp_declaration_port_list 
K_RPAREN K_SEMICOLON udp_body K_endprimitive
{
    yydebug("udp_declaration: attribute_instance_list K_primitive /* udp_identifier */ IDENTIFIER "
            "K_LPAREN udp_port_list K_RPAREN K_SEMICOLON udp_port_declaration_list udp_body K_endprimitive.");
    yyerror("udp_declaration: attribute_instance_list K_primitive /* udp_identifier */ IDENTIFIER "
            "K_LPAREN udp_port_list K_RPAREN K_SEMICOLON udp_port_declaration_list udp_body K_endprimitive is not supported.");
};


udp_port_declaration_list:
udp_port_declaration
{
    yydebug("udp_port_declaration_list: udp_port_declaration.");
    yyerror("udp_port_declaration_list: udp_port_declaration is not supported.");
}
| udp_port_declaration_list udp_port_declaration
{
    yydebug("udp_port_declaration_list: udp_port_declaration_list udp_port_declaration.");
    yyerror("udp_port_declaration_list: udp_port_declaration_list udp_port_declaration is not supported.");
};


udp_port_list:
/* output_port_identifier , input_port_identifier { , input_port_identifier } */
/* output_port_identifier */ IDENTIFIER K_COMMA list_of_identifiers
{
    yydebug("udp_port_list: generate_block.");
    yyerror("udp_port_list: IDENTIFIER K_COMMA list_of_identifiers is not supported.");
};


udp_declaration_port_list:
udp_output_declaration K_COMMA udp_input_declaration_list
{
    yydebug("udp_declaration_port_list: udp_output_declaration K_COMMA udp_input_declaration_list.");
    yyerror("udp_declaration_port_list: udp_output_declaration K_COMMA udp_input_declaration_list is not supported.");
};


udp_input_declaration_list:
udp_input_declaration
{
    yydebug("udp_input_declaration_list: udp_input_declaration.");
    yyerror("udp_input_declaration_list: udp_input_declaration is not supported.");
}
| udp_input_declaration_list K_COMMA udp_input_declaration
{
    yydebug("udp_input_declaration_list: udp_input_declaration_list K_COMMA udp_input_declaration.");
    yyerror("udp_input_declaration_list: udp_input_declaration_list K_COMMA udp_input_declaration is not supported.");
}
| udp_input_declaration_list K_COMMA IDENTIFIER
{
    yydebug("udp_input_declaration_list: udp_input_declaration_list K_COMMA IDENTIFIER.");
    yyerror("udp_input_declaration_list: udp_input_declaration_list K_COMMA IDENTIFIER is not supported.");
};


udp_port_declaration:
udp_output_declaration K_SEMICOLON
{
    yydebug("udp_port_declaration: udp_output_declaration K_SEMICOLON.");
    yyerror("udp_port_declaration: udp_output_declaration K_SEMICOLON is not supported.");
}
| udp_input_declaration_identifiers K_SEMICOLON
{
    yydebug("udp_port_declaration: udp_input_declaration_identifiers K_SEMICOLON.");
    yyerror("udp_port_declaration: udp_input_declaration_identifiers K_SEMICOLON is not supported.");
}
| udp_reg_declaration K_SEMICOLON
{
    yydebug("udp_port_declaration: udp_reg_declaration K_SEMICOLON.");
    yyerror("udp_port_declaration: udp_reg_declaration K_SEMICOLON is not supported.");
};


udp_output_declaration:
attribute_instance_list K_output /* port_identifier */ IDENTIFIER
{
    yydebug("udp_output_declaration: attribute_instance_list K_output /* port_identifier */ IDENTIFIER.");
    yyerror("udp_output_declaration: attribute_instance_list K_output /* port_identifier */ IDENTIFIER is not supported.");
}
// ** VERILOG_AMS **
| attribute_instance_list K_output /* discipline_identifier */ identifier_opt K_reg /* port_identifier */ IDENTIFIER eq_constant_expression_opt
{
    yydebug("udp_output_declaration: attribute_instance_list K_output /* discipline_identifier */ identifier_opt K_reg /* port_identifier */ IDENTIFIER eq_constant_expression_opt.");
    yyerror("udp_output_declaration: attribute_instance_list K_output /* discipline_identifier */ identifier_opt K_reg /* port_identifier */ IDENTIFIER eq_constant_expression_opt is not supported.");
};


udp_input_declaration_identifiers:
attribute_instance_list K_input /* list_of_port_identifiers */ list_of_identifiers
{
    yydebug("udp_input_declaration: attribute_instance_list K_input /* list_of_port_identifiers */ list_of_identifiers.");
    yyerror("udp_input_declaration: attribute_instance_list K_input /* list_of_port_identifiers */ list_of_identifiers is not supported.");
};

udp_input_declaration:
attribute_instance_list K_input /* list_of_port_identifiers */ IDENTIFIER
{
    yydebug("udp_input_declaration: attribute_instance_list K_input /* list_of_port_identifiers */ IDENTIFIER.");
    yyerror("udp_input_declaration: attribute_instance_list K_input /* list_of_port_identifiers */ IDENTIFIER is not supported.");
}

udp_reg_declaration:
attribute_instance_list K_reg /* variable_identifier */ IDENTIFIER
{
    yydebug("udp_reg_declaration: attribute_instance_list K_reg /* discipline_identifier */ identifier_opt /* variable_identifier */ IDENTIFIER.");
    yyerror("udp_reg_declaration: attribute_instance_list K_reg /* discipline_identifier */ identifier_opt /* variable_identifier */ IDENTIFIER is not supported.");
}
// ** VERILOG_AMS **
| attribute_instance_list K_reg /* discipline_identifier */ IDENTIFIER /* variable_identifier */ IDENTIFIER
{
    yydebug("udp_reg_declaration: attribute_instance_list K_reg IDENTIFIER IDENTIFIER");
    yyerror("udp_reg_declaration: attribute_instance_list K_reg IDENTIFIER IDENTIFIER is not supported");
};


//udp_body:
//combinational_body
//{
//    yydebug("udp_body: combinational_body.");
//    yyerror("udp_body: combinational_body is not supported.");
//}
//| sequential_body
//{
//    yydebug("udp_body: sequential_body.");
//    yyerror("udp_body: sequential_body is not supported.");
//};


udp_body:
K_table combinational_entry_list K_endtable
{
    yydebug("udp_body: K_table combinational_entry_list K_endtable");
    yyerror("udp_body: K_table combinational_entry_list K_endtable is not supported");
}
| K_table sequential_entry_list K_endtable
{
    yydebug("udp_body: K_table sequential_entry_list K_endtable");
    yyerror("udp_body: K_table sequential_entry_list K_endtable is not supported");
}
| K_initial /* output_port_identifier */ IDENTIFIER K_EQ number K_SEMICOLON K_table sequential_entry_list K_endtable
{
    yydebug("udp_body: K_initial /* output_port_identifier */ IDENTIFIER K_EQ number K_SEMICOLON K_table sequential_entry_list K_endtable");
    yyerror("udp_body: K_initial /* output_port_identifier */ IDENTIFIER K_EQ number K_SEMICOLON K_table sequential_entry_list K_endtable is not supported");
};




//combinational_body:
//K_table 
//{
//    lex_start_table();
//}
//combinational_entry_list K_endtable
//{
//    lex_end_table();
//};
//
//sequential_body:
//udp_initial_statement_opt K_table 
//{
//    lex_start_table();
//}
//sequential_entry_list K_endtable
//{
//    lex_end_table();
//};

combinational_entry:
/* level_input_list */ level_symbol_list K_COLON output_symbol K_SEMICOLON
{
    yydebug("combinational_entry: level_input_list K_COLON output_symbol K_SEMICOLON.");
    yyerror("combinational_entry: level_input_list K_COLON output_symbol K_SEMICOLON is not supported.");
};

combinational_entry_list:
combinational_entry
{
    yydebug("combinational_entry_list: combinational_entry.");
    yyerror("combinational_entry_list: combinational_entry is not supported.");
}
| combinational_entry_list combinational_entry
{
    yydebug("combinational_entry_list: combinational_entry_list combinational_entry.");
    yyerror("combinational_entry_list: combinational_entry_list combinational_entry is not supported.");
};


sequential_entry_list:
sequential_entry
{
    yydebug("sequential_entry_list: sequential_entry.");
    yyerror("sequential_entry_list: sequential_entry is not supported.");
}
| sequential_entry_list sequential_entry
{
    yydebug("sequential_entry_list: sequential_entry_list sequential_entry.");
    yyerror("sequential_entry_list: sequential_entry_list sequential_entry is not supported.");
};


udp_initial_statement_opt:
/* empty */
{
    yydebug("udp_initial_statement_opt: /* empty */");
    yyerror("udp_initial_statement_opt: /* empty */ is not supported.");
}
| udp_initial_statement
{
    yydebug("udp_initial_statement_opt: udp_initial_statement.");
    yyerror("udp_initial_statement_opt: udp_initial_statement is not supported.");
};


/* NOTE 2:
 * 
 * From verilogLexer.lxx : 
 * "The UDP state table needs some slightly different treatment by the lexer". 
 * So, in the rule udp_initial_statement, init_val can be substituted by number. 
 * 
 * init_val ::= 1'b0 | 1'b1 | 1'bx | 1'bX | 1'B0 | 1'B1 | 1'Bx | 1'BX | 1 | 0 
 * */

udp_initial_statement:
// K_initial output_port_identifier K_EQ init_val K_SEMICOLON
K_initial /* output_port_identifier */ IDENTIFIER K_EQ number K_SEMICOLON
{
    yydebug("udp_initial_statement: K_initial /* output_port_identifier */ IDENTIFIER K_EQ number K_SEMICOLON.");
    yyerror("udp_initial_statement: K_initial /* output_port_identifier */ IDENTIFIER K_EQ number K_SEMICOLON is not supported.");
};


sequential_entry:
/* seq_input_list */ edge_input_level_list K_COLON level_symbol K_COLON next_state K_SEMICOLON
{
    yydebug("sequential_entry: seq_level_input_list K_COLON level_symbol K_COLON next_state K_SEMICOLON.");
    yyerror("sequential_entry: seq_level_input_list K_COLON level_symbol K_COLON next_state K_SEMICOLON is not supported.");
};


//seq_input_list:
//level_input_list
//| edge_input_list;


level_input_list:
level_symbol
{
    yydebug("level_input_list: level_symbol.");
    yyerror("level_input_list: level_symbol is not supported.");
}
| level_input_list level_symbol
{
    yydebug("level_input_list: level_input_list level_symbol.");
    yyerror("level_input_list: level_input_list level_symbol is not supported.");
};

level_symbol_list:
level_symbol
{
    yydebug("level_symbol_list: level_symbol");
    yyerror("level_symbol_list: level_symbol is not supported.");
}
| level_symbol_list level_symbol
{
    yydebug("level_symbol_list: level_symbol_list level_symbol.");
    yyerror("level_symbol_list: level_symbol_list level_symbol is not supported.");
};

edge_input_level_list:
edge_indicator %prec LOW
{
    yydebug("edge_input_level_list: level_symbol_list edge_indicator level_symbol_list.");
    yyerror("edge_input_level_list: level_symbol_list edge_indicator level_symbol_list is not supported.");
}
| edge_indicator level_symbol_list %prec MEDIUM1
{
    yydebug("edge_input_level_list: level_symbol_list edge_indicator level_symbol_list.");
    yyerror("edge_input_level_list: level_symbol_list edge_indicator level_symbol_list is not supported.");
}
| level_symbol_list %prec MEDIUM2
{
    yydebug("edge_input_level_list: level_symbol_list");
    yyerror("edge_input_level_list: level_symbol_list is not supported.");
}
| level_symbol_list edge_indicator %prec MEDIUM3
{
    yydebug("edge_input_level_list: level_symbol_list edge_indicator level_symbol_list.");
    yyerror("edge_input_level_list: level_symbol_list edge_indicator level_symbol_list is not supported.");
}
| level_symbol_list edge_indicator level_symbol_list %prec HIGH
{
    yydebug("edge_input_level_list: level_symbol_list edge_indicator level_symbol_list.");
    yyerror("edge_input_level_list: level_symbol_list edge_indicator level_symbol_list is not supported.");
};


edge_indicator:
K_LPAREN level_symbol level_symbol K_RPAREN
{
    yydebug("edge_indicator: K_LPAREN level_symbol level_symbol K_RPAREN.");
    yyerror("edge_indicator: K_LPAREN level_symbol level_symbol K_RPAREN is not supported.");
}
| edge_symbol
{
    yydebug("edge_indicator: edge_symbol.");
    yyerror("edge_indicator: edge_symbol is not supported.");
};


/* current_state ::= level_symbol */

next_state:
output_symbol
{
    yydebug("next_state: output_symbol");
    yyerror("next_state: output_symbol is not supported");
}
| K_MINUS
{
    yydebug("next_state: K_MINUS");
    yyerror("next_state: K_MINUS is not supported");
};


output_symbol:
'0'
{
    
}
| '1'
{
    
}
| 'x'
{
    
}
| 'X'
{
    
};

level_symbol:
'0'
{
    
}
| '1'
{
    
}
| 'x'
{
    
}
| 'X'
{
    
}
| K_QUEST
{
    
}
| 'b'
{
    
}
| 'B'
{
    
};
  

edge_symbol:
'r'
{
    
}
| 'R'
{
    
}
| 'f'
{
    
}
| 'F'
{
    
}
| 'p'
{
    
}
| 'P'
{
    
}
| 'n'
{
    
}
| 'N'
{
    
}
| K_STAR
{
    
};



udp_instantiation:
/* udp_identifier */ IDENTIFIER udp_instance_list K_SEMICOLON
{
    yydebug("udp_instantiation: /* udp_identifier */ IDENTIFIER drive_strength_opt delay2_opt udp_instance_list K_SEMICOLON.");
    yyerror("udp_instantiation: /* udp_identifier */ IDENTIFIER drive_strength_opt delay2_opt udp_instance_list K_SEMICOLON is not supported.");
}
| /* udp_identifier */ IDENTIFIER drive_strength udp_instance_list K_SEMICOLON
{
    yydebug("udp_instantiation: /* udp_identifier */ IDENTIFIER drive_strength_opt delay2_opt udp_instance_list K_SEMICOLON.");
    yyerror("udp_instantiation: /* udp_identifier */ IDENTIFIER drive_strength_opt delay2_opt udp_instance_list K_SEMICOLON is not supported.");
}
| /* udp_identifier */ IDENTIFIER delay2 udp_instance_list K_SEMICOLON
{
    yydebug("udp_instantiation: /* udp_identifier */ IDENTIFIER drive_strength_opt delay2_opt udp_instance_list K_SEMICOLON.");
    yyerror("udp_instantiation: /* udp_identifier */ IDENTIFIER drive_strength_opt delay2_opt udp_instance_list K_SEMICOLON is not supported.");
}
| /* udp_identifier */ IDENTIFIER drive_strength delay2 udp_instance_list K_SEMICOLON
{
    yydebug("udp_instantiation: /* udp_identifier */ IDENTIFIER drive_strength_opt delay2_opt udp_instance_list K_SEMICOLON.");
    yyerror("udp_instantiation: /* udp_identifier */ IDENTIFIER drive_strength_opt delay2_opt udp_instance_list K_SEMICOLON is not supported.");
};


udp_instance_list:
udp_instance
{
    yydebug("udp_instance_list: udp_instance.");
    yyerror("udp_instance_list: udp_instance is not supported.");
}
| udp_instance_list K_COMMA udp_instance
{
    yydebug("udp_instance_list: udp_instance_list udp_instance.");
    yyerror("udp_instance_list: udp_instance_list udp_instance is not supported.");
};


udp_instance:
K_LPAREN /* output_terminal */ lvalue K_COMMA /* input_terminal_list */ comma_expression_list K_RPAREN
{
    yydebug("udp_instance: K_LPAREN /* output_terminal */ lvalue K_COMMA /* input_terminal_list */ comma_expression_list K_RPAREN.");
    yyerror("udp_instance: K_LPAREN /* output_terminal */ lvalue K_COMMA /* input_terminal_list */ comma_expression_list K_RPAREN is not supported.");
}
| /* name_of_udp_instance */ name_of_instance K_LPAREN /* output_terminal */ lvalue K_COMMA /* input_terminal_list */ comma_expression_list K_RPAREN
{
    yydebug("udp_instance: /* name_of_udp_instance */ name_of_instance K_LPAREN /* output_terminal */ lvalue "
            "K_COMMA /* input_terminal_list */ comma_expression_list K_RPAREN.");
    yyerror("udp_instance: /* name_of_udp_instance */ name_of_instance K_LPAREN /* output_terminal */ lvalue "
            "K_COMMA /* input_terminal_list */ comma_expression_list K_RPAREN is not supported.");
}
;



/* -----------------------------------------------------------------------
 *  BEHAVIORAL STATEMENTS
 *  
 *  CONTINUOUS ASSIGNMENT STATEMENTS
 * -----------------------------------------------------------------------
 */

continuous_assign:
K_assign drive_strength_opt delay3_opt list_of_net_assignments K_SEMICOLON
{
    yydebug("continuous_assign: K_assign drive_strength_opt delay3_opt list_of_net_assignments K_SEMICOLON.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ContinuousAssign($3, $4);
};


list_of_net_assignments:
/* net_assignment */ assignment
{
    yydebug("list_of_net_assignments: /* net_assignment */ assignment.");
    RULE_BREAK_MACRO
    $$ = new BList<Assign>();
    //$1->addProperty(NONBLOCKING_ASSIGNMENT);
    $$->push_back( $1 );
}
| list_of_net_assignments K_COMMA /* net_assignment */ assignment
{
    yydebug("list_of_net_assignments: list_of_net_assignments K_COMMA /* net_assignment */ assignment.");
    RULE_BREAK_MACRO
    $$ = $1;
    //$3->addProperty(NONBLOCKING_ASSIGNMENT);
    $$->push_back( $3 );
};


//net_assignment:
//lvalue K_EQ expression
//{
//    yydebug("net_assignment: lvalue K_EQ expression.");
//    yyerror("net_assignment: lvalue K_EQ expression is not supported.");
//};


/* -----------------------------------------------------------------------
 *  PROCEDURAL BLOCKS AND ASSIGNMENTS
 * -----------------------------------------------------------------------
 */

// ** VERILOG_AMS ** -->
analog_construct:
K_analog analog_statement
{
    yydebug("analog_construct: K_analog analog_statement");
    RULE_BREAK_MACRO
    parserInstance->setCurrentBlockCodeInfo( $1 );
    $$ = parserInstance->parse_AnalogConstruct( $2 );
}
| K_analog K_initial analog_function_statement
{
    yydebug("analog_construct: K_analog K_initial analog_function_statement");
    yyerror("analog_construct: K_analog K_initial analog_function_statement is not supported");
};

analog_procedural_assignment:
analog_variable_assignment K_SEMICOLON
{
    yydebug("analog_procedural_assignment: analog_variable_assignment K_SEMICOLON");   
    RULE_BREAK_MACRO $$ = $1;
};

analog_variable_assignment:
analog_variable_lvalue K_EQ /* analog_expression */ expression
{
    yydebug("analog_variable_assignment: analog_variable_lvalue K_EQ /* analog_expression */ expression");
    RULE_BREAK_MACRO $$ = parserInstance->parse_AnalogVariableAssignment( $1, $3 );
};

analog_variable_lvalue:
/* variable_identifier */ IDENTIFIER
{
    yydebug("analog_variable_lvalue: IDENTIFIER");
    RULE_BREAK_MACRO
    $$ = new Identifier($1);
    parserInstance->setCodeInfo( $$ );
    free($1);
}
| /* variable_identifier */ IDENTIFIER /* analog_bracket_expression_list */ bracket_expression_list
{
    yydebug("analog_variable_lvalue: IDENTIFIER bracket_expression_list");
    RULE_BREAK_MACRO $$ = parserInstance->parse_PrimaryListOfMemberOrSlice( $1, $2 );
};

// <-- ** VERILOG_AMS **

initial_construct:
K_initial statement
{
    yydebug("initial_construct: K_initial statement.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_InitialConstruct( $2 );
};


always_construct:
K_always statement
{
    yydebug("always_construct: K_always statement.");
    RULE_BREAK_MACRO
    parserInstance->setCurrentBlockCodeInfo( $1 );
    $$ = parserInstance->parse_AlwaysConstruct( $2 );
};


blocking_assignment:
lvalue K_EQ expression
{
   yydebug("blocking_assignment: lvalue K_EQ expression.");
   RULE_BREAK_MACRO $$ = parserInstance->parse_BlockingAssignment($1, $3, nullptr);
}
| lvalue K_EQ delay_or_event_control expression
{
   yydebug("blocking_assignment: lvalue K_EQ delay_or_event_control expression.");
   RULE_BREAK_MACRO $$ = parserInstance->parse_BlockingAssignment($1, $4, $3);
};



nonblocking_assignment:
lvalue K_LE expression
{
    yydebug("nonblocking_assignment: lvalue K_LE expression.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_NonBlockingAssignment( $1, $3, nullptr );
}
| lvalue K_LE delay_or_event_control expression
{
    yydebug("nonblocking_assignment: lvalue K_LE delay_or_event_control expression.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_NonBlockingAssignment( $1, $4, $3 );
};


procedural_continuous_assignments:
K_assign /* variable_assignment */ assignment
{
    yydebug("procedural_continuous_assignments: K_assign /* variable_assignment */ assignment.");
    yyerror("procedural_continuous_assignments: K_assign /* variable_assignment */ assignment is not supported.");
}
| K_deassign lvalue
{
    yydebug("procedural_continuous_assignments: K_deassign lvalue.");
    yyerror("procedural_continuous_assignments: K_deassign lvalue is not supported.");
}
| K_force assignment
{
    yydebug("procedural_continuous_assignments: K_force assignment.");
    yywarning("procedural_continuous_assignments: force assignment keyword is ignored.");
    $$ = $2;
}
| K_release lvalue
{
    yydebug("procedural_continuous_assignments: K_release lvalue.");
    yywarning("procedural_continuous_assignments: release keyword is ignored.");
};
//| K_force variable_assignment
//| K_force net_assignment
//| K_release variable_lvalue
//| K_release net_lvalue;


//variable_assignment:
assignment:
lvalue K_EQ expression
{
    yydebug("assignment: lvalue K_EQ expression.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_Assignment( $1, $3 );
};



/* -----------------------------------------------------------------------
 *  PARALLEL AND SEQUENTIAL BLOCKS
 * -----------------------------------------------------------------------
 */

// ** VERILOG_AMS ** -->
analog_seq_block:
K_begin K_end
{
    yydebug("analog_seq_block: K_begin K_end");     
    RULE_BREAK_MACRO
    $$ = new analog_statement_t();
    $$->skipped = true;
}
| K_begin analog_statement_no_empty_list K_end
{
    yydebug("analog_seq_block: K_begin analog_statement_no_empty_list K_end");     
    RULE_BREAK_MACRO $$ = parserInstance->parse_AnalogSeqBlock(nullptr, nullptr, $2);
}
| K_begin K_COLON /* analog_block_identifier */ IDENTIFIER analog_block_item_declaration_list K_end
{
    yydebug("analog_seq_block: K_begin K_COLON /* analog_block_identifier */ IDENTIFIER analog_block_item_declaration_list K_end");     
    RULE_BREAK_MACRO $$ = parserInstance->parse_AnalogSeqBlock($3, $4, nullptr);
}
| K_begin K_COLON /* analog_block_identifier */ IDENTIFIER analog_block_item_declaration_list analog_statement_no_empty_list K_end
{
    yydebug("analog_seq_block: K_begin K_COLON /* analog_block_identifier */ IDENTIFIER analog_block_item_declaration_list K_end");     
    RULE_BREAK_MACRO $$ = parserInstance->parse_AnalogSeqBlock($3, $4, $5);
};

analog_event_seq_block:
K_begin K_end
{
    yydebug("analog_event_seq_block: K_begin K_end");
    RULE_BREAK_MACRO
    $$ = new analog_statement_t();
    $$->skipped = true;
}
| K_begin analog_event_statement_no_empty_list K_end
{
    yydebug("analog_event_seq_block: K_begin analog_event_statement_no_empty_list K_end");
    RULE_BREAK_MACRO $$ = parserInstance->parse_AnalogSeqBlock(nullptr, nullptr, $2);
}
| K_begin K_COLON /* analog_block_identifier */ IDENTIFIER analog_block_item_declaration_list K_end
{
    yydebug("analog_event_seq_block: K_begin K_COLON /* analog_block_identifier */ IDENTIFIER analog_block_item_declaration_list K_end");
    RULE_BREAK_MACRO $$ = parserInstance->parse_AnalogSeqBlock($3, $4, nullptr);
}
| K_begin K_COLON /* analog_block_identifier */ IDENTIFIER analog_block_item_declaration_list analog_event_statement_no_empty_list K_end
{
    yydebug("analog_event_seq_block: K_begin K_COLON /* analog_block_identifier */ IDENTIFIER analog_block_item_declaration_list analog_event_statement_no_empty_list K_end");
    RULE_BREAK_MACRO $$ = parserInstance->parse_AnalogSeqBlock($3, $4, $5);
};

analog_function_seq_block:
K_begin K_end
{
    yydebug("analog_function_seq_block: K_begin K_end");
    RULE_BREAK_MACRO
    $$ = new analog_statement_t();
    $$->skipped = true;
}
| K_begin analog_function_statement_no_empty_list K_end
{
    yydebug("analog_function_seq_block: K_begin analog_function_statement_no_empty_list K_end");
    RULE_BREAK_MACRO $$ = parserInstance->parse_AnalogSeqBlock(nullptr, nullptr, $2);
}
| K_begin K_COLON /* analog_block_identifier */ IDENTIFIER analog_block_item_declaration_list K_end
{
    yydebug("analog_function_seq_block: K_begin K_COLON /* analog_block_identifier */ IDENTIFIER analog_block_item_declaration_list K_end");
    RULE_BREAK_MACRO $$ = parserInstance->parse_AnalogSeqBlock($3, $4, nullptr);
}
| K_begin K_COLON /* analog_block_identifier */ IDENTIFIER analog_block_item_declaration_list analog_function_statement_no_empty_list K_end
{
    yydebug("analog_function_seq_block: K_begin K_COLON /* analog_block_identifier */ IDENTIFIER analog_block_item_declaration_list analog_function_statement_no_empty_list K_end");
    RULE_BREAK_MACRO $$ = parserInstance->parse_AnalogSeqBlock($3, $4, $5);
};
// <-- ** VERILOG_AMS **


par_block:
K_fork K_join
{
    yydebug("par_block: K_fork K_join");
    yyerror("par_block: K_fork K_join is not supported");
}
| K_fork statement_no_empty_list K_join
{
    yydebug("par_block: K_fork statement_no_empty_list K_join");
    yyerror("par_block: K_fork statement_no_empty_list K_join is not supported");
}
| K_fork K_COLON /* block_identifier */ IDENTIFIER block_item_declaration_list K_join
{
    yydebug("par_block: K_fork K_COLON /* block_identifier */ IDENTIFIER block_item_declaration_list K_join");
    yyerror("par_block: K_fork K_COLON /* block_identifier */ IDENTIFIER block_item_declaration_list K_join is not supported");
}
| K_fork K_COLON /* block_identifier */ IDENTIFIER block_item_declaration_list statement_no_empty_list K_join
{
    yydebug("par_block: K_fork K_COLON /* block_identifier */ IDENTIFIER block_item_declaration_list statement_no_empty_list K_join");
    yyerror("par_block: K_fork K_COLON /* block_identifier */ IDENTIFIER block_item_declaration_list statement_no_empty_list K_join is not supported");
};

seq_block:
K_begin K_end
{
    yydebug("seq_block: K_begin K_end");
    RULE_BREAK_MACRO $$ = parserInstance->parse_SeqBlock( nullptr, nullptr, nullptr );
}
| K_begin statement_no_empty_list K_end
{
    yydebug("seq_block: K_begin statement_no_empty_list K_end");
    RULE_BREAK_MACRO $$ = parserInstance->parse_SeqBlock( nullptr, nullptr, $2 );
}
| K_begin K_COLON /* block_identifier */ IDENTIFIER block_item_declaration_list K_end
{
    yydebug("seq_block: K_begin K_COLON /* block_identifier */ IDENTIFIER block_item_declaration_list K_end");
    RULE_BREAK_MACRO $$ = parserInstance->parse_SeqBlock( $3, $4, nullptr );
}
| K_begin K_COLON /* block_identifier */ IDENTIFIER block_item_declaration_list statement_no_empty_list K_end
{
    yydebug("seq_block: K_begin K_COLON /* block_identifier */ IDENTIFIER block_item_declaration_list statement_no_empty_list K_end");
    RULE_BREAK_MACRO $$ = parserInstance->parse_SeqBlock( $3, $4, $5 );
};



/* -----------------------------------------------------------------------
 *  STATEMENTS
 * -----------------------------------------------------------------------
 */

// ** VERILOG_AMS ** -->
analog_statement:
attribute_instance_list analog_loop_statement
{
    yydebug("analog_statement: attribute_instance_list analog_loop_statement");
    RULE_BREAK_MACRO
    analog_statement_t * ret = new analog_statement_t();
    ret->analog_loop_statement = $2;
    $$ = ret;
}
//| attribute_instance_list analog_loop_generate_statement
| attribute_instance_list analog_case_statement
{
    yydebug("analog_statement: attribute_instance_list analog_case_statement");
    RULE_BREAK_MACRO
    $$ = new analog_statement_t();
    $$->analog_case_statement = $2;
}
| attribute_instance_list analog_conditional_statement
{
    yydebug("analog_statement: attribute_instance_list analog_conditional_statement");
    RULE_BREAK_MACRO
    $$ = new analog_statement_t();
    $$->analog_conditional_statement = $2;
}
| attribute_instance_list analog_procedural_assignment
{
    yydebug("analog_statement: attribute_instance_list analog_procedural_assignment");
    RULE_BREAK_MACRO
    $$ = new analog_statement_t();
    $$->analog_procedural_assignment = $2;
}
| attribute_instance_list analog_seq_block
{
    yydebug("analog_statement: attribute_instance_list analog_seq_block");
    RULE_BREAK_MACRO $$ = $2;
//    $$ = new analog_statement_t();
//    if ($2->size() > 0)
//        $$->analog_seq_block = $2;
//    else
//        $$->skipped = true;
}
| attribute_instance_list /*analog_system_task_enable*/ system_task_enable
{
    yydebug("analog_statement: attribute_instance_list system_task_enable");
    RULE_BREAK_MACRO
    $$ = new analog_statement_t();
    $$->system_task_enable = $2;
}
| attribute_instance_list contribution_statement
{
    yydebug("analog_statement: attribute_instance_list contribution_statement");
    RULE_BREAK_MACRO
    $$ = new analog_statement_t();
    $$->contribution_statement = $2;
}
| attribute_instance_list indirect_contribution_statement
{
    yydebug("analog_statement: attribute_instance_list indirect_contribution_statement");
    RULE_BREAK_MACRO
    $$ = new analog_statement_t();
    $$->indirect_contribution_statement = $2;
}
| attribute_instance_list analog_event_control_statement
{
    yydebug("analog_statement: attribute_instance_list analog_event_control_statement");
    RULE_BREAK_MACRO $$ = $2;
};

analog_statement_no_empty_list:
analog_statement
{
    yydebug("analog_statement_no_empty_list: analog_statement");
    RULE_BREAK_MACRO
    $$ = new std::list<analog_statement_t*>();
    $$->push_back( $1 );
}
| analog_statement_no_empty_list analog_statement
{
    yydebug("analog_statement_no_empty_list: analog_statement_no_empty_list analog_statement");
    RULE_BREAK_MACRO
    $$ = $1;
    $$->push_back( $2 );
};

analog_statement_or_null:
analog_statement
{
    yydebug("analog_statement_or_null: analog_statement");
    RULE_BREAK_MACRO $$ = $1;
}
| attribute_instance_list K_SEMICOLON
{
    yydebug("analog_statement_or_null: attribute_instance_list K_SEMICOLON");
    RULE_BREAK_MACRO
    $$ = new analog_statement_t();
    $$->skipped = true;
};

analog_event_statement:
attribute_instance_list analog_loop_statement
{
    yydebug("analog_event_statement: attribute_instance_list analog_loop_statement");
    RULE_BREAK_MACRO
    $$ = new analog_statement_t();
    $$->analog_loop_statement = $2;
}
| attribute_instance_list analog_case_statement
{
    yydebug("analog_event_statement: attribute_instance_list analog_case_statement");
    RULE_BREAK_MACRO
    $$ = new analog_statement_t();
    $$->analog_case_statement = $2;
}
| attribute_instance_list analog_conditional_statement
{
    yydebug("analog_event_statement: attribute_instance_list analog_conditional_statement");
    RULE_BREAK_MACRO
    $$ = new analog_statement_t();
    $$->analog_conditional_statement = $2;
}
| attribute_instance_list analog_procedural_assignment
{
    yydebug("analog_event_statement: attribute_instance_list analog_procedural_assignment");
    RULE_BREAK_MACRO
    $$ = new analog_statement_t();
    $$->analog_procedural_assignment = $2;
}
| attribute_instance_list analog_event_seq_block
{
    yydebug("analog_event_statement: attribute_instance_list analog_event_seq_block");
    RULE_BREAK_MACRO $$ = $2;
}
| attribute_instance_list /*analog_system_task_enable*/ system_task_enable
{
    yydebug("analog_event_statement: attribute_instance_list system_task_enable");
    RULE_BREAK_MACRO
    $$ = new analog_statement_t();
    $$->system_task_enable = $2;
}
| attribute_instance_list disable_statement
{
    yydebug("analog_event_statement: attribute_instance_list disable_statement");
    yydebug("analog_event_statement: attribute_instance_list disable_statement is not supported");
}
| attribute_instance_list event_trigger
{
    yydebug("analog_event_statement: attribute_instance_list event_trigger");
    yyerror("analog_event_statement: attribute_instance_list event_trigger is not supported");
}
| attribute_instance_list K_SEMICOLON
{
    yydebug("analog_event_statement: attribute_instance_list K_SEMICOLON");
    RULE_BREAK_MACRO
    $$ = new analog_statement_t();
    $$->skipped = true;
};

analog_event_statement_no_empty_list:
analog_event_statement
{
    yydebug("analog_event_statement_no_empty_list: analog_event_statement");
    RULE_BREAK_MACRO
    $$ = new std::list<analog_statement_t*>();
    $$->push_back( $1 );
}
| analog_event_statement_no_empty_list analog_event_statement
{
    yydebug("analog_event_statement_no_empty_list: analog_event_statement_no_empty_list analog_event_statement");
    RULE_BREAK_MACRO
    $$ = $1;
    $$->push_back( $2 );
};


analog_function_statement:
attribute_instance_list analog_function_case_statement
{
    yydebug("analog_function_statement: attribute_instance_list analog_function_case_statement");
    yyerror("analog_function_statement: attribute_instance_list analog_function_case_statement is not supported");
}
| attribute_instance_list analog_function_conditional_statement
{
    yydebug("analog_function_statement: attribute_instance_list analog_function_conditional_statement");
    RULE_BREAK_MACRO
    $$ = new analog_statement_t();
    $$->analog_conditional_statement = $2;
}
| attribute_instance_list analog_function_loop_statement
{
    yydebug("analog_function_statement: attribute_instance_list analog_function_loop_statement");
    yyerror("analog_function_statement: attribute_instance_list analog_function_loop_statement is not supported");
}
| attribute_instance_list analog_function_seq_block
{
    yydebug("analog_function_statement: attribute_instance_list analog_function_seq_block");
    RULE_BREAK_MACRO $$ = $2;
}
| attribute_instance_list analog_procedural_assignment
{
    yydebug("analog_function_statement: attribute_instance_list analog_procedural_assignment");
    RULE_BREAK_MACRO
    $$ = new analog_statement_t();
    $$->analog_procedural_assignment = $2;
}
| attribute_instance_list /*analog_system_task_enable*/ system_task_enable
{
    yydebug("analog_function_statement: attribute_instance_list /*analog_system_task_enable*/ system_task_enable");
    RULE_BREAK_MACRO
    $$ = new analog_statement_t();
    $$->system_task_enable = $2;
};

analog_function_statement_no_empty_list:
analog_function_statement
{
    yydebug("analog_function_statement_no_empty_list: analog_function_statement");
    RULE_BREAK_MACRO
    $$ = new std::list<analog_statement_t*>();
    $$->push_back( $1 );
}
| analog_function_statement_no_empty_list analog_function_statement
{
    yydebug("analog_function_statement_no_empty_list: analog_function_statement_no_empty_list analog_function_statement");
    RULE_BREAK_MACRO
    $$ = $1;
    $$->push_back( $2 );
};

analog_function_statement_or_null:
analog_function_statement
{
    yydebug("analog_function_statement_or_null: analog_function_statement");
    RULE_BREAK_MACRO $$ = $1;
}
| attribute_instance_list K_SEMICOLON
{
    yydebug("analog_function_statement_or_null: attribute_instance_list K_SEMICOLON");
    RULE_BREAK_MACRO
    $$ = new analog_statement_t();
    $$->skipped = true;
};

// <-- ** VERILOG_AMS **

statement:
attribute_instance_list blocking_assignment K_SEMICOLON
{
    yydebug("statement: attribute_instance_list blocking_assignment K_SEMICOLON.");
    RULE_BREAK_MACRO
    $$ = new statement_t();
    $$->blocking_assignment = $2;
    if ( $2 == nullptr ) $$->skipped = true;
}
| attribute_instance_list case_statement
{
    yydebug("statement: attribute_instance_list case_statement.");
    RULE_BREAK_MACRO
    $$ = new statement_t();
    $$->case_statement = $2;
    if ( $2 == nullptr ) $$->skipped = true;
}
| attribute_instance_list conditional_statement
{
    yydebug("statement: attribute_instance_list conditional_statement.");
    RULE_BREAK_MACRO
    $$ = new statement_t();
    $$->conditional_statement = parserInstance->parse_ConditionalStatement($2);
    if ( $2 == nullptr ) $$->skipped = true;
}
| attribute_instance_list disable_statement
{
    yydebug("statement: attribute_instance_list disable_statement.");
    RULE_BREAK_MACRO
    $$ = new statement_t();
    $$->disable_statement = $2;
}
| attribute_instance_list event_trigger
{
    yydebug("statement: attribute_instance_list event_trigger.");
    RULE_BREAK_MACRO
    $$ = new statement_t();
    $$->event_trigger = $2;
    if ( $2 == nullptr ) $$->skipped = true;
}
| attribute_instance_list loop_statement
{
    yydebug("statement: attribute_instance_list loop_statement.");
    RULE_BREAK_MACRO
    $$ = new statement_t();
    $$->loop_statement = $2;
    if ( $2 == nullptr ) $$->skipped = true;
}
| attribute_instance_list nonblocking_assignment K_SEMICOLON
{
    yydebug("statement: attribute_instance_list nonblocking_assignment K_SEMICOLON.");
    RULE_BREAK_MACRO
    $$ = new statement_t();
    $$->nonblocking_assignment = $2;
    if ( $2 == nullptr ) $$->skipped = true;
}
| attribute_instance_list par_block
{
    yydebug("statement: attribute_instance_list par_block.");
    yyerror("statement: attribute_instance_list par_block is not supported.");
}
| attribute_instance_list procedural_continuous_assignments K_SEMICOLON
{
    yydebug("statement: attribute_instance_list procedural_continuous_assignments K_SEMICOLON.");
    RULE_BREAK_MACRO
    $$ = new statement_t();
    $$->blocking_assignment = $2;
    if ( $2 == nullptr ) $$->skipped = true;
}
| attribute_instance_list procedural_timing_control_statement
{
    yydebug("statement: attribute_instance_list procedural_timing_control_statement.");
    RULE_BREAK_MACRO $$ = $2;
}
| attribute_instance_list seq_block
{
    yydebug("statement: attribute_instance_list seq_block.");
    RULE_BREAK_MACRO $$ = $2;
}
| attribute_instance_list system_task_enable
{
    yydebug("statement: attribute_instance_list system_task_enable.");
    RULE_BREAK_MACRO
    $$ = new statement_t();
    $$->system_task_enable = $2;
    if ($2 == nullptr) $$->skipped = true;
}
| attribute_instance_list task_enable
{
    yydebug("statement: attribute_instance_list task_enable.");
    RULE_BREAK_MACRO
    $$ = new statement_t();
    $$->task_enable = $2;
    if ($2 == nullptr) $$->skipped = true;
}
| attribute_instance_list wait_statement
{
    yydebug("statement: attribute_instance_list wait_statement.");
    RULE_BREAK_MACRO
    $$ = $2;
};


statement_no_empty_list:
statement
{
    yydebug("statement_no_empty_list: statement");
    RULE_BREAK_MACRO
    $$ = new std::list<statement_t*>();
    $$->push_back( $1 );
}
| statement_no_empty_list statement
{
    yydebug("statement_no_empty_list: statement_no_empty_list statement.");
    RULE_BREAK_MACRO
    $$ = $1;
    $$->push_back( $2 );
};

statement_or_null:
statement
{
    yydebug("statement_or_null: statement.");
    RULE_BREAK_MACRO $$ = $1;
}
| attribute_instance_list K_SEMICOLON
{
    yydebug("statement_or_null: attribute_instance_list K_SEMICOLON.");
    RULE_BREAK_MACRO $$ = nullptr;
};


/* 
 * function_statement1 ::= statement
 * function_statement ::= statement
 **/ 



/* -----------------------------------------------------------------------
 *  TIMING CONTROL STATEMENTS
 * -----------------------------------------------------------------------
 */

// ** VERILOG_AMS ** -->

analog_event_control_statement:
analog_event_control analog_event_statement
{
    yydebug("analog_event_control_statement: /*analog_event_control*/ event_control analog_event_statement");
    RULE_BREAK_MACRO $$ = parserInstance->parse_AnalogEventControlStatement($1, $2);
};

analog_event_control:
K_AT /* hierarchical_event_identifier */ hierarchical_identifier
{
    yydebug("analog_event_control: K_AT /* hierarchical_event_identifier */ hierarchical_identifier");
    RULE_BREAK_MACRO
    $$ = new analog_event_control_t();
    $$->event_identifier = $2;
}
| K_AT K_LPAREN analog_event_expression K_RPAREN
{
    yydebug("analog_event_control: K_AT K_LPAREN analog_event_expression K_RPAREN");
    RULE_BREAK_MACRO
    $$ = new analog_event_control_t();
    $$->analog_event_expression = $3;
};

//analysis_identifier_list:
//'"' /* analysis_identifier */ IDENTIFIER '"'
//{    yyerror("VERILOG-AMS IS NOT YET SUPPORTED: analysis_identifier_list 1");     }
//| analysis_identifier_list K_COMMA '"' /* analysis_identifier */ IDENTIFIER '"'
//{    yyerror("VERILOG-AMS IS NOT YET SUPPORTED: analysis_identifier_list 2");     };

analog_event_expression:
expression
{
    yydebug("analog_event_expression: expression.");
    RULE_BREAK_MACRO
    $$ = new analog_event_expression_t();
    $$->expression = $1;
}
| K_posedge expression
{
    yydebug("analog_event_expression: K_posedge expression.");
    RULE_BREAK_MACRO
    $$ = new analog_event_expression_t();
    $2->addProperty( PROPERTY_SENSITIVE_POS );
    $$->posedgeExpression = $2;
}
| K_negedge expression
{
    yydebug("analog_event_expression: K_negedge expression.");
    RULE_BREAK_MACRO
    $$ = new analog_event_expression_t();
    $2->addProperty( PROPERTY_SENSITIVE_NEG );
    $$->negedgeExpression = $2;
}
// NOTE: expression -> primary -> hierarchical_identifier
//| /* hierarchical_event_identifier */ hierarchical_identifier
| K_initial_step
{
    yydebug("analog_event_expression: K_initial_step");
    RULE_BREAK_MACRO
    $$ = new analog_event_expression_t();
    $$->or_analog_event_expression = new BList<Value>();
    $$->or_analog_event_expression->push_back(
                parserInstance->parse_InitialOrFinalStep("initial_step", nullptr));
}
| K_initial_step K_LPAREN /*analysis_identifier_list*/ string_list K_RPAREN
{
    yydebug("analog_event_expression: K_initial_step K_LPAREN string_list K_RPAREN");
    RULE_BREAK_MACRO
    $$ = new analog_event_expression_t();
    $$->or_analog_event_expression = new BList<Value>();
    $$->or_analog_event_expression->push_back(
                parserInstance->parse_InitialOrFinalStep("initial_step", $3));}
| K_final_step
{
    yydebug("analog_event_expression: K_final_step");
    RULE_BREAK_MACRO
    $$ = new analog_event_expression_t();
    $$->or_analog_event_expression = new BList<Value>();
    $$->or_analog_event_expression->push_back(
                parserInstance->parse_InitialOrFinalStep("final_step", nullptr));
}
| K_final_step K_LPAREN /*analysis_identifier_list*/ string_list K_RPAREN
{
    yydebug("analog_event_expression: K_final_step K_LPAREN string_list K_RPAREN");
    RULE_BREAK_MACRO
    $$ = new analog_event_expression_t();
    $$->or_analog_event_expression = new BList<Value>();
    $$->or_analog_event_expression->push_back(
                parserInstance->parse_InitialOrFinalStep("final_step", $3));
}
| analog_event_functions
{
    yydebug("analog_event_expression: analog_event_functions");
    RULE_BREAK_MACRO
    $$ = new analog_event_expression_t();
    $$->or_analog_event_expression = new BList<Value>();
    $$->or_analog_event_expression->push_back($1);
}
| analog_event_expression K_or analog_event_expression
{
    yydebug("analog_event_expression: analog_event_expression K_or analog_event_expression");
    RULE_BREAK_MACRO
    $$ = parserInstance->parseOrAnalogEventExpression($1, $3);
}
| analog_event_expression K_COMMA analog_event_expression
{
    yydebug("analog_event_expression: analog_event_expression K_COMMA analog_event_expression");
    RULE_BREAK_MACRO
    $$ = parserInstance->parseOrAnalogEventExpression($1, $3);
};

analog_event_functions:
K_cross K_LPAREN /* analog_expression */ expression K_RPAREN %prec LOW
{
    yydebug("analog_event_functions: K_cross K_LPAREN /* analog_expression */ expression K_RPAREN");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_analogEventFunction("cross", $3);
}
| K_cross K_LPAREN /* analog_expression */ expression K_COMMA analog_expression_or_null K_RPAREN
{
    yydebug("analog_event_functions: K_cross K_LPAREN /* analog_expression */ expression K_COMMA analog_expression_or_null K_RPAREN");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_analogEventFunction("cross", $3, $5);
}
| K_cross K_LPAREN /* analog_expression */ expression K_COMMA analog_expression_or_null K_COMMA constant_expression_or_null K_RPAREN
{
    yydebug("analog_event_functions: K_cross K_LPAREN /* analog_expression */ expression K_COMMA analog_expression_or_null K_COMMA constant_expression_or_null K_RPAREN");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_analogEventFunction("cross", $3, $5, $7);
}
| K_cross K_LPAREN /* analog_expression */ expression K_COMMA analog_expression_or_null K_COMMA constant_expression_or_null K_COMMA constant_expression_or_null K_RPAREN
{
    yydebug("analog_event_functions: K_cross K_LPAREN /* analog_expression */ expression K_COMMA analog_expression_or_null K_COMMA constant_expression_or_null K_COMMA constant_expression_or_null K_RPAREN");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_analogEventFunction("cross", $3, $5, $7, $9);
}
| K_cross K_LPAREN /* analog_expression */ expression K_COMMA analog_expression_or_null K_COMMA constant_expression_or_null K_COMMA constant_expression_or_null K_COMMA /* analog_expression */ expression K_RPAREN
{
    yydebug("analog_event_functions: K_cross K_LPAREN /* analog_expression */ expression K_COMMA analog_expression_or_null K_COMMA constant_expression_or_null K_COMMA constant_expression_or_null K_COMMA /* analog_expression */ expression K_RPAREN");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_analogEventFunction("cross", $3, $5, $7, $9, $11);
}
| K_above K_LPAREN /* analog_expression */ expression K_RPAREN
{
    yydebug("analog_event_functions: K_above K_LPAREN /* analog_expression */ expression K_RPAREN");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_analogEventFunction("above", $3);
}
| K_above K_LPAREN /* analog_expression */ expression K_COMMA constant_expression_or_null K_RPAREN
{
    yydebug("analog_event_functions: K_above K_LPAREN /* analog_expression */ expression K_COMMA constant_expression_or_null K_RPAREN");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_analogEventFunction("above", $3, $5);
}
| K_above K_LPAREN /* analog_expression */ expression K_COMMA constant_expression_or_null K_COMMA constant_expression_or_null K_RPAREN
{
    yydebug("analog_event_functions: K_above K_LPAREN /* analog_expression */ expression K_COMMA constant_expression_or_null K_COMMA constant_expression_or_null K_RPAREN");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_analogEventFunction("above", $3, $5, $7);
}
| K_above K_LPAREN /* analog_expression */ expression K_COMMA constant_expression_or_null K_COMMA constant_expression_or_null K_COMMA /* analog_expression */ expression K_RPAREN
{
    yydebug("analog_event_functions: K_above K_LPAREN /* analog_expression */ expression K_COMMA constant_expression_or_null K_COMMA constant_expression_or_null K_COMMA /* analog_expression */ expression K_RPAREN");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_analogEventFunction("above", $3, $5, $7, $9);
}
| K_timer K_LPAREN /* analog_expression */ expression K_RPAREN
{
    yydebug("analog_event_functions: K_timer K_LPAREN /* analog_expression */ expression K_RPAREN");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_analogEventFunction("timer", $3);
}
| K_timer K_LPAREN /* analog_expression */ expression K_COMMA analog_expression_or_null K_RPAREN
{
    yydebug("analog_event_functions: K_timer K_LPAREN /* analog_expression */ expression K_COMMA analog_expression_or_null K_RPAREN");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_analogEventFunction("timer", $3, $5);
}
| K_timer K_LPAREN /* analog_expression */ expression K_COMMA analog_expression_or_null K_COMMA constant_expression_or_null K_RPAREN
{
    yydebug("analog_event_functions: K_timer K_LPAREN /* analog_expression */ expression K_COMMA analog_expression_or_null K_COMMA constant_expression_or_null K_RPAREN");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_analogEventFunction("timer", $3, $5, $7);
}
| K_timer K_LPAREN /* analog_expression */ expression K_COMMA analog_expression_or_null K_COMMA constant_expression_or_null K_COMMA /* analog_expression */ expression K_RPAREN
{
    yydebug("analog_event_functions: K_timer K_LPAREN /* analog_expression */ expression K_COMMA analog_expression_or_null K_COMMA constant_expression_or_null K_COMMA /* analog_expression */ expression K_RPAREN");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_analogEventFunction("timer", $3, $5, $7, $9);
}
| K_absdelta K_LPAREN /* analog_expression */ expression K_COMMA expression K_RPAREN
{
    yydebug("analog_event_functions: K_absdelta K_LPAREN /* analog_expression */ expression K_COMMA");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_analogEventFunction("absdelta", $3, $5);
}
| K_absdelta K_LPAREN /* analog_expression */ expression K_COMMA expression K_COMMA constant_expression_or_null K_RPAREN
{
    yydebug("analog_event_functions: K_absdelta K_LPAREN /* analog_expression */ expression K_COMMA analog_expression_or_null K_COMMA constant_expression_or_null K_RPAREN");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_analogEventFunction("absdelta", $3, $5, $7);
}
| K_absdelta K_LPAREN /* analog_expression */ expression K_COMMA expression K_COMMA constant_expression_or_null K_COMMA constant_expression_or_null K_RPAREN
{
    yydebug("analog_event_functions: K_absdelta K_LPAREN /* analog_expression */ expression K_COMMA analog_expression_or_null K_COMMA constant_expression_or_null K_COMMA constant_expression_or_null K_RPAREN");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_analogEventFunction("absdelta", $3, $5, $7, $9);
}
| K_absdelta K_LPAREN /* analog_expression */ expression K_COMMA expression K_COMMA constant_expression_or_null K_COMMA constant_expression_or_null K_COMMA /* analog_expression */ expression K_RPAREN
{
    yydebug("analog_event_functions: K_absdelta K_LPAREN /* analog_expression */ expression K_COMMA analog_expression_or_null K_COMMA constant_expression_or_null K_COMMA constant_expression_or_null K_COMMA /* analog_expression */ expression K_RPAREN");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_analogEventFunction("absdelta", $3, $5, $7, $9, $11);
};

analog_expression_or_null:
/* empty */
{
    yydebug("analog_expression_or_null: /* empty */");
    RULE_BREAK_MACRO $$ = nullptr;
}
| /* analog_expression */ expression
{
    yydebug("analog_expression_or_null: expression");
    RULE_BREAK_MACRO $$ = $1;
};

// <-- ** VERILOG_AMS **


delay_control:
K_SHARP delay_value
{
    yydebug("delay_control: K_SHARP delay_value.");
    RULE_BREAK_MACRO $$ = $2;
}
| K_SHARP K_LPAREN mintypmax_expression K_RPAREN
{
    yydebug("delay_control: K_SHARP K_LPAREN mintypmax_expression K_RPAREN.");
    RULE_BREAK_MACRO $$ = $3;
};

delay_or_event_control:
delay_control
{
    yydebug("delay_or_event_control: delay_control.");
    RULE_BREAK_MACRO $$ = $1;
}
| event_control
{
    yydebug("delay_or_event_control: event_control.");
    yyerror("delay_or_event_control: event_control is not supported.");
}
| K_repeat K_LPAREN expression K_RPAREN event_control
{
    yydebug("delay_or_event_control: K_repeat K_LPAREN expression K_RPAREN event_control.");
    yyerror("delay_or_event_control: K_repeat K_LPAREN expression K_RPAREN event_control is not supported.");
};


disable_statement:
/*
 * | disable hierarchical_task_identifier ;
 * | disable hierarchical_block_identifier ;
 */
K_disable hierarchical_identifier K_SEMICOLON
{
    yydebug("disable_statement: K_disable hierarchical_identifier K_SEMICOLON.");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_DisableStatement( $2 );
};


event_control:
K_AT /* hierarchical_event_identifier */ hierarchical_identifier
{
    yydebug("event_control: K_AT /* hierarchical_event_identifier */ hierarchical_identifier.");
    RULE_BREAK_MACRO
    $$ = new event_control_t();
    $$->event_identifier = $2;
}
| K_AT K_LPAREN event_expression_list K_RPAREN
{
    yydebug("event_control: K_AT K_LPAREN event_expression K_RPAREN.");
    RULE_BREAK_MACRO
    $$ = new event_control_t();
    $$->event_expression_list = $3;
}
| K_ATSTAR
{
    yydebug("event_control: K_ATSTAR.");
    RULE_BREAK_MACRO
    $$ = new event_control_t();
    $$->event_all = true;
}
| K_AT /* K_LPAREN K_STAR K_RPAREN */ K_PSTARP
{
    yydebug("event_control: K_AT K_PSTARP.");
    RULE_BREAK_MACRO
    $$ = new event_control_t();
    $$->event_all = true;
};


event_trigger:
K_TRIGGER /* hierarchical_event_identifier */ hierarchical_identifier K_SEMICOLON %prec LOW
{
    yydebug("event_trigger: K_TRIGGER /* hierarchical_event_identifier */ hierarchical_identifier bracket_expression_list_opt K_SEMICOLON.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_EventTrigger( $2, nullptr );
}
| K_TRIGGER /* hierarchical_event_identifier */ hierarchical_identifier bracket_expression_list K_SEMICOLON %prec HIGH
{
    yydebug("event_trigger: K_TRIGGER /* hierarchical_event_identifier */ hierarchical_identifier bracket_expression_list_opt K_SEMICOLON.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_EventTrigger( $2, $3 );
};


event_expression:
expression
{
    yydebug("event_expression: expression.");
    RULE_BREAK_MACRO
    $$ = new event_expression_t();
    $$->expression = $1;
}
| K_posedge expression
{
    yydebug("event_expression: K_posedge expression.");
    RULE_BREAK_MACRO
    $$ = new event_expression_t();
    $2->addProperty( PROPERTY_SENSITIVE_POS );
    $$->posedgeExpression = $2;
}
| K_negedge expression
{
    yydebug("event_expression: K_negedge expression.");
    RULE_BREAK_MACRO
    $$ = new event_expression_t();
    $2->addProperty( PROPERTY_SENSITIVE_NEG );
    $$->negedgeExpression = $2;
}
// ** VERILOG_AMS ** -->
| analog_event_functions
{
    yydebug("event_expression: analog_event_functions");
    RULE_BREAK_MACRO
    $$ = new event_expression_t();
    $$->expression = $1;
}
| K_driver_update expression
{
    yydebug("event_expression: K_driver_update expression");
    RULE_BREAK_MACRO $$ = parserInstance->parse_EventExpressionDriverUpdate( $2 );
}
//| event_expression K_or event_expression
//{
//    yydebug("event_expression: event_expression K_or event_expression");
//    yyerror("event_expression: event_expression K_or event_expression is not supported");
//}
//
// NOTE: expression -> hierarchical_identifier -> IDENTIFIER bracket_range_expression_list
//| analog_variable_lvalue
// <-- ** VERILOG_AMS **
;

event_expression_list:
event_expression
{
    yydebug("event_expression_list: event_expression.");
    RULE_BREAK_MACRO
    $$ = new std::list<event_expression_t*>();
    $$->push_back( $1 );
}
| event_expression_list K_or event_expression
{
    yydebug("event_expression_list: event_expression_list K_or event_expression.");
    RULE_BREAK_MACRO
    $$ = $1;
    $$->push_back( $3 );
}
| event_expression_list K_COMMA event_expression
{
    yydebug("event_expression_list: event_expression_list K_COMMA event_expression.");
    RULE_BREAK_MACRO
    $$ = $1;
    $$->push_back( $3 );
};

procedural_timing_control:
delay_control
{
    yydebug("procedural_timing_control: delay_control.");
    RULE_BREAK_MACRO
    $$ = new procedural_timing_control_t();
    $$->delay_control = $1;
}
| event_control
{
    yydebug("procedural_timing_control: event_control.");
    RULE_BREAK_MACRO
    $$ = new procedural_timing_control_t();
    $$->event_control = $1;
};


procedural_timing_control_statement:
procedural_timing_control statement_or_null
{
    yydebug("procedural_timing_control_statement: procedural_timing_control statement_or_null.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ProceduralTimingControlStatement( $1, $2 );
};


wait_statement:
K_wait K_LPAREN expression K_RPAREN statement_or_null
{
    yydebug("wait_statement: K_wait K_LPAREN expression K_RPAREN statement_or_null.");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_WaitStatement( $3, $5 );
};



/* -----------------------------------------------------------------------
 *  CONDITIONAL STATEMENTS
 * -----------------------------------------------------------------------
 */

// ** VERILOG_AMS ** -->

analog_conditional_statement:
K_if K_LPAREN /* analog_expression */ expression K_RPAREN analog_statement_or_null %prec less_than_K_else
{
    yydebug("analog_conditional_statement: K_if K_LPAREN /* analog_expression */ expression K_RPAREN analog_statement_or_null");
    RULE_BREAK_MACRO
    parserInstance->setCurrentBlockCodeInfo( $1 );
    $$ = parserInstance->parse_AnalogConditionalStatement( $3, $5, nullptr );
}
| K_if K_LPAREN /* analog_expression */ expression K_RPAREN analog_statement_or_null K_else analog_statement_or_null
{
    yydebug("analog_conditional_statement: K_if K_LPAREN /* analog_expression */ expression K_RPAREN analog_statement_or_null K_else analog_statement_or_null");
    RULE_BREAK_MACRO
    parserInstance->setCurrentBlockCodeInfo( $1 );
    $$ = parserInstance->parse_AnalogConditionalStatement( $3, $5, $7 );
};

analog_function_conditional_statement:
K_if K_LPAREN /* analog_expression */ expression K_RPAREN analog_function_statement_or_null %prec less_than_K_else
{
    yydebug("analog_function_conditional_statement: K_if K_LPAREN /* analog_expression */ expression "
            "K_RPAREN analog_function_statement_or_null");
    RULE_BREAK_MACRO
    parserInstance->setCurrentBlockCodeInfo( $1 );
    $$ = parserInstance->parse_AnalogConditionalStatement( $3, $5, nullptr );
}
| K_if K_LPAREN /* analog_expression */ expression K_RPAREN analog_function_statement_or_null K_else analog_function_statement_or_null
{
    yydebug("analog_function_conditional_statement: K_if K_LPAREN /* analog_expression */ expression "
            "K_RPAREN analog_function_statement_or_null K_else analog_function_statement_or_null");
    RULE_BREAK_MACRO
    parserInstance->setCurrentBlockCodeInfo( $1 );
    $$ = parserInstance->parse_AnalogConditionalStatement( $3, $5, $7 );
};

// <-- ** VERILOG_AMS **

conditional_statement:
K_if K_LPAREN expression K_RPAREN statement_or_null %prec less_than_K_else
{
    yydebug("conditional_statement: K_if K_LPAREN expression K_RPAREN statement_or_null");
    RULE_BREAK_MACRO
    parserInstance->setCurrentBlockCodeInfo( $1 );
    $$ = parserInstance->parse_ConditionalStatement( $3, $5, nullptr );
}
| K_if K_LPAREN expression K_RPAREN statement_or_null K_else statement_or_null
{
    yydebug("conditional_statement: K_if K_LPAREN expression K_RPAREN statement_or_null K_else statement_or_null");
    RULE_BREAK_MACRO
    parserInstance->setCurrentBlockCodeInfo( $1 );
    $$ = parserInstance->parse_ConditionalStatement( $3, $5, $7 );
};

  
/* -----------------------------------------------------------------------
 *  CASE STATEMENTS
 * -----------------------------------------------------------------------
 */

// ** VERILOG_AMS ** -->

analog_case_statement:
K_case K_LPAREN /* analog_expression */ expression K_RPAREN analog_case_item_list K_endcase
{
    yydebug("analog_case_statement: K_case K_LPAREN /* analog_expression */ expression K_RPAREN analog_case_item_list K_endcase");
    RULE_BREAK_MACRO
    parserInstance->setCurrentBlockCodeInfo( $1 );
    $$ = parserInstance->parse_CaseStatement( $3, $5, hif::CASE_LITERAL);
}
| K_casez K_LPAREN /* analog_expression */ expression K_RPAREN analog_case_item_list K_endcase
{
    yydebug("analog_case_statement: K_casez K_LPAREN /* analog_expression */ expression K_RPAREN analog_case_item_list K_endcase");
    RULE_BREAK_MACRO
    parserInstance->setCurrentBlockCodeInfo( $1 );
    $$ = parserInstance->parse_CaseStatement( $3, $5, hif::CASE_Z);
}
| K_casex K_LPAREN /* analog_expression */ expression K_RPAREN analog_case_item_list K_endcase
{
    yydebug("analog_case_statement: K_casex K_LPAREN /* analog_expression */ expression K_RPAREN analog_case_item_list K_endcase");
    RULE_BREAK_MACRO
    parserInstance->setCurrentBlockCodeInfo( $1 );
    $$ = parserInstance->parse_CaseStatement( $3, $5, hif::CASE_X);
};

analog_case_item:
/* analog_expression_comma_list */ comma_expression_list K_COLON analog_statement_or_null
{
    yydebug("analog_case_item: comma_expression_list K_COLON analog_statement_or_null");
    RULE_BREAK_MACRO $$ = parserInstance->parse_AnalogCaseItem( $1, $3);
}
| K_default colon_opt analog_statement_or_null
{
    yydebug("analog_case_item: K_default colon_opt analog_statement_or_null");
    RULE_BREAK_MACRO $$ = parserInstance->parse_AnalogCaseItem( nullptr, $3 );
};

analog_case_item_list:
analog_case_item
{
    yydebug("analog_case_item_list: analog_case_item");
    RULE_BREAK_MACRO
    $$ = new BList<SwitchAlt>();
    $$->push_back($1);
}
| analog_case_item_list analog_case_item
{
    yydebug("analog_case_item_list: analog_case_item_list analog_case_item");
    RULE_BREAK_MACRO
    $$ = $1;
    $$->push_back($2);
};

analog_function_case_statement:
K_case K_LPAREN /* analog_expression */ expression K_RPAREN analog_function_case_item_list K_endcase
{
    yyerror("VERILOG-AMS IS NOT YET SUPPORTED: analog_function_case_statement 1");
};

analog_function_case_item_list:
analog_function_case_item
{
    yyerror("VERILOG-AMS IS NOT YET SUPPORTED: analog_function_case_item_list 1");
}
| analog_function_case_item_list analog_function_case_item
{
    yyerror("VERILOG-AMS IS NOT YET SUPPORTED: analog_function_case_item_list 2");
};

analog_expression_list:
/* analog_expression */ expression
{
    yydebug("analog_expression_list: expression");
    yyerror("analog_expression_list: expression is not supported");
}
| analog_expression_list /* analog_expression */ expression
{
    yydebug("analog_expression_list: analog_expression_list expression");
    yyerror("analog_expression_list: analog_expression_list expression is not supported");
};

analog_function_case_item:
analog_expression_list K_COLON analog_function_statement_or_null
{
    yyerror("VERILOG-AMS IS NOT YET SUPPORTED: analog_function_case_item 1");
}
| K_default colon_opt analog_function_statement_or_null
{
    yyerror("VERILOG-AMS IS NOT YET SUPPORTED: analog_function_case_item 2");
};

// <-- ** VERILOG_AMS **

case_statement:
K_case K_LPAREN expression K_RPAREN case_item_list K_endcase
{
    yydebug("case_statement: K_case K_LPAREN expression K_RPAREN case_item_list K_endcase.");
    RULE_BREAK_MACRO
    parserInstance->setCurrentBlockCodeInfo( $1 );
    $$ = parserInstance->parse_CaseStatement( $3, $5, hif::CASE_LITERAL);
}
| K_casez K_LPAREN expression K_RPAREN case_item_list K_endcase
{
    yydebug("case_statement: K_casez K_LPAREN expression K_RPAREN case_item_list K_endcase.");
    RULE_BREAK_MACRO
    parserInstance->setCurrentBlockCodeInfo( $1 );
    $$ = parserInstance->parse_CaseStatement( $3, $5, hif::CASE_Z);
}
| K_casex K_LPAREN expression K_RPAREN case_item_list K_endcase
{
    yydebug("case_statement: K_casex K_LPAREN expression K_RPAREN case_item_list K_endcase.");
    RULE_BREAK_MACRO
    parserInstance->setCurrentBlockCodeInfo( $1 );
    $$ = parserInstance->parse_CaseStatement( $3, $5, hif::CASE_X);
};


case_item:
comma_expression_list K_COLON statement_or_null
{
    yydebug("case_item: comma_expression_list K_COLON statement_or_null.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_CaseItem( $1, $3);
}
| K_default colon_opt statement_or_null
{
    yydebug("case_item: K_default colon_opt statement_or_null.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_CaseItem( nullptr, $3 );
};


case_item_list:
case_item
{
    yydebug("case_item_list: case_item.");
    RULE_BREAK_MACRO
    $$ = new BList<SwitchAlt>();
    $$->push_back($1);
}
| case_item_list case_item
{
    yydebug("case_item_list: case_item_list case_item.");
    RULE_BREAK_MACRO
    $$ = $1;
    $$->push_back($2);
};




/* -----------------------------------------------------------------------
 *  LOOPING STATEMENTS
 * -----------------------------------------------------------------------
 */

loop_statement:
K_forever statement
{
    yydebug("loop_statement: K_forever statement.");
    RULE_BREAK_MACRO
    parserInstance->setCurrentBlockCodeInfo( $1 );
    $$ = parserInstance->parse_LoopStatementForever( $2 );
}
| K_repeat K_LPAREN expression K_RPAREN statement
{
    yydebug("loop_statement: K_repeat K_LPAREN expression K_RPAREN statement.");
    RULE_BREAK_MACRO
    parserInstance->setCurrentBlockCodeInfo( $1 );
    $$ = parserInstance->parse_LoopStatementRepeat( $3, $5 );
}
| K_while K_LPAREN expression K_RPAREN statement
{
    yydebug("loop_statement: K_while K_LPAREN expression K_RPAREN statement.");
    RULE_BREAK_MACRO
    parserInstance->setCurrentBlockCodeInfo( $1 );
    $$ = parserInstance->parse_LoopStatementWhile( $3, $5 );
}
| K_for K_LPAREN /* variable_assignment */ assignment K_SEMICOLON expression K_SEMICOLON /* variable_assignment */ assignment K_RPAREN statement
{
    yydebug("loop_statement: K_for K_LPAREN /* variable_assignment */ assignment K_SEMICOLON expression "
            "K_SEMICOLON /* variable_assignment */ assignment K_RPAREN statement.");
    RULE_BREAK_MACRO
    parserInstance->setCurrentBlockCodeInfo( $1 );
    $$ = parserInstance->parse_LoopStatementFor( $3, $5, $7, $9);
};

// ** VERILOG_AMS ** -->

analog_loop_statement:
K_repeat K_LPAREN /* analog_expression */ expression K_RPAREN analog_statement
{
    yydebug("analog_loop_statement: K_repeat K_LPAREN /* analog_expression */ expression K_RPAREN analog_statement");
    RULE_BREAK_MACRO
    parserInstance->setCurrentBlockCodeInfo( $1 );
    $$ = parserInstance->parse_LoopStatementRepeat( $3, $5 );
}
| K_while K_LPAREN /* analog_expression */ expression K_RPAREN analog_statement
{
    yydebug("analog_loop_statement: K_repeat K_LPAREN /* analog_expression */ expression K_RPAREN analog_statement");
    RULE_BREAK_MACRO
    parserInstance->setCurrentBlockCodeInfo( $1 );
    $$ = parserInstance->parse_LoopStatementWhile( $3, $5 );
}
| K_for K_LPAREN analog_variable_assignment K_SEMICOLON /* analog_expression */ expression K_SEMICOLON analog_variable_assignment K_RPAREN analog_statement
{
    yydebug("analog_loop_statement: K_for K_LPAREN analog_variable_assignment K_SEMICOLON /* analog_expression */ "
            "expression K_SEMICOLON analog_variable_assignment K_RPAREN analog_statement");
    RULE_BREAK_MACRO
    parserInstance->setCurrentBlockCodeInfo( $1 );
    $$ = parserInstance->parse_LoopStatementFor( $3, $5, $7, $9);
};


analog_function_loop_statement:
K_repeat K_LPAREN /* analog_expression */ expression K_RPAREN analog_function_statement
{
    yydebug("analog_function_loop_statement: K_repeat K_LPAREN /* analog_expression */ expression K_RPAREN analog_function_statement");
    yyerror("analog_function_loop_statement: K_repeat K_LPAREN /* analog_expression */ expression K_RPAREN analog_function_statement is not supported");
}
| K_while K_LPAREN /* analog_expression */ expression K_RPAREN analog_function_statement
{
    yydebug("analog_function_loop_statement: K_while K_LPAREN /* analog_expression */ expression K_RPAREN analog_function_statement");
    yyerror("analog_function_loop_statement: K_while K_LPAREN /* analog_expression */ expression K_RPAREN analog_function_statement is not supported");
}
| K_for K_LPAREN analog_variable_assignment K_SEMICOLON /* analog_expression */ expression K_SEMICOLON analog_variable_assignment K_RPAREN analog_function_statement
{ 
    yydebug("analog_function_loop_statement: K_for K_LPAREN analog_variable_assignment K_SEMICOLON expression "
            "K_SEMICOLON analog_variable_assignment K_RPAREN analog_function_statement");
    yyerror("analog_function_loop_statement: K_for K_LPAREN analog_variable_assignment K_SEMICOLON expression "
            "K_SEMICOLON analog_variable_assignment K_RPAREN analog_function_statement is not supported");
};

// <-- ** VERILOG_AMS **




/* -----------------------------------------------------------------------
 *  TASK ENABLE STATEMENTS
 * -----------------------------------------------------------------------
 */

system_task_enable:
/* system_task_identifier */ SYSTEM_IDENTIFIER K_SEMICOLON
{
    yydebug("system_task_enable: /* system_task_identifier */ SYSTEM_IDENTIFIER K_SEMICOLON.");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_SystemTaskEnable( $1, nullptr, nullptr );
    free( $1 );
}
| /* system_task_identifier */ SYSTEM_IDENTIFIER K_LPAREN expression_opt expression_comma_list K_RPAREN K_SEMICOLON
{
    yydebug("system_task_enable: /* system_task_identifier */ SYSTEM_IDENTIFIER K_LPAREN expression_opt expression_comma_list K_RPAREN K_SEMICOLON.");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_SystemTaskEnable( $1, $3, $4 );
    free( $1 );
};


task_enable:
/* hierarchical_task_identifier [ ( expression { , expression } ) ] ; */
/* hierarchical_task_identifier */ hierarchical_identifier K_LPAREN comma_expression_list K_RPAREN K_SEMICOLON
{
    yydebug("task_enable: hierarchical_identifier K_LPAREN comma_expression_list K_RPAREN K_SEMICOLON.");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_TaskEnable( $1, $3 );
}
| /* hierarchical_task_identifier */ hierarchical_identifier K_LPAREN K_RPAREN K_SEMICOLON
{
    yydebug("task_enable: hierarchical_identifier K_LPAREN K_RPAREN K_SEMICOLON.");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_TaskEnable( $1, nullptr );
}
| /* hierarchical_task_identifier */ hierarchical_identifier K_SEMICOLON
{
    yydebug("task_enable: hierarchical_identifier K_SEMICOLON.");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_TaskEnable( $1, nullptr );
};


task_enable_expression_opt:
/* empty */
{
    yydebug("task_enable_expression_opt: /* empty */");
	RULE_BREAK_MACRO
    $$ = nullptr;
}
// TODO
| K_LPAREN comma_expression_list K_RPAREN
{
    yydebug("task_enable_expression_opt: K_LPAREN expression_list K_RPAREN.");
	RULE_BREAK_MACRO
    $$ = $2;
};


//system_task_enable_expression_opt:
///* empty */
//{
//    yydebug("system_task_enable_expression_opt: /* empty */");
//    RULE_BREAK_MACRO
//}
//| K_LPAREN expression_opt expression_comma_list K_RPAREN
//{
//    yydebug("system_task_enable_expression_opt: K_LPAREN expression_opt expression_comma_list K_RPAREN.");
//    RULE_BREAK_MACRO
//    yywarning("system_task_enable_expression_opt: K_LPAREN expression_opt expression_comma_list K_RPAREN is not supported.");
//    delete $2;
//    delete $3;
//    // TODO: see rule 'expression_comma_list'
//};


expression_comma_list:
/* empty */
{
    yydebug("expression_comma_list: /* empty */");
    RULE_BREAK_MACRO $$ = new BList<Value>();
}
| expression_comma_list K_COMMA expression_opt
{
    yydebug("expression_comma_list: expression_comma_list K_COMMA expression_opt.");
    RULE_BREAK_MACRO
    $$ = $1;
    $1->push_back($3);
};


expression_opt:
/* empty */
{
    yydebug("expression_opt: /* empty */");
    RULE_BREAK_MACRO $$ = nullptr;
}
| expression
{
    yydebug("expression_opt: expression.");
    RULE_BREAK_MACRO $$ = $1;
};



/* -----------------------------------------------------------------------
 *  TASK ENABLE STATEMENTS ( ** VERILOG_AMS ** )
 * -----------------------------------------------------------------------
 */

contribution_statement:
/* branch_lvalue */ branch_probe_function_call K_CONTRIB /* analog_expression */ expression K_SEMICOLON
{
    yydebug("contribution_statement");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_ContributionStatement($1, $3);
};

indirect_contribution_statement:
/* branch_lvalue */ branch_probe_function_call K_COLON indirect_expression K_EQEQ /* analog_expression */ expression K_SEMICOLON
{
     yydebug("indirect_contribution_statement");
     RULE_BREAK_MACRO
     $$ = parserInstance->parse_IndirectContributionStatement($1, $3, $5);
};



/* -----------------------------------------------------------------------
 *  SPECIFY SECTION
 *  
 *  SPECIFY BLOCK DECLARATION
 * -----------------------------------------------------------------------
 */

specify_block:
K_specify specify_item_list K_endspecify
{
    yydebug("specify_block: K_specify specify_item_list K_endspecify.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_SpecifyBlock( $2 );
};


specify_item:
specparam_declaration
{
    yydebug("specify_item: specparam_declaration.");
    yyerror("specify_item: specparam_declaration is not supported.");
}
| pulsestyle_declaration
{
    yydebug("specify_item: pulsestyle_declaration.");
    yyerror("specify_item: pulsestyle_declaration is not supported.");
}
| showcancelled_declaration
{
    yydebug("specify_item: showcancelled_declaration.");
    yyerror("specify_item: showcancelled_declaration is not supported.");
}
//| path_declaration
//{
//    yydebug("specify_item: path_declaration.");
//    yyerror("specify_item: path_declaration is not supported.");
//}
| system_timing_check
{
    yydebug("specify_item: system_timing_check.");
    RULE_BREAK_MACRO
    $$ = new specify_item_t();
    $$->system_timing_check = $1;
};


specify_item_list:
/* empty */
{
    yydebug("specify_item_list: /* empty */");
    RULE_BREAK_MACRO $$ = new std::list<specify_item_t*>();
}
| specify_item_list specify_item
{
    yydebug("specify_item_list: specify_item_list specify_item.");
    RULE_BREAK_MACRO
    $$ = $1;
    $$->push_back( $2 );
};



pulsestyle_declaration:
K_pulsestyle_onevent list_of_path_outputs K_SEMICOLON
{
    yydebug("pulsestyle_declaration: K_pulsestyle_onevent list_of_path_outputs K_SEMICOLON.");
    yyerror("pulsestyle_declaration: K_pulsestyle_onevent list_of_path_outputs K_SEMICOLON is not supported.");
}
| K_pulsestyle_ondetect list_of_path_outputs K_SEMICOLON
{
    yydebug("pulsestyle_declaration: K_pulsestyle_ondetect list_of_path_outputs K_SEMICOLON.");
    yyerror("pulsestyle_declaration: K_pulsestyle_ondetect list_of_path_outputs K_SEMICOLON is not supported.");
};


showcancelled_declaration:
K_showcancelled list_of_path_outputs K_SEMICOLON
{
    yydebug("showcancelled_declaration: K_showcancelled list_of_path_outputs K_SEMICOLON.");
    yyerror("showcancelled_declaration: K_showcancelled list_of_path_outputs K_SEMICOLON is not supported.");
}
| K_noshowcancelled list_of_path_outputs K_SEMICOLON
{
    yydebug("showcancelled_declaration: K_noshowcancelled list_of_path_outputs K_SEMICOLON.");
    yyerror("showcancelled_declaration: K_noshowcancelled list_of_path_outputs K_SEMICOLON is not supported.");
};


/* -----------------------------------------------------------------------
 *  SPECIFY PATH DECLARATION
 * -----------------------------------------------------------------------
 */

//path_declaration:
//simple_path_declaration K_SEMICOLON
//| edge_sensitive_path_declaration K_SEMICOLON
//| state_dependent_path_declaration K_SEMICOLON;


//simple_path_declaration:
//parallel_path_description K_EQ path_delay_value
//| full_path_description K_EQ path_delay_value;


//parallel_path_description:
//K_LPAREN specify_input_terminal_descriptor polarity_operator_opt K_EG specify_output_terminal_descriptor K_RPAREN
//{
//    yydebug("parallel_path_description: K_LPAREN specify_input_terminal_descriptor polarity_operator_opt K_EG specify_output_terminal_descriptor K_RPAREN.");
//    yyerror("parallel_path_description: K_LPAREN specify_input_terminal_descriptor polarity_operator_opt K_EG specify_output_terminal_descriptor K_RPAREN is not supported.");
//};
//
//
//full_path_description:
//K_LPAREN list_of_path_inputs polarity_operator_opt K_SG list_of_path_outputs K_RPAREN
//{
//    yydebug("full_path_description: K_LPAREN list_of_path_inputs polarity_operator_opt K_SG list_of_path_outputs K_RPAREN.");
//    yyerror("full_path_description: K_LPAREN list_of_path_inputs polarity_operator_opt K_SG list_of_path_outputs K_RPAREN is not supported.");
//};


//list_of_path_inputs:
//specify_input_terminal_descriptor_list
//{
//    yydebug("list_of_path_inputs: specify_input_terminal_descriptor_list.");
//    yyerror("list_of_path_inputs: specify_input_terminal_descriptor_list is not supported.");
//};


list_of_path_outputs:
specify_output_terminal_descriptor_list
{
    yydebug("list_of_path_outputs: specify_output_terminal_descriptor_list.");
    yyerror("list_of_path_outputs: specify_output_terminal_descriptor_list is not supported.");
};


//specify_input_terminal_descriptor_list:
//specify_input_terminal_descriptor
//{
//    yydebug("specify_input_terminal_descriptor_list: specify_input_terminal_descriptor.");
//    yyerror("specify_input_terminal_descriptor_list: specify_input_terminal_descriptor is not supported.");
//}
//| specify_input_terminal_descriptor_list K_COMMA specify_input_terminal_descriptor
//{
//    yydebug("specify_input_terminal_descriptor_list: specify_input_terminal_descriptor_list K_COMMA specify_input_terminal_descriptor.");
//    yyerror("specify_input_terminal_descriptor_list: specify_input_terminal_descriptor_list K_COMMA specify_input_terminal_descriptor is not supported.");
//};


specify_output_terminal_descriptor_list:
specify_output_terminal_descriptor
{
    yydebug("specify_output_terminal_descriptor_list: specify_output_terminal_descriptor.");
    yyerror("specify_output_terminal_descriptor_list: specify_output_terminal_descriptor is not supported.");
}
| specify_output_terminal_descriptor_list K_COMMA specify_output_terminal_descriptor
{
    yydebug("specify_output_terminal_descriptor_list: specify_output_terminal_descriptor_list K_COMMA specify_output_terminal_descriptor.");
    yyerror("specify_output_terminal_descriptor_list: specify_output_terminal_descriptor_list K_COMMA specify_output_terminal_descriptor is not supported.");
};





/* -----------------------------------------------------------------------
 *  SPECIFY BLOCK TERMINALS
 * -----------------------------------------------------------------------
 */

specify_input_terminal_descriptor:
/* input_identifier */ IDENTIFIER constant_bracket_range_expression_opt
{
    yydebug("specify_input_terminal_descriptor: /* input_identifier */ IDENTIFIER constant_bracket_range_expression_opt.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_SpecifyTerminalDescriptor($1, $2);
};


specify_output_terminal_descriptor:
/* output_identifier */ IDENTIFIER constant_bracket_range_expression_opt
{
    yydebug("specify_output_terminal_descriptor: /* output_identifier */ IDENTIFIER constant_bracket_range_expression_opt.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_SpecifyTerminalDescriptor($1, $2);
};


// input_identifier ::= input_port_identifier | inout_port_identifier
// output_identifier ::= output_port_identifier | inout_port_identifier





/* -----------------------------------------------------------------------
 *  SPECIFY PATH DELAYS
 * -----------------------------------------------------------------------
 */

//path_delay_value:
//list_of_path_delay_expressions
//| K_LPAREN list_of_path_delay_expressions K_RPAREN;


//list_of_path_delay_expressions:
///* t_path_delay_expression */ constant_mintypmax_expression
//| /* trise_path_delay_expression */ constant_mintypmax_expression K_COMMA 
///* tfall_path_delay_expression */ constant_mintypmax_expression
//| /* trise_path_delay_expression */ constant_mintypmax_expression K_COMMA 
///* tfall_path_delay_expression */ constant_mintypmax_expression K_COMMA 
///*  tz_path_delay_expression */ constant_mintypmax_expression
//| /* t01_path_delay_expression */  constant_mintypmax_expression K_COMMA 
///* t10_path_delay_expression */ constant_mintypmax_expression K_COMMA 
///*  t0z_path_delay_expression */ constant_mintypmax_expression K_COMMA
///* tz1_path_delay_expression */ constant_mintypmax_expression K_COMMA 
///* t1z_path_delay_expression */  constant_mintypmax_expression K_COMMA 
///* tz0_path_delay_expression */constant_mintypmax_expression
//| /* t01_path_delay_expression */ constant_mintypmax_expression K_COMMA 
///* t10_path_delay_expression */  constant_mintypmax_expression K_COMMA 
///* t0z_path_delay_expression */ constant_mintypmax_expression K_COMMA
///* tz1_path_delay_expression */ constant_mintypmax_expression K_COMMA 
///* t1z_path_delay_expression */  constant_mintypmax_expression K_COMMA 
///* tz0_path_delay_expression */ constant_mintypmax_expression K_COMMA
///* t0x_path_delay_expression */ constant_mintypmax_expression K_COMMA 
///* tx1_path_delay_expression */  constant_mintypmax_expression K_COMMA 
///* t1x_path_delay_expression */ constant_mintypmax_expression K_COMMA
///* tx0_path_delay_expression */ constant_mintypmax_expression K_COMMA 
///* txz_path_delay_expression */  constant_mintypmax_expression K_COMMA 
///* tzx_path_delay_expression */ constant_mintypmax_expression;


/*
 * t_path_delay_expression ::= path_delay_expression
 * trise_path_delay_expression ::= path_delay_expression
 * tfall_path_delay_expression ::= path_delay_expression
 * tz_path_delay_expression ::= path_delay_expression
 * t01_path_delay_expression ::= path_delay_expression
 * t10_path_delay_expression ::= path_delay_expression
 * t0z_path_delay_expression ::= path_delay_expression
 * tz1_path_delay_expression ::= path_delay_expression
 * t1z_path_delay_expression ::= path_delay_expression
 * tz0_path_delay_expression ::= path_delay_expression
 * t0x_path_delay_expression ::= path_delay_expression
 * tx1_path_delay_expression ::= path_delay_expression
 * t1x_path_delay_expression ::= path_delay_expression
 * tx0_path_delay_expression ::= path_delay_expression
 * txz_path_delay_expression ::= path_delay_expression
 * tzx_path_delay_expression ::= path_delay_expression
 * 
 * path_delay_expression ::= constant_mintypmax_expression
 */


//edge_sensitive_path_declaration:
//parallel_edge_sensitive_path_description K_EQ path_delay_value
//| full_edge_sensitive_path_description K_EQ path_delay_value;


//parallel_edge_sensitive_path_description:
//K_LPAREN edge_identifier_opt specify_input_terminal_descriptor K_EG
//K_LPAREN specify_output_terminal_descriptor polarity_operator_opt K_COLON /* data_source_expression */ expression K_RPAREN K_RPAREN
//{
//    yydebug("parallel_edge_sensitive_path_description: K_LPAREN edge_identifier_opt specify_input_terminal_descriptor K_EG "
//            "K_LPAREN specify_output_terminal_descriptor polarity_operator_opt K_COLON /* data_source_expression */ expression K_RPAREN K_RPAREN");
//    yyerror("parallel_edge_sensitive_path_description: K_LPAREN edge_identifier_opt specify_input_terminal_descriptor K_EG "
//            "K_LPAREN specify_output_terminal_descriptor polarity_operator_opt K_COLON /* data_source_expression */ expression K_RPAREN K_RPAREN is not supported.");
//};


//full_edge_sensitive_path_description:
//K_LPAREN edge_identifier_opt list_of_path_inputs K_SG K_LPAREN 
//list_of_path_outputs polarity_operator_opt K_COLON /* data_source_expression */ expression K_RPAREN K_RPAREN
//{
//    yydebug("full_edge_sensitive_path_description: K_LPAREN edge_identifier_opt list_of_path_inputs K_SG K_LPAREN "
//            "list_of_path_outputs polarity_operator_opt K_COLON /* data_source_expression */ expression K_RPAREN K_RPAREN.");
//    yyerror("full_edge_sensitive_path_description: K_LPAREN edge_identifier_opt list_of_path_inputs K_SG K_LPAREN "
//            "list_of_path_outputs polarity_operator_opt K_COLON /* data_source_expression */ expression K_RPAREN K_RPAREN is not supported.");
//};


// data_source_expression ::= expression


//edge_identifier_opt:
///* empty */
//{
//    yydebug("edge_identifier_opt: /* empty */");
//    yyerror("edge_identifier_opt: /* empty */ is not supported.");
//}
//| edge_identifier
//{
//    yydebug("edge_identifier_opt: edge_identifier.");
//    yyerror("edge_identifier_opt: edge_identifier is not supported.");
//};

//edge_identifier:
//K_posedge
//{
//    yydebug("edge_identifier: K_posedge.");
//    yyerror("edge_identifier: K_posedge is not supported.");
//}
//| K_negedge
//{
//    yydebug("edge_identifier: K_negedge.");
//    yyerror("edge_identifier: K_negedge is not supported.");
//};


//state_dependent_path_declaration:
//K_if K_LPAREN module_path_expression K_RPAREN simple_path_declaration
//| K_if K_LPAREN module_path_expression K_RPAREN edge_sensitive_path_declaration
//| K_ifnone simple_path_declaration;


//polarity_operator_opt:
///* empty */
//{
//    yydebug("polarity_operator_opt: /* empty */");
//    yyerror("polarity_operator_opt: /* empty */ is not supported.");
//}
//| K_PLUS
//{
//    yydebug("polarity_operator_opt: K_PLUS");
//    yyerror("polarity_operator_opt: K_PLUS is not supported.");
//}
//| K_MINUS
//{
//    yydebug("polarity_operator_opt: K_MINUS");
//    yyerror("polarity_operator_opt: K_MINUS is not supported.");
//};



/* -----------------------------------------------------------------------
 *  SYSTEM TIMING CHECK COMMANDS
 * -----------------------------------------------------------------------
 */

system_timing_check:
setup_timing_check
{
    yydebug("system_timing_check: setup_timing_check.");
    RULE_BREAK_MACRO $$ = $1;
}
| hold_timing_check
{
    yydebug("system_timing_check: hold_timing_check.");
    yyerror("system_timing_check: hold_timing_check is not supported.");
}
| setuphold_timing_check
{
    yydebug("system_timing_check: setuphold_timing_check.");
    yyerror("system_timing_check: setuphold_timing_check is not supported.");
}
| recovery_timing_check
{
    yydebug("system_timing_check: recovery_timing_check.");
    yyerror("system_timing_check: recovery_timing_check is not supported.");
}
| removal_timing_check
{
    yydebug("system_timing_check: removal_timing_check.");
    yyerror("system_timing_check: removal_timing_check is not supported.");
}
| recrem_timing_check
{
    yydebug("system_timing_check: recrem_timing_check.");
    yyerror("system_timing_check: recrem_timing_check is not supported.");
}
| skew_timing_check
{
    yydebug("system_timing_check: skew_timing_check.");
    yyerror("system_timing_check: skew_timing_check is not supported.");
}
| timeskew_timing_check
{
    yydebug("system_timing_check: timeskew_timing_check.");
    yyerror("system_timing_check: timeskew_timing_check is not supported.");
}
| fullskew_timing_check
{
    yydebug("system_timing_check: fullskew_timing_check.");
    yyerror("system_timing_check: fullskew_timing_check is not supported.");
}
| period_timing_check
{
    yydebug("system_timing_check: period_timing_check.");
    yyerror("system_timing_check: period_timing_check is not supported.");
}
| width_timing_check
{
    yydebug("system_timing_check: width_timing_check.");
    yyerror("system_timing_check: width_timing_check is not supported.");
}
| nochange_timing_check
{
    yydebug("system_timing_check: nochange_timing_check.");
    yyerror("system_timing_check: nochange_timing_check is not supported.");
};


setup_timing_check:
K_Ssetup K_LPAREN /* data_event */ timing_check_event K_COMMA /* reference_event */ timing_check_event K_COMMA 
/* timing_check_limit */ expression comma_notifier_opt_opt K_RPAREN K_SEMICOLON
{
    yydebug("system_timing_check: K_Ssetup K_LPAREN /* data_event */ timing_check_event K_COMMA "
            "/* reference_event */ timing_check_event K_COMMA /* timing_check_limit */ expression comma_notifier_opt_opt K_RPAREN K_SEMICOLON.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_TimingCheck("$setup", $3, $5, $7, $8);
};


hold_timing_check:
K_Shold K_LPAREN /* reference_event */ timing_check_event K_COMMA /* data_event */ timing_check_event K_COMMA 
/* timing_check_limit */ expression comma_notifier_opt_opt K_RPAREN K_SEMICOLON
{
    yydebug("system_timing_check: K_Shold K_LPAREN /* reference_event */ timing_check_event K_COMMA "
            "/* data_event */ timing_check_event K_COMMA /* timing_check_limit */ expression comma_notifier_opt_opt K_RPAREN K_SEMICOLON.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_TimingCheck("$setup", $3, $5, $7, $8);
};


setuphold_timing_check:
K_Ssetuphold K_LPAREN /* reference_event */ timing_check_event K_COMMA /* data_event */ timing_check_event K_COMMA 
/* timing_check_limit */ expression K_COMMA /* timing_check_limit */ expression timing_check_opt_1a K_RPAREN K_SEMICOLON
{
    yydebug("setuphold_timing_check: K_Ssetuphold K_LPAREN /* reference_event */ timing_check_event K_COMMA "
            "/* data_event */ timing_check_event K_COMMA /* timing_check_limit */ expression K_COMMA "
            "/* timing_check_limit */ expression timing_check_opt_1a K_RPAREN K_SEMICOLON.");
    yyerror("setuphold_timing_check: K_Ssetuphold K_LPAREN /* reference_event */ timing_check_event K_COMMA "
            "/* data_event */ timing_check_event K_COMMA /* timing_check_limit */ expression K_COMMA "
            "/* timing_check_limit */ expression timing_check_opt_1a K_RPAREN K_SEMICOLON is not supported.");
};


recovery_timing_check:
K_Srecovery K_LPAREN /* reference_event */ timing_check_event K_COMMA /* data_event */ timing_check_event K_COMMA 
/* timing_check_limit */ expression comma_notifier_opt_opt K_RPAREN K_SEMICOLON
{
    yydebug("recovery_timing_check: K_Srecovery K_LPAREN /* reference_event */ timing_check_event K_COMMA "
            "/* data_event */ timing_check_event K_COMMA /* timing_check_limit */ expression comma_notifier_opt_opt K_RPAREN K_SEMICOLON.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_TimingCheck("$setup", $3, $5, $7, $8);
};


removal_timing_check:
K_Sremoval K_LPAREN /* reference_event */ timing_check_event K_COMMA /* data_event */ timing_check_event K_COMMA 
/* timing_check_limit */ expression comma_notifier_opt_opt K_RPAREN K_SEMICOLON
{
    yydebug("removal_timing_check: K_Sremoval K_LPAREN /* reference_event */ timing_check_event K_COMMA "
            "/* data_event */ timing_check_event K_COMMA /* timing_check_limit */ expression comma_notifier_opt_opt K_RPAREN K_SEMICOLON.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_TimingCheck("$setup", $3, $5, $7, $8);
};


recrem_timing_check:
K_Srecrem K_LPAREN /* reference_event */ timing_check_event K_COMMA /* data_event */ timing_check_event K_COMMA 
/* timing_check_limit */ expression K_COMMA /* timing_check_limit */ expression timing_check_opt_1a K_RPAREN K_SEMICOLON
{
    yydebug("recrem_timing_check: K_Srecrem K_LPAREN /* reference_event */ timing_check_event K_COMMA "
            "/* data_event */ timing_check_event K_COMMA /* timing_check_limit */ expression K_COMMA "
            "/* timing_check_limit */ expression timing_check_opt_1a K_RPAREN K_SEMICOLON.");
    yyerror("recrem_timing_check: K_Srecrem K_LPAREN /* reference_event */ timing_check_event K_COMMA "
            "/* data_event */ timing_check_event K_COMMA /* timing_check_limit */ expression K_COMMA "
            "/* timing_check_limit */ expression timing_check_opt_1a K_RPAREN K_SEMICOLON is not supported.");
};


skew_timing_check:
K_Sskew K_LPAREN /* reference_event */ timing_check_event K_COMMA /* data_event */ timing_check_event K_COMMA 
/* timing_check_limit */ expression comma_notifier_opt_opt K_RPAREN K_SEMICOLON
{
    yydebug("skew_timing_check: K_Sskew K_LPAREN /* reference_event */ timing_check_event K_COMMA "
            "/* data_event */ timing_check_event K_COMMA /* timing_check_limit */ expression comma_notifier_opt_opt K_RPAREN K_SEMICOLON.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_TimingCheck("$setup", $3, $5, $7, $8);
};


timeskew_timing_check:
K_Stimeskew K_LPAREN /* reference_event */ timing_check_event K_COMMA /* data_event */ timing_check_event K_COMMA 
/* timing_check_limit */ expression timing_check_opt_1b K_RPAREN K_SEMICOLON
{
    yydebug("timeskew_timing_check: K_Stimeskew K_LPAREN /* reference_event */ timing_check_event K_COMMA "
            "/* data_event */ timing_check_event K_COMMA /* timing_check_limit */ expression timing_check_opt_1b K_RPAREN K_SEMICOLON.");
    yyerror("timeskew_timing_check: K_Stimeskew K_LPAREN /* reference_event */ timing_check_event K_COMMA "
            "/* data_event */ timing_check_event K_COMMA /* timing_check_limit */ expression timing_check_opt_1b K_RPAREN K_SEMICOLON is not supported.");
};

  
fullskew_timing_check:
K_Sfullskew K_LPAREN /* reference_event */ timing_check_event K_COMMA /* data_event */ timing_check_event K_COMMA 
/* timing_check_limit */ expression K_COMMA /* timing_check_limit */ expression timing_check_opt_1b K_RPAREN K_SEMICOLON
{
    yydebug("fullskew_timing_check: K_Sfullskew K_LPAREN /* reference_event */ timing_check_event K_COMMA "
            "/* data_event */ timing_check_event K_COMMA /* timing_check_limit */ expression K_COMMA "
            "/* timing_check_limit */ expression timing_check_opt_1b K_RPAREN K_SEMICOLON.");
    yyerror("fullskew_timing_check: K_Sfullskew K_LPAREN /* reference_event */ timing_check_event K_COMMA "
            "/* data_event */ timing_check_event K_COMMA /* timing_check_limit */ expression K_COMMA "
            "/* timing_check_limit */ expression timing_check_opt_1b K_RPAREN K_SEMICOLON is not supported.");
};
  
  
period_timing_check:
K_Speriod K_LPAREN /* controlled_reference_event */ controlled_timing_check_event K_COMMA 
/* timing_check_limit */ expression comma_notifier_opt_opt K_RPAREN K_SEMICOLON
{
    yydebug("period_timing_check: K_Speriod K_LPAREN /* controlled_reference_event */ controlled_timing_check_event K_COMMA "
            "/* timing_check_limit */ expression comma_notifier_opt_opt K_RPAREN K_SEMICOLON.");
    yyerror("period_timing_check: K_Speriod K_LPAREN /* controlled_reference_event */ controlled_timing_check_event K_COMMA "
            "/* timing_check_limit */ expression comma_notifier_opt_opt K_RPAREN K_SEMICOLON is not supported.");
};


width_timing_check:
K_Swidth K_LPAREN /* controlled_reference_event */ controlled_timing_check_event K_COMMA 
/* timing_check_limit */ expression comma_threshold_notifier_opt K_RPAREN K_SEMICOLON
{
    yydebug("width_timing_check: K_Swidth K_LPAREN /* controlled_reference_event */ controlled_timing_check_event K_COMMA "
            "/* timing_check_limit */ expression comma_threshold_notifier_opt K_RPAREN K_SEMICOLON.");
    yyerror("width_timing_check: K_Swidth K_LPAREN /* controlled_reference_event */ controlled_timing_check_event K_COMMA "
            "/* timing_check_limit */ expression comma_threshold_notifier_opt K_RPAREN K_SEMICOLON is not supported.");
};

                                                                   
nochange_timing_check:
K_Snochange K_LPAREN /* reference_event */ timing_check_event K_COMMA /* data_event */ timing_check_event K_COMMA 
/* start_edge_offset */ mintypmax_expression K_COMMA /* end_edge_offset */ mintypmax_expression comma_notifier_opt_opt K_RPAREN K_SEMICOLON
{
    yydebug("nochange_timing_check: K_Snochange K_LPAREN /* reference_event */ timing_check_event K_COMMA "
            "/* data_event */ timing_check_event K_COMMA /* start_edge_offset */ mintypmax_expression K_COMMA "
            "/* end_edge_offset */ mintypmax_expression comma_notifier_opt_opt K_RPAREN K_SEMICOLON.");
    yyerror("nochange_timing_check: K_Snochange K_LPAREN /* reference_event */ timing_check_event K_COMMA "
            "/* data_event */ timing_check_event K_COMMA /* start_edge_offset */ mintypmax_expression K_COMMA "
            "/* end_edge_offset */ mintypmax_expression comma_notifier_opt_opt K_RPAREN K_SEMICOLON is not supported.");
};




/*
 * [ , [ notifier ] [ , [ event_based_flag ] [ , [ remain_active_flag ] ] ] ]
 * 
 */

timing_check_opt_1b:
/* empty */
{
    yydebug("timing_check_opt_1b: /* empty */");
    yyerror("timing_check_opt_1b: /* empty */ is not supported.");
}
| K_COMMA notifier_opt timing_check_opt_2b
{
    yydebug("timing_check_opt_1b: K_COMMA notifier_opt timing_check_opt_2b.");
    yyerror("timing_check_opt_1b: K_COMMA notifier_opt timing_check_opt_2b is not supported.");
};

timing_check_opt_2b:
/* empty */
{
    yydebug("timing_check_opt_2b: /* empty */");
    yyerror("timing_check_opt_2b: /* empty */ is not supported.");
}
| K_COMMA event_based_flag_opt timing_check_opt_3b
{
    yydebug("timing_check_opt_2b: K_COMMA event_based_flag_opt timing_check_opt_3b.");
    yyerror("timing_check_opt_2b: K_COMMA event_based_flag_opt timing_check_opt_3b is not supported.");
};

timing_check_opt_3b:
/* empty */
{
    yydebug("timing_check_opt_3b: /* empty */");
    yyerror("timing_check_opt_3b: /* empty */ is not supported.");
}
| K_COMMA /* remain_active_flag_opt */ /* constant_expression */ expression
{
    yydebug("timing_check_opt_3b: K_COMMA /* remain_active_flag_opt */ /* constant_expression */ expression.");
    yyerror("timing_check_opt_3b: K_COMMA /* remain_active_flag_opt */ /* constant_expression */ expression is not supported.");
};




/*
 * [ , [ notifier ] [ , [ stamptime_condition ] [ , [ checktime_condition ]
 * [ , [ delayed_reference ] [ , [ delayed_data ] ] ] ] ] ]
 * 
 */

timing_check_opt_1a:
/* empty */
{
    yydebug("timing_check_opt_1a: /* empty */");
    yyerror("timing_check_opt_1a: /* empty */ is not supported.");
}
| K_COMMA notifier_opt timing_check_opt_2a
{
    yydebug("timing_check_opt_1a: K_COMMA notifier_opt timing_check_opt_2a.");
    yyerror("timing_check_opt_1a: K_COMMA notifier_opt timing_check_opt_2a is not supported.");
};


timing_check_opt_2a:
/* empty */
{
    yydebug("timing_check_opt_2a: /* empty */");
    yyerror("timing_check_opt_2a: /* empty */ is not supported.");
}
| K_COMMA /* stamptime_condition_opt */ mintypmax_expression_opt timing_check_opt_3a
{
    yydebug("timing_check_opt_2a: K_COMMA /* stamptime_condition_opt */ mintypmax_expression_opt timing_check_opt_3a.");
    yyerror("timing_check_opt_2a: K_COMMA /* stamptime_condition_opt */ mintypmax_expression_opt timing_check_opt_3a is not supported.");
};

mintypmax_expression_opt:
/* empty */
{
    yydebug("mintypmax_expression_opt: /* empty */");
    RULE_BREAK_MACRO $$ = nullptr;
}
| mintypmax_expression
{
    yydebug("mintypmax_expression_opt: mintypmax_expression.");
    RULE_BREAK_MACRO $$ = $1;
};


timing_check_opt_3a:
/* empty */
{
    yydebug("timing_check_opt_3a: /* empty */");
    yyerror("timing_check_opt_3a: /* empty */ is not supported.");
}
| K_COMMA checktime_condition_opt timing_check_opt_4a
{
    yydebug("timing_check_opt_3a: K_COMMA checktime_condition_opt timing_check_opt_4a.");
    yyerror("timing_check_opt_3a: K_COMMA checktime_condition_opt timing_check_opt_4a is not supported.");
};

timing_check_opt_4a:
/* empty */
{
    yydebug("timing_check_opt_4a: /* empty */");
    yyerror("timing_check_opt_4a: /* empty */ is not supported.");
}
| K_COMMA delayed_reference_opt timing_check_opt_5a
{
    yydebug("timing_check_opt_4a: K_COMMA delayed_reference_opt timing_check_opt_5a.");
    yyerror("timing_check_opt_4a: K_COMMA delayed_reference_opt timing_check_opt_5a is not supported.");
};

timing_check_opt_5a:
/* empty */
{
    yydebug("timing_check_opt_5a: /* empty */");
    yyerror("timing_check_opt_5a: /* empty */ is not supported.");
}
| K_COMMA delayed_data
{
    yydebug("timing_check_opt_5a: K_COMMA delayed_data.");
    yyerror("timing_check_opt_5a: K_COMMA delayed_data is not supported.");
};







comma_notifier_opt_opt:
/* empty */
{
    yydebug("comma_notifier_opt_opt: /* empty */");
    RULE_BREAK_MACRO $$ = nullptr;
}
| K_COMMA notifier_opt
{
    yydebug("comma_notifier_opt_opt: K_COMMA notifier_opt.");
    RULE_BREAK_MACRO $$ = $2;
};

notifier_opt:
/* empty */
{
    yydebug("notifier_opt: /* empty */");
    RULE_BREAK_MACRO $$ = nullptr;
}
| /* notifier -> variable_identifier -> */ IDENTIFIER
{
    yydebug("notifier_opt: /* notifier -> variable_identifier -> */ IDENTIFIER.");
    RULE_BREAK_MACRO
    $$ = new Identifier($1);
    free($1);
};

comma_threshold_notifier_opt:
/* empty */
{
    yydebug("comma_threshold_notifier_opt: /* empty */");
    yyerror("comma_threshold_notifier_opt: /* empty */ is not supported.");
}
| K_COMMA /* threshold */ /* constant_expression */ expression comma_notifier_opt
{
    yydebug("comma_threshold_notifier_opt: K_COMMA /* threshold */ /* constant_expression */ expression comma_notifier_opt.");
    yyerror("comma_threshold_notifier_opt: K_COMMA /* threshold */ /* constant_expression */ expression comma_notifier_opt is not supported.");
};

comma_notifier_opt:
/* empty */
{
    yydebug("comma_notifier_opt: /* empty */");
    yyerror("comma_notifier_opt: /* empty */ is not supported.");
}
| K_COMMA notifier_opt
{
    yydebug("comma_notifier_opt: K_COMMA notifier_opt.");
    yyerror("comma_notifier_opt: K_COMMA notifier_opt is not supported.");
};






/* -----------------------------------------------------------------------
 *  SYSTEM TIMING CHECK COMMAND ARGUMENTS
 * -----------------------------------------------------------------------
 */

/*
 * data_event ::= timing_check_event
 * controlled_reference_event ::= controlled_timing_check_event
 * checktime_condition ::= mintypmax_expression
 * end_edge_offset ::= mintypmax_expression
 * event_based_flag ::= constant_expression
 * notifier ::= variable_identifier
 * reference_event ::= timing_check_event
 * remain_active_flag ::= constant_expression
 * stamptime_condition ::= mintypmax_expression
 * start_edge_offset ::= mintypmax_expression
 * threshold ::= constant_expression
 * timing_check_limit ::= expression
 * 
 */


delayed_data:
/* terminal_identifier */ IDENTIFIER
{
    yydebug("delayed_data: /* terminal_identifier */ IDENTIFIER.");
    yyerror("delayed_data: /* terminal_identifier */ IDENTIFIER is not supported.");
}
| /* terminal_identifier */ IDENTIFIER K_LBRACKET /*constant_mintypmax_expression*/ mintypmax_expression K_RBRACKET
{
    yydebug("delayed_data: /* terminal_identifier */ IDENTIFIER K_LBRACKET /*constant_mintypmax_expression*/ mintypmax_expression K_RBRACKET.");
    yyerror("delayed_data: /* terminal_identifier */ IDENTIFIER K_LBRACKET /*constant_mintypmax_expression*/ mintypmax_expression K_RBRACKET is not supported.");
};


delayed_reference:
/* terminal_identifier */ IDENTIFIER
{
    yydebug("delayed_reference: /* terminal_identifier */ IDENTIFIER.");
    yyerror("delayed_reference: /* terminal_identifier */ IDENTIFIER is not supported.");
}
| /* terminal_identifier */ IDENTIFIER K_LBRACKET /*constant_mintypmax_expression*/ mintypmax_expression K_RBRACKET
{
    yydebug("delayed_reference: /* terminal_identifier */ IDENTIFIER K_LBRACKET /*constant_mintypmax_expression*/ mintypmax_expression K_RBRACKET.");
    yyerror("delayed_reference: /* terminal_identifier */ IDENTIFIER K_LBRACKET /*constant_mintypmax_expression*/ mintypmax_expression K_RBRACKET is not supported.");
};


delayed_reference_opt:
/* empty */
{
    yydebug("delayed_reference_opt: /* empty */");
    yyerror("delayed_reference_opt: /* empty */ is not supported.");
}
| delayed_reference
{
    yydebug("delayed_reference_opt: delayed_reference.");
    yyerror("delayed_reference_opt: delayed_reference is not supported.");
};


event_based_flag_opt:
/* empty */
{
    yydebug("event_based_flag_opt: /* empty */");
    yyerror("event_based_flag_opt: /* empty */ is not supported.");
}
| /* event_based_flag */ /* constant_expression */ expression
{
    yydebug("event_based_flag_opt: /* event_based_flag */ /* constant_expression */ expression.");
    yyerror("event_based_flag_opt: /* event_based_flag */ /* constant_expression */ expression is not supported.");
};


checktime_condition_opt:
/* empty */
{
    yydebug("checktime_condition_opt: /* empty */");
    yyerror("checktime_condition_opt: /* empty */ is not supported.");
}
| /* checktime_condition */ mintypmax_expression
{
    yydebug("checktime_condition_opt: /* checktime_condition */ mintypmax_expression.");
    yyerror("checktime_condition_opt: /* checktime_condition */ mintypmax_expression is not supported.");
};








/* -----------------------------------------------------------------------
 *  SYSTEM TIMING CHECK COMMAND ARGUMENTS
 * -----------------------------------------------------------------------
 */

timing_check_event:
timing_check_event_control_opt specify_terminal_descriptor
{
    yydebug("timing_check_event: timing_check_event_control_opt specify_terminal_descriptor.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_TimingCheckEvent($1, $2);
}
| timing_check_event_control_opt specify_terminal_descriptor K_TAND timing_check_condition
{
    yydebug("timing_check_event: timing_check_event_control_opt specify_terminal_descriptor K_TAND timing_check_condition.");
    yyerror("timing_check_event: timing_check_event_control_opt specify_terminal_descriptor K_TAND timing_check_condition is not supported.");
};


timing_check_event_control_opt:
/* empty */
{
    yydebug("timing_check_event_control_opt: /* empty */");
    RULE_BREAK_MACRO $$ = nullptr;
}
| timing_check_event_control
{
    yydebug("timing_check_event_control_opt: timing_check_event_control.");
    RULE_BREAK_MACRO $$ = $1;
};

controlled_timing_check_event:
timing_check_event_control specify_terminal_descriptor
{
    yydebug("controlled_timing_check_event: timing_check_event_control specify_terminal_descriptor.");
    yyerror("controlled_timing_check_event: timing_check_event_control specify_terminal_descriptor is not supported.");
}
| timing_check_event_control specify_terminal_descriptor K_TAND timing_check_condition
{
    yydebug("controlled_timing_check_event: timing_check_event_control specify_terminal_descriptor K_TAND timing_check_condition.");
    yyerror("controlled_timing_check_event: timing_check_event_control specify_terminal_descriptor K_TAND timing_check_condition is not supported.");
};



timing_check_event_control:
K_posedge
{
    yydebug("timing_check_event_control: K_posedge.");
    RULE_BREAK_MACRO
    $$ = new timing_check_event_control_t();
    $$->pos_edge = true;
    $$->neg_edge = false;
}
| K_negedge
{
    yydebug("timing_check_event_control: K_negedge.");
    RULE_BREAK_MACRO
    $$ = new timing_check_event_control_t();
    $$->pos_edge = false;
    $$->neg_edge = true;
}
| edge_control_specifier
{
    yydebug("timing_check_event_control: edge_control_specifier.");
    yyerror("timing_check_event_control: edge_control_specifier is not supported.");
};



specify_terminal_descriptor:
//specify_input_terminal_descriptor
//{
//    yydebug("specify_terminal_descriptor: specify_input_terminal_descriptor.");
//    yyerror("specify_terminal_descriptor: specify_input_terminal_descriptor is not supported.");
//}
//| 
specify_output_terminal_descriptor
{
    yydebug("specify_terminal_descriptor: specify_output_terminal_descriptor.");
    RULE_BREAK_MACRO $$ = $1;
};



edge_control_specifier:
K_edge edge_descriptor_list_opt
{
    yydebug("edge_control_specifier: K_edge edge_descriptor_list_opt.");
    yyerror("edge_control_specifier: K_edge edge_descriptor_list_opt is not supported.");
};


       
edge_descriptor_list_opt:
/* empty */
{
    yydebug("edge_descriptor_list_opt: /* empty */");
    yyerror("edge_descriptor_list_opt: /* empty */ is not supported.");
}
| edge_descriptor_list
{
    yydebug("edge_descriptor_list_opt: edge_descriptor_list.");
    yyerror("edge_descriptor_list_opt: edge_descriptor_list is not supported.");
};


edge_descriptor_list:
edge_descriptor
{
    yydebug("edge_descriptor_list: edge_descriptor.");
    yyerror("edge_descriptor_list: edge_descriptor is not supported.");
}
| edge_descriptor_list K_COMMA edge_descriptor
{
    yydebug("edge_descriptor_list: edge_descriptor_list K_COMMA edge_descriptor.");
    yyerror("edge_descriptor_list: edge_descriptor_list K_COMMA edge_descriptor is not supported.");
};

       

edge_descriptor:
"01"
{
    
}
| "10"
{
    
}
| z_or_x '0'
{
    
}
| z_or_x '1'
{
    
}
| '0' z_or_x
{
    
}
| '1' z_or_x
{
    
};


z_or_x:
'x'     {       }
| 'X'   {       }
| 'z'   {       }
| 'Z'   {       };


timing_check_condition:
/* scalar_timing_check_condition */ expression
{
    yydebug("timing_check_condition: /* scalar_timing_check_condition */ expression.");
    RULE_BREAK_MACRO $$ = $1;
}
//| K_LPAREN scalar_timing_check_condition K_RPAREN
;


//scalar_timing_check_condition:
//expression
//{
//    yydebug("scalar_timing_check_condition: expression.");
//    yyerror("scalar_timing_check_condition: expression is not supported.");
//}
////| K_TILDE expression
////| expression K_EQEQ SCALAR_CONSTANT
////| expression K_CEQ SCALAR_CONSTANT
////| expression K_NE SCALAR_CONSTANT
////| expression K_CNE SCALAR_CONSTANT
;


//SCALAR_CONSTANT:
//'1\'b0'
//| '1\'b1' 
//| '1\'B0' 
//| '1\'B1' 
//| '\'b0'
//| '\'b1'
//| '\'B0'
//| '\'B1'
//| '1' 
//| '0' ;






/* -----------------------------------------------------------------------
 *  EXPRESSIONS
 * -----------------------------------------------------------------------
 */

/* 
 * base_expression ::= expression
 * constant_base_expression ::= constant_expression
 * dimension_constant_expression ::= constant_expression
 * expression1 ::= expression
 * expression2 ::= expression
 * expression3 ::= expression
 * lsb_constant_expression ::= constant_expression
 * msb_constant_expression ::= constant_expression
 * width_constant_expression ::= constant_expression
 * 
 */


//conditional_expression:
///* expression1 */ expression K_QUEST attribute_instance_list /* expression2 */ expression K_COLON /* expression3 */ expression;


/*
 * unary_binary_op_set:
K_PLUS     {}
K_MINUS   {}
K_AMPERSAND   {}
K_BAR   {}
K_CAP   {}
K_NXOR
 */

expression:
primary
{
    yydebug("expression: primary.");
    RULE_BREAK_MACRO $$ = $1;
}
| K_EXCL attribute_instance_list primary %prec UNARY_PREC
{
    yydebug("expression: K_EXCL attribute_instance_list primary.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ExpressionUnaryOperator(op_not, $3);
}
| K_TILDE attribute_instance_list primary %prec UNARY_PREC
{
    yydebug("expression: K_TILDE attribute_instance_list primary.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ExpressionUnaryOperator(op_bnot, $3);
}
| K_NAND attribute_instance_list primary %prec UNARY_PREC
{
    yydebug("expression: K_NAND attribute_instance_list primary.");
    yyerror("expression: K_NAND attribute_instance_list primary is not supported.");
}
| K_NOR attribute_instance_list primary %prec UNARY_PREC
{
    yydebug("expression: K_NOR attribute_instance_list primary.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ExpressionNorOperator( $3 );
}
| K_PLUS attribute_instance_list primary %prec UNARY_PREC
{
    yydebug("expression: K_PLUS attribute_instance_list primary.");
    RULE_BREAK_MACRO $$ = $3;
}
| K_MINUS attribute_instance_list primary %prec UNARY_PREC
{
    yydebug("expression: K_MINUS attribute_instance_list primary.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ExpressionUnaryOperator(op_minus, $3);
}
| K_AMPERSAND attribute_instance_list primary %prec UNARY_PREC
{
    yydebug("expression: K_AMPERSAND attribute_instance_list primary.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ExpressionUnaryOperator(op_andrd, $3);
}
| K_BAR attribute_instance_list primary %prec UNARY_PREC
{
    yydebug("expression: K_BAR attribute_instance_list primary.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ExpressionUnaryOperator(op_orrd, $3);
}
| K_CAP attribute_instance_list primary %prec UNARY_PREC
{
    yydebug("expression: K_CAP attribute_instance_list primary.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ExpressionUnaryOperator(op_xorrd, $3);
}
| K_NXOR attribute_instance_list primary %prec UNARY_PREC
{
    yydebug("expression: K_NXOR attribute_instance_list primary.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ExpressionUnaryOperator(op_xorrd, $3, true);
}
| expression K_PLUS attribute_instance_list expression
{
    yydebug("expression: expression K_PLUS attribute_instance_list expression.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ExpressionBinaryOperator($1, op_plus, $4);
}
| expression K_MINUS attribute_instance_list expression
{
    yydebug("expression: expression K_MINUS attribute_instance_list expression.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ExpressionBinaryOperator($1, op_minus, $4);
}
| expression K_AMPERSAND attribute_instance_list expression
{
    yydebug("expression: expression K_AMPERSAND attribute_instance_list expression.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ExpressionBinaryOperator($1, op_band, $4);
}
| expression K_BAR attribute_instance_list expression
{
    yydebug("expression: expression K_BAR attribute_instance_list expression.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ExpressionBinaryOperator($1, op_bor, $4);
}
| expression K_CAP attribute_instance_list expression
{
    yydebug("expression: expression K_CAP attribute_instance_list expression.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ExpressionBinaryOperator($1, op_bxor, $4);
}
| expression K_NXOR attribute_instance_list expression
{
    yydebug("expression: expression K_NXOR attribute_instance_list expression.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ExpressionBinaryOperator($1, op_bxor, $4, true);
}
| expression K_STAR attribute_instance_list expression
{
    yydebug("expression: expression K_STAR attribute_instance_list expression.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ExpressionBinaryOperator($1, op_mult, $4);
}
| expression K_SLASH attribute_instance_list expression
{
    yydebug("expression: expression K_SLASH attribute_instance_list expression.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ExpressionBinaryOperator($1, op_div, $4);
}
| expression K_PERC attribute_instance_list expression
{
    yydebug("expression: expression K_PERC attribute_instance_list expression.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ExpressionBinaryOperator($1, op_mod, $4);
}
| expression K_EQEQ attribute_instance_list expression
{
    yydebug("expression: expression K_EQEQ attribute_instance_list expression.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ExpressionBinaryOperator($1, op_eq, $4);
}
| expression K_NE attribute_instance_list expression
{
    yydebug("expression: expression K_NE attribute_instance_list expression.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ExpressionBinaryOperator($1, op_neq, $4);
}
| expression K_CEQ attribute_instance_list expression
{
    yydebug("expression: expression K_CEQ attribute_instance_list expression.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ExpressionBinaryOperator($1, op_case_eq, $4);
}
| expression K_CNE attribute_instance_list expression
{
    yydebug("expression: expression K_CNE attribute_instance_list expression.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ExpressionBinaryOperator($1, op_case_neq, $4);
}
| expression K_LAND attribute_instance_list expression
{
    yydebug("expression: expression K_LAND attribute_instance_list expression.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ExpressionBinaryOperator($1, op_and, $4);
}
| expression K_LOR attribute_instance_list expression
{
    yydebug("expression: expression K_LOR attribute_instance_list expression.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ExpressionBinaryOperator($1, op_or, $4);
}
| expression K_LT attribute_instance_list expression
{
    yydebug("expression: expression K_LT attribute_instance_list expression.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ExpressionBinaryOperator($1, op_lt, $4);
}
| expression K_LE attribute_instance_list expression
{
    yydebug("expression: expression K_LE attribute_instance_list expression.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ExpressionBinaryOperator($1, op_le, $4);
}
| expression K_GT attribute_instance_list expression
{
    yydebug("expression: expression K_GT attribute_instance_list expression.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ExpressionBinaryOperator($1, op_gt, $4);
}
| expression K_GE attribute_instance_list expression
{
    yydebug("expression: expression K_GE attribute_instance_list expression.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ExpressionBinaryOperator($1, op_ge, $4);
}
| expression K_RS attribute_instance_list expression
{
    yydebug("expression: expression K_RS attribute_instance_list expression.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ExpressionBinaryOperator($1, op_srl, $4);
}
| expression K_RSS attribute_instance_list expression
{
    yydebug("expression: expression K_RSS attribute_instance_list expression.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ExpressionBinaryOperator($1, op_sra, $4);
}
| expression K_LS attribute_instance_list expression
{
    yydebug("expression: expression K_LS attribute_instance_list expression.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ExpressionBinaryOperator($1, op_sll, $4);
}
| expression K_LSS attribute_instance_list expression
{
    yydebug("expression: expression K_LSS attribute_instance_list expression.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ExpressionBinaryOperator($1, op_sla, $4);
}
| expression K_POW attribute_instance_list expression
{
    yydebug("expression: expression K_POW attribute_instance_list expression.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ExpressionBinaryOperator($1, op_pow, $4);
}
| expression K_QUEST attribute_instance_list expression K_COLON expression
{
    yydebug("expression: expression K_QUEST attribute_instance_list expression K_COLON expression.");
    RULE_BREAK_MACRO $$ = parserInstance->parse_ExpressionTernaryOperator( $1, $4, $6 );
}
;



mintypmax_expression:
expression %prec LOW
{
    yydebug("mintypmax_expression: expression");
    RULE_BREAK_MACRO $$ = $1;
}
| expression K_COLON expression K_COLON expression %prec HIGH
{
    yydebug("mintypmax_expression: expression K_COLON expression K_COLON expression");
    yyerror("mintypmax_expression: expression K_COLON expression K_COLON expression is not supported.");
};


//module_path_conditional_expression:
//module_path_expression K_QUEST attribute_instance_list module_path_expression K_COLON module_path_expression;

//module_path_expression:
//unary_operator attribute_instance_list module_path_primary
//| module_path_expression binary_operator attribute_instance_list module_path_expression %prec HIGH
//| module_path_conditional_expression %prec MEDIUM1
//| module_path_primary %prec LOW;


//module_path_mintypmax_expression:
//module_path_expression K_COLON module_path_expression K_COLON module_path_expression %prec HIGH
//| module_path_expression %prec LOW;



range_expression:
expression
{
    yydebug("range_expression: expression");
    RULE_BREAK_MACRO $$ = $1;
}
| /* msb_constant_expression */ expression K_COLON /* lsb_constant_expression */ /* constant_expression */ expression
{
    yydebug("range_expression: /* msb_constant_expression */ /* constant_expression */ expression : /* lsb_constant_expression */ /* constant_expression */ expression");
    RULE_BREAK_MACRO $$ = parserInstance->parse_RangeExpression( $1, $3 );
}
| /* base_expression */ expression K_PO_POS /* width_constant_expression */ /* constant_expression */ expression
{
    yydebug("range_expression: /* base_expression */ expression K_PO_POS /* width_constant_expression */ /* constant_expression */ expression");
    RULE_BREAK_MACRO $$ = parserInstance->parse_RangeExpressionPO_POS( $1, $3 );
}
| /* base_expression */ expression  K_PO_NEG /* width_constant_expression */ /* constant_expression */ expression
{
    yydebug("range_expression: /* base_expression */ expression  K_PO_NEG /* width_constant_expression */ constant_expression");
    RULE_BREAK_MACRO $$ = parserInstance->parse_RangeExpressionPO_NEG( $1, $3 );
};




/* -----------------------------------------------------------------------
 *  EXPRESSIONS - CONCATENATIONS
 * -----------------------------------------------------------------------
 */

//concatenation:
//K_LBRACE comma_expression_list K_RBRACE
//{
//    yydebug("concatenation: K_LBRACE comma_expression_list K_RBRACE");
//    RULE_BREAK_MACRO $$ = $2;
//};

concatenation:
K_LBRACE comma_expression_opt_list K_RBRACE
{
    yydebug("concatenation: K_LBRACE comma_expression_list K_RBRACE");
    RULE_BREAK_MACRO $$ = $2;
};

comma_expression_list:
expression
{
    yydebug("comma_expression_list: expression");
    RULE_BREAK_MACRO
    $$ = new BList<Value>();
    $$->push_back( $1 );
}
| comma_expression_list K_COMMA expression
{
    yydebug("comma_expression_list: comma_expression_list K_COMMA expression");
    RULE_BREAK_MACRO
    $$ = $1;
    $$->push_back( $3 );
};

comma_expression_opt_list:
/* empty */
{
    RULE_BREAK_MACRO $$ = new BList<Value>();
}
| expression
{
    yydebug("comma_expression_list: expression");
    RULE_BREAK_MACRO
    $$ = new BList<Value>();
    $$->push_back( $1 );
}
| comma_expression_opt_list K_COMMA
{
    RULE_BREAK_MACRO
    $$ = new BList<Value>();
    $$->push_back( nullptr );
}
| comma_expression_opt_list K_COMMA expression
{
    yydebug("comma_expression_list: comma_expression_list K_COMMA expression");
    RULE_BREAK_MACRO
    $$ = $1;
    $$->push_back( $3 );
};

multiple_concatenation:
K_LBRACE /* constant_expression */ expression concatenation K_RBRACE
{
    yydebug("multiple_concatenation: /* constant_expression */ expression concatenation");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_MultipleConcatenation(
             $2, parserInstance->parse_Concatenation( $3 ) );
};


//module_path_concatenation:
//K_LBRACE module_path_list K_RBRACE;

//module_path_list:
//module_path_expression
//| module_path_list K_COMMA module_path_expression;

//module_path_multiple_concatenation:
//K_LBRACE /* constant_expression */ expression module_path_concatenation K_RBRACE
//;

constant_arrayinit:
K_QUOTE K_LBRACE comma_expression_list K_RBRACE
{
    yydebug("constant_arrayinit: K_QUOTE K_LBRACE comma_expression_list K_RBRACE");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_ArrayInitialization($3);
}
| K_LBRACE comma_expression_list K_RBRACE
{
    yydebug("constant_arrayinit: K_LBRACE comma_expression_list K_RBRACE");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_ArrayInitialization($2);
}
;

constant_optional_arrayinit:
K_LBRACE K_RBRACE
{
    yydebug("constant_optional_arrayinit: K_QUOTE K_LBRACE K_RBRACE");
    RULE_BREAK_MACRO $$ = new BList<Value>();
}
//// | K_QUOTE K_LBRACE comma_expression_list K_RBRACE
//// Removed 'K_QUOTE' for compatibility with SystemVerilog and Questa
////| K_LBRACE comma_expression_list K_RBRACE
| concatenation
{
    yydebug("constant_optional_arrayinit: K_QUOTE K_LBRACE comma_expression_list K_RBRACE");
    RULE_BREAK_MACRO $$ = $1;
}
| K_QUOTE concatenation
{
    yydebug("constant_optional_arrayinit: K_QUOTE K_LBRACE comma_expression_list K_RBRACE");
    RULE_BREAK_MACRO $$ = $2;
};


// ** VERILOG_AMS ** -->

//analog_concatenation:
//K_LBRACE analog_comma_expression_list K_RBRACE
//{
//    
//};

//analog_comma_expression_list:
//analog_comma_expression_list K_COMMA /* analog_expression */ expression
//{
//    yydebug("analog_comma_expression_list: analog_comma_expression_list K_COMMA /* analog_expression */ expression");
//    yyerror("analog_comma_expression_list: analog_comma_expression_list K_COMMA /* analog_expression */ expression is not supported.");
//}
//| /* analog_expression */ expression
//{
//    yydebug("analog_comma_expression_list: /* analog_expression */ expression");
//    yyerror("analog_comma_expression_list: /* analog_expression */ expression is not supported.");
//};

//analog_multiple_concatenation:
//K_LBRACE /* constant_expression */ expression analog_concatenation K_RBRACE;

analog_filter_function_arg:
/* parameter_identifier */ IDENTIFIER
{
    yydebug("analog_filter_function_arg: IDENTIFIER");
    RULE_BREAK_MACRO
    $$ = new analog_filter_function_arg_t();
    $$->identifier = parserInstance->parse_Identifier( $1 );
}
| /* parameter_identifier */ IDENTIFIER K_LBRACKET /* msb_constant_expression */ /* constant_expression */ expression K_COLON
/* lsb_constant_expression */ /* constant_expression */ expression K_RBRACKET
{
    yydebug("analog_filter_function_arg: IDENTIFIER K_LBRACKET expression K_COLON expression K_RBRACKET");
    yyerror("analog_filter_function_arg: IDENTIFIER K_LBRACKET expression K_COLON expression K_RBRACKET is not supported");
}
| constant_optional_arrayinit
{
    yydebug("analog_filter_function_arg: constant_optional_arrayinit");
    RULE_BREAK_MACRO
    $$ = new analog_filter_function_arg_t();
    $$->constant_optional_arrayinit = $1;
};

// <-- ** VERILOG_AMS **


/* -----------------------------------------------------------------------
 *  EXPRESSIONS - FUNCTION CALLS
 * -----------------------------------------------------------------------
 */

// NOTE: replicated in 'primary'
//function_call:
//hierarchical_identifier attribute_instance_list K_LPAREN comma_expression_list K_RPAREN;


// NOTE: replicated in 'primary'
//system_function_call:
///* system_function_identifier */ SYSTEM_IDENTIFIER %prec LOW
//| /* system_function_identifier */ SYSTEM_IDENTIFIER K_LPAREN comma_expression_list K_RPAREN %prec HIGH;

// ** VERILOG_AMS ** -->

//NOTE: disabled, see 'primary'
//analog_function_call:
///* analog_function_identifier */ IDENTIFIER attribute_instance_list K_LPAREN analog_comma_expression_list K_RPAREN;

//NOTE: disabled, see 'primary'
//analog_system_function_call:
///* analog_system_function_identifier */ SYSTEM_IDENTIFIER
//// TODO: check syntactical equivalence
//| /* analog_system_function_identifier */ SYSTEM_IDENTIFIER K_LPAREN analog_expression_opt_comma_list K_RPAREN;

// TODO: check syntactical equivalence
//analog_expression_opt_comma_list:
///* empty */
//| /* analog_expression */ expression
//| analog_expression_opt_comma_list K_COMMA
//| analog_expression_opt_comma_list K_COMMA expression;

analog_built_in_function_call:
analog_built_in_function_name K_LPAREN /* analog_expression */ expression K_RPAREN
{
    yydebug("analog_built_in_function_call: analog_built_in_function_name K_LPAREN /* analog_expression */ expression K_RPAREN");    
    RULE_BREAK_MACRO $$ = parserInstance->parse_AnalogBuiltInFunctionCall($1, $3, nullptr);
}
| analog_built_in_function_name K_LPAREN /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_RPAREN
{
    yydebug("analog_built_in_function_call: analog_built_in_function_name K_LPAREN /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_RPAREN");    
    RULE_BREAK_MACRO $$ = parserInstance->parse_AnalogBuiltInFunctionCall($1, $3, $5);
};

// NOTE: see 'analog_built_in_function_call'
analog_built_in_function_name:
K_ln
{
    yydebug("analog_built_in_function_name: K_ln");
    RULE_BREAK_MACRO
    $$ = new Identifier("ln");
    parserInstance->setCodeInfo( $$ );
}
| K_log
{
    yydebug("analog_built_in_function_name: K_log");
    RULE_BREAK_MACRO
    $$ = new Identifier("log");
    parserInstance->setCodeInfo( $$ );
}
| K_exp
{
    yydebug("analog_built_in_function_name: K_exp");
    RULE_BREAK_MACRO
    $$ = new Identifier("exp");
    parserInstance->setCodeInfo( $$ );
}
| K_sqrt
{
    yydebug("analog_built_in_function_name: K_sqrt");
    RULE_BREAK_MACRO
    $$ = new Identifier("sqrt");
    parserInstance->setCodeInfo( $$ );
}
| K_min
{
    yydebug("analog_built_in_function_name: K_min");
    RULE_BREAK_MACRO
    $$ = new Identifier("min");
    parserInstance->setCodeInfo( $$ );
}
| K_max
{
    yydebug("analog_built_in_function_name: K_max");
    RULE_BREAK_MACRO
    $$ = new Identifier("max");
    parserInstance->setCodeInfo( $$ );
}
| K_abs
{
    yydebug("analog_built_in_function_name: K_abs");
    RULE_BREAK_MACRO
    $$ = new Identifier("abs");
    parserInstance->setCodeInfo( $$ );
}
| K_pow
{
    yydebug("analog_built_in_function_name: K_pow");
    RULE_BREAK_MACRO
    $$ = new Identifier("pow");
    parserInstance->setCodeInfo( $$ );
}
| K_floor
{
    yydebug("analog_built_in_function_name: K_floor");
    RULE_BREAK_MACRO
    $$ = new Identifier("floor");
    parserInstance->setCodeInfo( $$ );
}
| K_ceil
{
    yydebug("analog_built_in_function_name: K_ceil");
    RULE_BREAK_MACRO
    $$ = new Identifier("ceil");
    parserInstance->setCodeInfo( $$ );
}
| K_sin
{
    yydebug("analog_built_in_function_name: K_sin");
    RULE_BREAK_MACRO
    $$ = new Identifier("sin");
    parserInstance->setCodeInfo( $$ );
}
| K_cos
{
    yydebug("analog_built_in_function_name: K_cos");
    RULE_BREAK_MACRO
    $$ = new Identifier("cos");
    parserInstance->setCodeInfo( $$ );
}
| K_tan
{
    yydebug("analog_built_in_function_name: K_tan");
    RULE_BREAK_MACRO
    $$ = new Identifier("tan");
    parserInstance->setCodeInfo( $$ );
}
| K_asin
{
    yydebug("analog_built_in_function_name: K_asin");
    RULE_BREAK_MACRO
    $$ = new Identifier("asin");
    parserInstance->setCodeInfo( $$ );
}
| K_acos
{
    yydebug("analog_built_in_function_name: K_acos");
    RULE_BREAK_MACRO
    $$ = new Identifier("acos");
    parserInstance->setCodeInfo( $$ );
}
| K_atan
{
    yydebug("analog_built_in_function_name: K_atan");
    RULE_BREAK_MACRO
    $$ = new Identifier("atan");
    parserInstance->setCodeInfo( $$ );
}
| K_atan2
{
    yydebug("analog_built_in_function_name: K_atan2");
    RULE_BREAK_MACRO
    $$ = new Identifier("atan2");
    parserInstance->setCodeInfo( $$ );
}
| K_hypot
{
    yydebug("analog_built_in_function_name: K_hypot");
    RULE_BREAK_MACRO
    $$ = new Identifier("hypot");
    parserInstance->setCodeInfo( $$ );
}
| K_sinh
{
    yydebug("analog_built_in_function_name: K_sinh");
    RULE_BREAK_MACRO
    $$ = new Identifier("sinh");
    parserInstance->setCodeInfo( $$ );
}
| K_cosh
{
    yydebug("analog_built_in_function_name: K_cosh");
    RULE_BREAK_MACRO
    $$ = new Identifier("cosh");
    parserInstance->setCodeInfo( $$ );
}
| K_tanh
{
    yydebug("analog_built_in_function_name: K_tanh");
    RULE_BREAK_MACRO
    $$ = new Identifier("tanh");
    parserInstance->setCodeInfo( $$ );
}
| K_asinh
{
    yydebug("analog_built_in_function_name: K_asinh");
    RULE_BREAK_MACRO
    $$ = new Identifier("asinh");
    parserInstance->setCodeInfo( $$ );
}
| K_acosh
{
    yydebug("analog_built_in_function_name: K_acosh");
    RULE_BREAK_MACRO
    $$ = new Identifier("acosh");
    parserInstance->setCodeInfo( $$ );
}
| K_atanh
{
    yydebug("analog_built_in_function_name: K_atanh");
    RULE_BREAK_MACRO
    $$ = new Identifier("atanh");
    parserInstance->setCodeInfo( $$ );
};

// NOTE: disabled in 'primary'
analysis_function_call:
K_analysis K_LPAREN /*analysis_identifier_list*/ string_list K_RPAREN
{
    yydebug("analysis_function_call: K_analysis K_LPAREN /*analysis_identifier_list*/ string_list K_RPAREN");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_analysisFunctionCall( $3 );
};

analog_filter_function_call:
K_ddt K_LPAREN /* analog_expression */ expression K_RPAREN
{
    yydebug("analog_filter_function_call: K_ddt K_LPAREN /* analog_expression */ expression K_RPAREN");    
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AnalogFilterFunctionCall("ddt", $3, nullptr, nullptr, nullptr, nullptr, nullptr);
}
| K_ddt K_LPAREN /* analog_expression */ expression K_COMMA /* abstol_expression */ expression K_RPAREN
{
    yydebug("analog_filter_function_call: K_ddt K_LPAREN /* analog_expression */ expression K_COMMA /* abstol_expression */ expression K_RPAREN");    
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AnalogFilterFunctionCall("ddt", $3, $5, nullptr, nullptr, nullptr, nullptr);
}

| K_ddx K_LPAREN /* analog_expression */ expression K_COMMA branch_probe_function_call K_RPAREN
{
    yydebug("analog_filter_function_call: K_ddx K_LPAREN /* analog_expression */ expression K_COMMA /* abstol_expression */ expression K_RPAREN");    
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AnalogFilterFunctionCall("ddx", $3, $5, nullptr, nullptr, nullptr, nullptr);
}
| K_idt K_LPAREN /* analog_expression */ expression K_RPAREN
{
    yydebug("analog_filter_function_call: K_idt K_LPAREN /* analog_expression */ expression K_RPAREN");    
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AnalogFilterFunctionCall("idt", $3, nullptr, nullptr, nullptr, nullptr, nullptr);
}
| K_idt K_LPAREN /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_RPAREN
{
    yydebug("analog_filter_function_call: K_idt K_LPAREN /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_RPAREN");    
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AnalogFilterFunctionCall("idt", $3, $5, nullptr, nullptr, nullptr, nullptr);
}
| K_idt K_LPAREN /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_RPAREN
{
    yydebug("analog_filter_function_call: K_idt K_LPAREN /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_RPAREN");    
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AnalogFilterFunctionCall("idt", $3, $5, $7, nullptr, nullptr, nullptr);
}
| K_idt K_LPAREN /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_COMMA /* abstol_expression */ expression K_RPAREN
{
    yydebug("analog_filter_function_call: K_idt K_LPAREN /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_COMMA /* abstol_expression */ expression K_RPAREN");    
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AnalogFilterFunctionCall("idt", $3, $5, $7, $9, nullptr, nullptr);
}
| K_idtmod K_LPAREN /* analog_expression */ expression K_RPAREN
{
    yydebug("analog_filter_function_call: K_idtmod K_LPAREN /* analog_expression */ expression K_RPAREN");    
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AnalogFilterFunctionCall("idtmod", $3, nullptr, nullptr, nullptr, nullptr, nullptr);
}
| K_idtmod K_LPAREN /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_RPAREN
{
    yydebug("analog_filter_function_call: K_idtmod K_LPAREN /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_RPAREN");    
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AnalogFilterFunctionCall("idtmod", $3, $5, nullptr, nullptr, nullptr, nullptr);
}
| K_idtmod K_LPAREN /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_RPAREN
{
    yydebug("analog_filter_function_call: K_idtmod K_LPAREN /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_RPAREN");    
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AnalogFilterFunctionCall("idtmod", $3, $5, $7, nullptr, nullptr, nullptr);
}
| K_idtmod K_LPAREN /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_RPAREN
{
    yydebug("analog_filter_function_call: K_idtmod K_LPAREN /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_RPAREN");    
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AnalogFilterFunctionCall("idtmod", $3, $5, $7, $9, nullptr, nullptr);
}
| K_idtmod K_LPAREN /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_COMMA /* abstol_expression */ expression K_RPAREN
{
    yydebug("analog_filter_function_call: K_idtmod K_LPAREN /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_COMMA /* abstol_expression */ expression K_RPAREN");    
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AnalogFilterFunctionCall("idtmod", $3, $5, $7, $9, $11, nullptr);
}
| K_absdelay K_LPAREN /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_RPAREN
{
    yydebug("analog_filter_function_call: K_absdelay K_LPAREN /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_RPAREN");    
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AnalogFilterFunctionCall("absdelay", $3, $5, nullptr, nullptr, nullptr, nullptr);
}
| K_absdelay K_LPAREN /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_COMMA expression K_RPAREN
{
    yydebug("analog_filter_function_call: K_absdelay K_LPAREN /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_COMMA expression K_RPAREN");    
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AnalogFilterFunctionCall("absdelay", $3, $5, $7, nullptr, nullptr, nullptr);
}
| K_transition K_LPAREN /* analog_expression */ expression K_RPAREN
{
    yydebug("analog_filter_function_call: K_transition K_LPAREN /* analog_expression */ expression K_RPAREN");    
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AnalogFilterFunctionCall("transition", $3, nullptr, nullptr, nullptr, nullptr, nullptr);
}
| K_transition K_LPAREN /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_RPAREN
{
    yydebug("analog_filter_function_call: K_transition K_LPAREN /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_RPAREN");    
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AnalogFilterFunctionCall("transition", $3, $5, nullptr, nullptr, nullptr, nullptr);
}
| K_transition K_LPAREN /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_RPAREN
{
    yydebug("analog_filter_function_call: K_transition K_LPAREN /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_RPAREN");    
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AnalogFilterFunctionCall("transition", $3, $5, $7, nullptr, nullptr, nullptr);
}
| K_transition K_LPAREN /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_RPAREN
{
    yydebug("analog_filter_function_call: K_transition K_LPAREN /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_RPAREN");    
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AnalogFilterFunctionCall("transition", $3, $5, $7, $9, nullptr, nullptr);
}
| K_transition K_LPAREN /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_COMMA expression K_RPAREN
{
    yydebug("analog_filter_function_call: K_transition K_LPAREN /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_COMMA expression K_RPAREN");    
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AnalogFilterFunctionCall("transition", $3, $5, $7, $9, $11, nullptr);
}

| K_slew K_LPAREN /* analog_expression */ expression K_RPAREN
{
    yydebug("analog_filter_function_call: K_slew K_LPAREN /* analog_expression */ expression K_RPAREN");    
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AnalogFilterFunctionCall("slew", $3, nullptr, nullptr, nullptr, nullptr, nullptr);
}
| K_slew K_LPAREN /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_RPAREN
{
    yydebug("analog_filter_function_call: K_slew K_LPAREN /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_RPAREN");    
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AnalogFilterFunctionCall("slew", $3, $5, nullptr, nullptr, nullptr, nullptr);
}
| K_slew K_LPAREN /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_RPAREN
{
    yydebug("analog_filter_function_call: K_slew K_LPAREN /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_RPAREN");    
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AnalogFilterFunctionCall("slew", $3, $5, $7, nullptr, nullptr, nullptr);
}
| K_last_crossing K_LPAREN /* analog_expression */ expression K_RPAREN
{
    yydebug("analog_filter_function_call: K_last_crossing K_LPAREN /* analog_expression */ expression K_RPAREN");    
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AnalogFilterFunctionCall("last_crossing", $3, nullptr, nullptr, nullptr, nullptr, nullptr);
}
| K_last_crossing K_LPAREN /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_RPAREN
{
    yydebug("analog_filter_function_call: K_last_crossing K_LPAREN /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_RPAREN");    
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AnalogFilterFunctionCall("last_crossing", $3, $5, nullptr, nullptr, nullptr, nullptr);
}
| K_limexp K_LPAREN /* analog_expression */ expression K_RPAREN
{
    yydebug("analog_filter_function_call: K_limexp K_LPAREN /* analog_expression */ expression K_RPAREN");    
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AnalogFilterFunctionCall("limexp", $3, nullptr, nullptr, nullptr, nullptr, nullptr);
}
| laplace_filter_name K_LPAREN /* analog_expression */ expression K_COMMA K_COMMA K_RPAREN
{
    yydebug("analog_filter_function_call: laplace_filter_name K_LPAREN /* analog_expression */ expression K_COMMA K_COMMA K_RPAREN");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AnalogFilterFunctionCallArg($1, $3, nullptr, nullptr, nullptr, nullptr, nullptr);
}
| laplace_filter_name K_LPAREN /* analog_expression */ expression K_COMMA K_COMMA K_COMMA expression K_RPAREN
{
    yydebug("analog_filter_function_call: laplace_filter_name K_LPAREN /* analog_expression */ expression K_COMMA expression K_RPAREN");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AnalogFilterFunctionCallArg($1, $3, nullptr, nullptr, $7, nullptr, nullptr);
}
| laplace_filter_name K_LPAREN /* analog_expression */ expression K_COMMA analog_filter_function_arg K_COMMA K_RPAREN
{
    yydebug("analog_filter_function_call: laplace_filter_name K_LPAREN /* analog_expression */ expression K_COMMA analog_filter_function_arg K_COMMA K_RPAREN");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AnalogFilterFunctionCallArg($1, $3, $5, nullptr, nullptr, nullptr, nullptr);
}
| laplace_filter_name K_LPAREN /* analog_expression */ expression K_COMMA analog_filter_function_arg K_COMMA K_COMMA expression K_RPAREN
{
    yydebug("analog_filter_function_call: laplace_filter_name K_LPAREN /* analog_expression */ expression K_COMMA analog_filter_function_arg K_COMMA K_COMMA expression K_RPAREN");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AnalogFilterFunctionCallArg($1, $3, $5, nullptr, $8, nullptr, nullptr);
}
| laplace_filter_name K_LPAREN /* analog_expression */ expression K_COMMA analog_filter_function_arg K_COMMA analog_filter_function_arg K_RPAREN
{
    yydebug("analog_filter_function_call: laplace_filter_name K_LPAREN /* analog_expression */ expression K_COMMA analog_filter_function_arg K_COMMA analog_filter_function_arg K_RPAREN");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AnalogFilterFunctionCallArg($1, $3, $5, $7, nullptr, nullptr, nullptr);
}
| laplace_filter_name K_LPAREN /* analog_expression */ expression K_COMMA analog_filter_function_arg K_COMMA analog_filter_function_arg K_COMMA expression K_RPAREN
{
    yydebug("analog_filter_function_call: laplace_filter_name K_LPAREN /* analog_expression */ expression K_COMMA analog_filter_function_arg K_COMMA analog_filter_function_arg K_COMMA expression K_RPAREN");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AnalogFilterFunctionCallArg($1, $3, $5, $7, $9, nullptr, nullptr);
}
| laplace_filter_name K_LPAREN /* analog_expression */ expression K_COMMA K_COMMA analog_filter_function_arg K_COMMA expression K_RPAREN
{
    yydebug("analog_filter_function_call: laplace_filter_name K_LPAREN /* analog_expression */ expression K_COMMA K_COMMA analog_filter_function_arg K_COMMA expression K_RPAREN");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AnalogFilterFunctionCallArg($1, $3, nullptr, $6, $8, nullptr, nullptr);
}
| zi_filter_name K_LPAREN /* analog_expression */ expression K_COMMA K_COMMA K_COMMA expression K_RPAREN
{
    yydebug("analog_filter_function_call: zi_filter_name K_LPAREN /* analog_expression */ expression K_COMMA K_COMMA K_COMMA expression K_RPAREN");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AnalogFilterFunctionCallArg($1, $3, nullptr, nullptr, $7, nullptr, nullptr);
}
| zi_filter_name K_LPAREN /* analog_expression */ expression K_COMMA analog_filter_function_arg K_COMMA K_COMMA expression K_RPAREN
{
    yydebug("analog_filter_function_call: zi_filter_name K_LPAREN /* analog_expression */ expression K_COMMA analog_filter_function_arg K_COMMA K_COMMA expression K_RPAREN");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AnalogFilterFunctionCallArg($1, $3, $5, nullptr, $8, nullptr, nullptr);
}
| zi_filter_name K_LPAREN /* analog_expression */ expression K_COMMA analog_filter_function_arg K_COMMA analog_filter_function_arg K_COMMA expression K_RPAREN
{
    yydebug("analog_filter_function_call: zi_filter_name K_LPAREN /* analog_expression */ expression K_COMMA analog_filter_function_arg K_COMMA analog_filter_function_arg K_COMMA expression K_RPAREN");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AnalogFilterFunctionCallArg($1, $3, $5, $7, $9, nullptr, nullptr);
}
| zi_filter_name K_LPAREN /* analog_expression */ expression K_COMMA analog_filter_function_arg K_COMMA analog_filter_function_arg K_COMMA expression K_COMMA /* analog_expression */ expression K_RPAREN
{
    yydebug("analog_filter_function_call: zi_filter_name K_LPAREN /* analog_expression */ expression K_COMMA analog_filter_function_arg K_COMMA analog_filter_function_arg K_COMMA expression K_COMMA /* analog_expression */ expression K_RPAREN");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AnalogFilterFunctionCallArg($1, $3, $5, $7, $9, $11, nullptr);
}
| zi_filter_name K_LPAREN /* analog_expression */ expression K_COMMA analog_filter_function_arg K_COMMA analog_filter_function_arg K_COMMA expression K_COMMA /* analog_expression */ expression K_COMMA expression K_RPAREN
{
    yydebug("analog_filter_function_call: zi_filter_name K_LPAREN /* analog_expression */ expression K_COMMA analog_filter_function_arg K_COMMA analog_filter_function_arg K_COMMA expression K_COMMA /* analog_expression */ expression K_COMMA expression K_RPAREN");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AnalogFilterFunctionCallArg($1, $3, $5, $7, $9, $11, $13);
};

// NOTE: disabled in 'primary'
analog_small_signal_function_call:
K_ac_stim K_LPAREN K_RPAREN
{
    yydebug("analog_small_signal_function_call: K_ac_stim K_LPAREN K_RPAREN");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AnalogSmallSignalFunctionCall("ac_stim", nullptr, nullptr, nullptr);
}
| K_ac_stim K_LPAREN '"' IDENTIFIER '"' K_RPAREN
{
    yydebug("analog_small_signal_function_call: K_ac_stim K_LPAREN \" IDENTIFIER \" K_RPAREN");
    RULE_BREAK_MACRO
    StringValue * t = new StringValue($4);
    parserInstance->setCodeInfo(t);
    $$ = parserInstance->parse_AnalogSmallSignalFunctionCall("ac_stim", t, nullptr, nullptr);
    free($4);
}
| K_ac_stim K_LPAREN '"' IDENTIFIER '"' K_COMMA /* analog_expression */ expression K_RPAREN
{
    yydebug("analog_small_signal_function_call: K_ac_stim K_LPAREN \" IDENTIFIER \" K_COMMA /* analog_expression */ expression K_RPAREN");
    RULE_BREAK_MACRO
    StringValue * t = new StringValue($4);
    parserInstance->setCodeInfo(t);
    $$ = parserInstance->parse_AnalogSmallSignalFunctionCall("ac_stim", t, $7, nullptr);
    free($4);
}
| K_ac_stim K_LPAREN '"' IDENTIFIER '"' K_COMMA /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_RPAREN
{
    yydebug("analog_small_signal_function_call: K_ac_stim K_LPAREN \" IDENTIFIER \" K_COMMA /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_RPAREN");
    RULE_BREAK_MACRO
    StringValue * t = new StringValue($4);
    parserInstance->setCodeInfo(t);
    $$ = parserInstance->parse_AnalogSmallSignalFunctionCall("ac_stim", t, $7, $9);
    free($4);
}
| K_white_noise K_LPAREN /* analog_expression */ expression K_RPAREN
{
    yydebug("analog_small_signal_function_call: K_white_noise K_LPAREN /* analog_expression */ expression K_RPAREN");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AnalogSmallSignalFunctionCall("white_noise", $3, nullptr, nullptr);
}
| K_white_noise K_LPAREN /* analog_expression */ expression K_COMMA STRING K_RPAREN
{
    yydebug("analog_small_signal_function_call: K_white_noise K_LPAREN /* analog_expression */ expression K_COMMA STRING K_RPAREN");
    RULE_BREAK_MACRO
    StringValue * t = new StringValue($5);
    parserInstance->setCodeInfo(t);
    $$ = parserInstance->parse_AnalogSmallSignalFunctionCall("white_noise", $3, t, nullptr);
    free($5);
}
| K_flicker_noise K_LPAREN /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_RPAREN
{
    yydebug("analog_small_signal_function_call: K_flicker_noise K_LPAREN /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_RPAREN");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AnalogSmallSignalFunctionCall("flicker_noise", $3, $5, nullptr);
}
| K_flicker_noise K_LPAREN /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_COMMA STRING K_RPAREN
{
    yydebug("analog_small_signal_function_call: K_flicker_noise K_LPAREN /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_COMMA STRING K_RPAREN");
    RULE_BREAK_MACRO
    StringValue * t = new StringValue($7);
    parserInstance->setCodeInfo(t);
    $$ = parserInstance->parse_AnalogSmallSignalFunctionCall("flicker_noise", $3, $5, t);
    free($7);
}
| K_noise_table K_LPAREN noise_table_input_arg K_RPAREN
{
    yydebug("analog_small_signal_function_call: K_noise_table K_LPAREN noise_table_input_arg K_RPAREN");
    RULE_BREAK_MACRO
    StringValue * t = new StringValue($3);
    parserInstance->setCodeInfo(t);
    $$ = parserInstance->parse_AnalogSmallSignalFunctionCall("noise_table", t, nullptr, nullptr);
    free($3);
}
| K_noise_table K_LPAREN noise_table_input_arg K_COMMA STRING K_RPAREN
{
    yydebug("analog_small_signal_function_call: K_noise_table K_LPAREN noise_table_input_arg K_COMMA STRING K_RPAREN");
    RULE_BREAK_MACRO
    StringValue * t = new StringValue($3);
    parserInstance->setCodeInfo(t);
    StringValue * t2 = new StringValue($5);
    parserInstance->setCodeInfo(t2);
    $$ = parserInstance->parse_AnalogSmallSignalFunctionCall("noise_table", t, t2, nullptr);
    free($3);
    free($5);
};

noise_table_input_arg:
/* parameter_identifier */ IDENTIFIER
{
    yydebug("noise_table_input_arg: IDENTIFIER");
    RULE_BREAK_MACRO $$ = $1;
}
//| parameter_identifier msb_constant_expression K_COLON lsb_constant_expression
| IDENTIFIER expression K_COLON expression
{
    yydebug("noise_table_input_arg: IDENTIFIER expression K_COLON expression");
    yyerror("noise_table_input_arg: IDENTIFIER expression K_COLON expression is not supported");
}
| STRING
{
    yydebug("noise_table_input_arg: STRING");
    yyerror("noise_table_input_arg: STRING is not supported");
}
| constant_arrayinit
{
    yydebug("noise_table_input_arg: constant_arrayinit");
    yyerror("noise_table_input_arg: constant_arrayinit is not supported");
};

laplace_filter_name:
K_laplace_zd
{
    yydebug("laplace_filter_name: K_laplace_zd");
    RULE_BREAK_MACRO $$ = hif::application_utils::hif_strdup("laplace_zd");
}
| K_laplace_zp 
{
    yydebug("laplace_filter_name: K_laplace_zp");
    RULE_BREAK_MACRO $$ = hif::application_utils::hif_strdup("laplace_zp");
}
| K_laplace_np
{
    yydebug("laplace_filter_name: K_laplace_np");
    RULE_BREAK_MACRO $$ = hif::application_utils::hif_strdup("laplace_np");
}
| K_laplace_nd
{
    yydebug("laplace_filter_name: K_laplace_nd");
    RULE_BREAK_MACRO $$ = hif::application_utils::hif_strdup("laplace_nd");
};

zi_filter_name:
K_zi_zp
{
    yydebug("zi_filter_name: K_zi_zp");
    RULE_BREAK_MACRO $$ = hif::application_utils::hif_strdup("zi_zp");
}
| K_zi_zd
{
    yydebug("zi_filter_name: K_zi_zd");
    RULE_BREAK_MACRO $$ = hif::application_utils::hif_strdup("zi_zd");
}
| K_zi_np 
{
    yydebug("zi_filter_name: K_zi_np");
    RULE_BREAK_MACRO $$ = hif::application_utils::hif_strdup("zi_np");
}
| K_zi_nd
{
    yydebug("zi_filter_name: K_zi_nd");
    RULE_BREAK_MACRO $$ = hif::application_utils::hif_strdup("zi_nd");
};


branch_probe_function_call:
nature_attribute_identifier K_LPAREN /*branch_reference*/ hierarchical_identifier K_RPAREN
{
    yydebug("branch_probe_function_call: nature_attribute_identifier K_LPAREN /*branch_reference*/ hierarchical_identifier K_RPAREN");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_BranchProbeFunctionCall($1, $3, nullptr);
}
|  nature_attribute_identifier K_LPAREN /* analog_net_reference */ /* analog_reference */ hierarchical_identifier 
K_COMMA /* analog_net_reference */ /* analog_reference */ hierarchical_identifier K_RPAREN
{
    yydebug("branch_probe_function_call: nature_attribute_identifier K_LPAREN "
            "/* analog_net_reference */ /* analog_reference */ hierarchical_identifier"
            "K_COMMA /* analog_net_reference */ /* analog_reference */ hierarchical_identifier K_RPAREN");

    RULE_BREAK_MACRO
    $$ = parserInstance->parse_BranchProbeFunctionCall($1, $3, $5);
};

port_probe_function_call:
nature_attribute_identifier K_LPAREN K_LT /* analog_port_reference */ /* analog_reference */ hierarchical_identifier  K_GT K_RPAREN
{
    yydebug("port_probe_function_call: nature_attribute_identifier K_LPAREN K_LT /* analog_port_reference */ /* analog_reference */ hierarchical_identifier  K_GT K_RPAREN");
    yyerror("port_probe_function_call: nature_attribute_identifier K_LPAREN K_LT /* analog_port_reference */ /* analog_reference */ hierarchical_identifier  K_GT K_RPAREN is not supported");
};

//constant_analog_function_call:
///* analog_function_identifier */ IDENTIFIER attribute_instance_list K_LPAREN constant_expression_list K_RPAREN;

//constant_analog_built_in_function_call:
//analog_built_in_function_name K_LPAREN constant_expression K_RPAREN
//| analog_built_in_function_name K_LPAREN constant_expression K_COMMA constant_expression K_RPAREN;

// <-- ** VERILOG_AMS **


/* -----------------------------------------------------------------------
 *  EXPRESSIONS ( ** VERILOG_AMS ** )
 * -----------------------------------------------------------------------
 */

//abstol_expression:
///* constant_expression */ expression
//{
//    yyerror("VERILOG-AMS IS NOT YET SUPPORTED: abstol_expression 1");
//}
//| /* nature_identifier */ IDENTIFIER
//{
//    yyerror("VERILOG-AMS IS NOT YET SUPPORTED: abstol_expression 2");
//};

constant_expression_or_null:
/* empty */
{
    yydebug("constant_expression_or_null: /* empty */");
    RULE_BREAK_MACRO $$ = nullptr;

}
| /* constant_expression */ expression
{
    yydebug("constant_expression_or_null: /* constant_expression */ expression");
    RULE_BREAK_MACRO $$ = $1;
};

indirect_expression:
branch_probe_function_call
{
    yydebug("indirect_expression: branch_probe_function_call");
    RULE_BREAK_MACRO $$ = $1;
}
| port_probe_function_call
{
    yydebug("indirect_expression: port_probe_function_call");
    yyerror("indirect_expression: port_probe_function_call is not supported");
}
| K_ddt K_LPAREN branch_probe_function_call K_RPAREN
{
    yydebug("indirect_expression: K_ddt K_LPAREN branch_probe_function_call K_RPAREN");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AnalogDifferentialFunctionCall("ddt", $3);
}
| K_ddt K_LPAREN branch_probe_function_call K_COMMA /* abstol_expression */ expression K_RPAREN
{
    yydebug("indirect_expression: K_ddt K_LPAREN branch_probe_function_call K_COMMA /* abstol_expression */ expression K_RPAREN");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AnalogDifferentialFunctionCall("ddt", $3, $5);
}
| K_ddt K_LPAREN port_probe_function_call K_RPAREN
{
    yydebug("indirect_expression: K_ddt K_LPAREN port_probe_function_call K_RPAREN");
    yyerror("indirect_expression: K_ddt K_LPAREN port_probe_function_call K_RPAREN is not supported");
}
| K_ddt K_LPAREN port_probe_function_call K_COMMA /* abstol_expression */ expression K_RPAREN
{
    yydebug("indirect_expression: K_ddt K_LPAREN port_probe_function_call K_COMMA /* abstol_expression */ expression K_RPAREN");
    yyerror("indirect_expression: K_ddt K_LPAREN port_probe_function_call K_COMMA /* abstol_expression */ expression K_RPAREN is not supported");
}
| K_idt K_LPAREN branch_probe_function_call K_RPAREN
{
    yydebug("indirect_expression: K_idt K_LPAREN branch_probe_function_call K_RPAREN");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AnalogDifferentialFunctionCall("idt", $3);
}
| K_idt K_LPAREN branch_probe_function_call K_COMMA /* analog_expression */ expression K_RPAREN
{
    yydebug("indirect_expression: K_idt K_LPAREN branch_probe_function_call K_COMMA /* analog_expression */ expression K_RPAREN");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AnalogDifferentialFunctionCall("idt", $3, $5);
}
| K_idt K_LPAREN branch_probe_function_call K_COMMA /* analog_expression */ expression K_COMMA
/* analog_expression */ expression K_RPAREN
{
    yydebug("indirect_expression: K_idt K_LPAREN branch_probe_function_call K_COMMA "
            "/* analog_expression */ expression K_COMMA /* analog_expression */ expression K_RPAREN");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AnalogDifferentialFunctionCall("idt", $3, $5, $7);
}
| K_idt K_LPAREN branch_probe_function_call K_COMMA /* analog_expression */ expression K_COMMA
/* analog_expression */ expression K_COMMA /* abstol_expression */ expression K_RPAREN
{
    yydebug("indirect_expression: K_idt K_LPAREN branch_probe_function_call K_COMMA /* analog_expression */ expression K_COMMA "
            "/* analog_expression */ expression K_COMMA /* abstol_expression */ expression K_RPAREN");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AnalogDifferentialFunctionCall("idt", $3, $5, $7, $9);
}
| K_idt K_LPAREN port_probe_function_call K_RPAREN
{
    yydebug("indirect_expression: K_idt K_LPAREN port_probe_function_call K_RPAREN");
    yyerror("indirect_expression: K_idt K_LPAREN port_probe_function_call K_RPAREN is not supported");
}
| K_idt K_LPAREN port_probe_function_call K_COMMA /* analog_expression */ expression K_RPAREN
{
    yydebug("indirect_expression: K_idt K_LPAREN port_probe_function_call K_COMMA /* analog_expression */ expression K_RPAREN");
    yyerror("indirect_expression: K_idt K_LPAREN port_probe_function_call K_COMMA /* analog_expression */ expression K_RPAREN is not supported");
}
| K_idt K_LPAREN port_probe_function_call K_COMMA /* analog_expression */ expression K_COMMA
/* analog_expression */ expression K_RPAREN
{
    yydebug("indirect_expression: K_idt K_LPAREN port_probe_function_call K_COMMA /* analog_expression */ "
            "expression K_COMMA /* analog_expression */ expression K_RPAREN");
    yyerror("indirect_expression: K_idt K_LPAREN port_probe_function_call K_COMMA /* analog_expression */ "
            "expression K_COMMA /* analog_expression */ expression K_RPAREN is not supported");
}
| K_idt K_LPAREN port_probe_function_call K_COMMA /* analog_expression */ expression K_COMMA
/* analog_expression */ expression K_COMMA /* abstol_expression */ expression K_RPAREN
{
    yydebug("indirect_expression: K_idt K_LPAREN port_probe_function_call K_COMMA /* analog_expression */ "
            "expression K_COMMA /* analog_expression */ expression K_COMMA /* abstol_expression */ expression K_RPAREN");
    yyerror("indirect_expression: K_idt K_LPAREN port_probe_function_call K_COMMA /* analog_expression */ "
            "expression K_COMMA /* analog_expression */ expression K_COMMA /* abstol_expression */ expression K_RPAREN is not supported");
}
| K_idtmod K_LPAREN branch_probe_function_call K_RPAREN
{
    yydebug("indirect_expression: K_idtmod K_LPAREN branch_probe_function_call K_RPAREN");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AnalogDifferentialFunctionCall("idtmod", $3);
}
| K_idtmod K_LPAREN branch_probe_function_call K_COMMA /* analog_expression */ expression K_RPAREN
{
    yydebug("indirect_expression: K_idtmod K_LPAREN branch_probe_function_call K_COMMA /* analog_expression */ expression K_RPAREN");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AnalogDifferentialFunctionCall("idtmod", $3, $5);
}
| K_idtmod K_LPAREN branch_probe_function_call K_COMMA /* analog_expression */ expression K_COMMA
/* analog_expression */ expression K_RPAREN
{
    yydebug("indirect_expression: K_idtmod K_LPAREN branch_probe_function_call K_COMMA /* analog_expression */ "
            "expression K_COMMA /* analog_expression */ expression K_RPAREN");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AnalogDifferentialFunctionCall("idtmod", $3, $5, $7);
}
| K_idtmod K_LPAREN branch_probe_function_call K_COMMA /* analog_expression */ expression K_COMMA
/* analog_expression */ expression K_COMMA /* analog_expression */ expression K_RPAREN
{
    yydebug("indirect_expression: K_idtmod K_LPAREN branch_probe_function_call K_COMMA /* analog_expression */ expression K_COMMA "
            "/* analog_expression */ expression K_COMMA /* analog_expression */ expression K_RPAREN");
    yyerror("indirect_expression: K_idtmod K_LPAREN branch_probe_function_call K_COMMA /* analog_expression */ expression K_COMMA "
            "/* analog_expression */ expression K_COMMA /* analog_expression */ expression K_RPAREN is not supported");
}
| K_idtmod K_LPAREN branch_probe_function_call K_COMMA /* analog_expression */ expression K_COMMA
/* analog_expression */ expression K_COMMA /* analog_expression */ expression K_COMMA /* abstol_expression */ expression K_RPAREN
{
    yydebug("indirect_expression: K_idtmod K_LPAREN branch_probe_function_call K_COMMA /* analog_expression */ expression K_COMMA /* analog_expression */ "
            "expression K_COMMA /* analog_expression */ expression K_COMMA /* abstol_expression */ expression K_RPAREN");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_AnalogDifferentialFunctionCall("idtmod", $3, $5, $7, $9);
}
| K_idtmod K_LPAREN port_probe_function_call K_RPAREN
{
    yydebug("indirect_expression: K_idtmod K_LPAREN port_probe_function_call K_RPAREN");
    yyerror("indirect_expression: K_idtmod K_LPAREN port_probe_function_call K_RPAREN is not supported");
}
| K_idtmod K_LPAREN port_probe_function_call K_COMMA /* analog_expression */ expression K_RPAREN
{
    yydebug("indirect_expression: K_idtmod K_LPAREN port_probe_function_call K_COMMA /* analog_expression */ expression K_RPAREN");
    yyerror("indirect_expression: K_idtmod K_LPAREN port_probe_function_call K_COMMA /* analog_expression */ expression K_RPAREN is not supported");
}
| K_idtmod K_LPAREN port_probe_function_call K_COMMA /* analog_expression */ expression K_COMMA
/* analog_expression */ expression K_RPAREN
{
    yydebug("indirect_expression: K_idtmod K_LPAREN port_probe_function_call K_COMMA /* analog_expression */ "
            "expression K_COMMA /* analog_expression */ expression K_RPAREN");
    yyerror("indirect_expression: K_idtmod K_LPAREN port_probe_function_call K_COMMA /* analog_expression */ "
            "expression K_COMMA /* analog_expression */ expression K_RPAREN is not supported");
}
| K_idtmod K_LPAREN port_probe_function_call K_COMMA /* analog_expression */ expression K_COMMA
/* analog_expression */ expression K_COMMA /* analog_expression */ expression K_RPAREN
{
    yydebug("indirect_expression: K_idtmod K_LPAREN port_probe_function_call K_COMMA /* analog_expression */ expression K_COMMA "
            "/* analog_expression */ expression K_COMMA /* analog_expression */ expression K_RPAREN");
    yyerror("indirect_expression: K_idtmod K_LPAREN port_probe_function_call K_COMMA /* analog_expression */ expression K_COMMA "
            "/* analog_expression */ expression K_COMMA /* analog_expression */ expression K_RPAREN is not supported");
}
| K_idtmod K_LPAREN port_probe_function_call K_COMMA /* analog_expression */ expression K_COMMA /* analog_expression */ expression K_COMMA
/* analog_expression */ expression K_COMMA /* abstol_expression */ expression K_RPAREN
{
    yydebug("indirect_expression: K_idtmod K_LPAREN port_probe_function_call K_COMMA /* analog_expression */ expression K_COMMA "
            "/* analog_expression */ expression K_COMMA /* analog_expression */ expression K_COMMA /* abstol_expression */ expression K_RPAREN");
    yyerror("indirect_expression: K_idtmod K_LPAREN port_probe_function_call K_COMMA /* analog_expression */ expression K_COMMA "
            "/* analog_expression */ expression K_COMMA /* analog_expression */ expression K_COMMA /* abstol_expression */ expression K_RPAREN is not supported");
};


/* -----------------------------------------------------------------------
 *  EXPRESSIONS - PRIMARIES
 * -----------------------------------------------------------------------
 */

primary:
number
{
    yydebug("primary: number");
    RULE_BREAK_MACRO $$ = $1;
}
// hierarchical_identifier expression_list_range_expression_opt
| hierarchical_identifier %prec LOW
{
    yydebug("primary: hierarchical_identifier");
    RULE_BREAK_MACRO $$ = $1;
}
// TODO: check syntax (conflicts with lvalue)
//| hierarchical_identifier bracket_range_expression_list
//{
//    yydebug("primary: hierarchical_identifier expression_list_range_expression_opt");
//    RULE_BREAK_MACRO $$ = parserInstance->parse_PrimaryListOfMemberOrSlice( $1, $2 );
//}
| concatenation
{
    yydebug("primary: concatenation");
    RULE_BREAK_MACRO $$ = parserInstance->parse_Concatenation( $1 );
}
| multiple_concatenation
{
    yydebug("primary: multiple_concatenation");
    RULE_BREAK_MACRO $$ = $1;
}

//| FUNCTION_CALL -->
| hierarchical_identifier K_LPAREN K_RPAREN  %prec HIGH
{
    yydebug("primary: hierarchical_identifier attribute_instance_list K_LPAREN K_RPAREN");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FunctionCall( $1, nullptr );
}
| hierarchical_identifier K_LPAREN comma_expression_list K_RPAREN  %prec HIGH
{
    yydebug("primary: hierarchical_identifier attribute_instance_list K_LPAREN comma_expression_list K_RPAREN");
    RULE_BREAK_MACRO $$ = parserInstance->parse_FunctionCall( $1, $3 );
}
| hierarchical_identifier attribute_instance_list_no_empty K_LPAREN comma_expression_list K_RPAREN
{
    yydebug("primary: hierarchical_identifier attribute_instance_list K_LPAREN comma_expression_list K_RPAREN");
    yyerror("primary: hierarchical_identifier attribute_instance_list K_LPAREN comma_expression_list K_RPAREN is not supported.");
}
// <-- FUNCTION_CALL

//| SYSTEM_FUNCTION_CALL -->
| /* system_function_identifier */ SYSTEM_IDENTIFIER %prec MEDIUM1
{
    yydebug("primary: /* system_function_identifier */ SYSTEM_IDENTIFIER");
    RULE_BREAK_MACRO 
    $$ = parserInstance->parse_FunctionCall( new Identifier($1), nullptr );
    free($1);
}
| /* system_function_identifier */ SYSTEM_IDENTIFIER K_LPAREN K_RPAREN %prec MEDIUM2
{
    yydebug("primary: /* system_function_identifier */ SYSTEM_IDENTIFIER K_LPAREN K_RPAREN");
    RULE_BREAK_MACRO 
    $$ = parserInstance->parse_FunctionCall( new Identifier($1), nullptr );
    free($1);
}
| /* system_function_identifier */ SYSTEM_IDENTIFIER K_LPAREN comma_expression_list K_RPAREN %prec MEDIUM3
{
    yydebug("primary: /* system_function_identifier */ SYSTEM_IDENTIFIER K_LPAREN comma_expression_list K_RPAREN");
    RULE_BREAK_MACRO 
    $$ = parserInstance->parse_FunctionCall( new Identifier($1), $3 );
    free($1);
}
// <-- SYSTEM_FUNCTION_CALL

// | K_LPAREN expression K_RPAREN
// | K_LPAREN /* analog_expression */ expression K_RPAREN
| K_LPAREN mintypmax_expression K_RPAREN
{
    yydebug("primary: K_LPAREN mintypmax_expression K_RPAREN");
    RULE_BREAK_MACRO $$ = $2;
}
| STRING
{
    yydebug("primary: STRING");
    RULE_BREAK_MACRO
    $$ = new StringValue($1);
    free($1);
}
// ** VERILOG_AMS ** -->
//| nature_attribute_reference
| /* net_identifier */ hierarchical_identifier K_DOT K_potential K_DOT nature_attribute_identifier
{
    yydebug("primary: /* net_identifier */ hierarchical_identifier K_DOT K_potential K_DOT nature_attribute_identifier");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_NatureAttributeReference($1, "potential", $5);
}
| /* net_identifier */ hierarchical_identifier K_DOT K_flow K_DOT nature_attribute_identifier
{
    yydebug("primary: /* net_identifier */ hierarchical_identifier K_DOT K_flow K_DOT nature_attribute_identifier");
    RULE_BREAK_MACRO
    $$ = parserInstance->parse_NatureAttributeReference($1, "flow", $5);
}

// NOTE: recognized by function_call
//| branch_probe_function_call

//| port_probe_function_call
| /* nature_attribute_identifier */ hierarchical_identifier K_LPAREN K_LT /* analog_port_reference */ /* analog_reference */ hierarchical_identifier K_GT K_RPAREN
{
    yydebug("primary: /* nature_attribute_identifier */ hierarchical_identifier K_LPAREN K_LT /* analog_port_reference */ analog_reference K_GT K_RPAREN");
    RULE_BREAK_MACRO $$ = parserInstance->parse_AmsFlowOfPort($1, $4);
}

// NOTE: recognized by function_call
//| analog_function_call

// NOTE: recognized by function_call
//| analog_system_function_call

| analog_built_in_function_call
{
    yydebug("primary: analog_built_in_function_call");    
    RULE_BREAK_MACRO $$ = $1; 
}
| analog_filter_function_call
{
    yydebug("primary: analog_filter_function_call");    
    RULE_BREAK_MACRO $$ = $1; 
}
| analog_small_signal_function_call
{
    yydebug("primary: analog_small_signal_function_call");
    RULE_BREAK_MACRO $$ = $1;
}
| analysis_function_call
{
    yydebug("primary: analysis_function_call");
    RULE_BREAK_MACRO $$ = $1;
}
// <-- ** VERILOG_AMS **
;

/*
 * [ { '[' expression ']' } '[' range_expression ']' ]
 * 
 */
//expression_list_range_expression_opt:
///* empty */
//{
//    yydebug("expression_list_range_expression_opt: /* empty */");
//    // $$ = nullptr;
//}
//| bracket_expression_list K_LBRACKET range_expression K_RBRACKET
//{
//    yydebug("expression_list_range_expression_opt: bracket_expression_list K_LBRACKET range_expression K_RBRACKET");
//    yyerror("expression_list_range_expression_opt: bracket_expression_list K_LBRACKET range_expression K_RBRACKET is not supported.");
//};


bracket_expression_list:
K_LBRACKET expression K_RBRACKET
{
    yydebug("bracket_expression_list: K_LBRACKET expression K_RBRACKET");
    RULE_BREAK_MACRO
    $$ = new BList<Value>();
    $$->push_back( $2 );
}
| bracket_expression_list K_LBRACKET expression K_RBRACKET
{
    yydebug("bracket_expression_list: bracket_expression_list K_LBRACKET expression K_RBRACKET");
    RULE_BREAK_MACRO
    $$ = $1;
    $$->push_back( $3 );
};

bracket_range_expression_list:
K_LBRACKET range_expression K_RBRACKET
{
    yydebug("bracket_range_expression_list: K_LBRACKET expression K_RBRACKET");
    RULE_BREAK_MACRO
    $$ = new BList<Value>();
    $$->push_back( $2 );
}
| bracket_range_expression_list K_LBRACKET range_expression K_RBRACKET
{
    yydebug("bracket_range_expression_list: bracket_range_expression_list K_LBRACKET expression K_RBRACKET");
    RULE_BREAK_MACRO
    $$ = $1;
    $$->push_back( $3 );
};


constant_bracket_range_expression_opt:
/* empty */
{
    yydebug("constant_bracket_range_expression_opt: /* empty */");
    RULE_BREAK_MACRO $$ = nullptr;
}
| K_LBRACKET /*constant_range_expression*/ range_expression K_RBRACKET
{
    yydebug("constant_bracket_range_expression_opt: K_LBRACKET /*constant_range_expression*/ range_expression K_RBRACKET");
    RULE_BREAK_MACRO $$ = $2;
};

//module_path_primary:
//number
//| IDENTIFIER
//| module_path_concatenation
//| module_path_multiple_concatenation
//| function_call
//| system_function_call
//| K_LPAREN module_path_mintypmax_expression K_RPAREN;


// ** VERILOG_AMS ** -->

//analog_primary:
//primary
//{
//    yyerror("VERILOG-AMS IS NOT YET SUPPORTED: analog_primary");
//};

//number /**/
//| analog_concatenation /**/ 
//| analog_multiple_concatenation /**/ 
//| /* genvar_identifier */ IDENTIFIER
//// | parameter_reference
//| IDENTIFIER K_LBRACKET /* analog_expression */ expression K_RBRACKET 
//// | variable_reference
//| IDENTIFIER K_LBRACKET /* analog_expression */ expression K_RBRACKET analog_expression_bracket_list
////| net_reference
//| hierarchical_identifier
//| hierarchical_identifier K_LBRACKET analog_range_expression K_RBRACKET
////| nature_attribute_reference
//| /* net_identifier */ IDENTIFIER K_DOT K_potential K_DOT nature_attribute_identifier
//| /* net_identifier */ IDENTIFIER K_DOT K_flow K_DOT nature_attribute_identifier
//| branch_probe_function_call
//| port_probe_function_call
//| analog_function_call
//| analog_system_function_call
//| analog_built_in_function_call
//| analog_filter_function_call
//| analog_small_signal_function_call
//| analysis_function_call
//| K_LPAREN /* analog_expression */ expression K_RPAREN

// <-- ** VERILOG_AMS **


/* -----------------------------------------------------------------------
 *  EXPRESSIONS - LEFT-SIDE VALUES
 * -----------------------------------------------------------------------
 */

//net_lvalue:
///* hierarchical_net_identifier */ hierarchical_identifier %prec LOW
//| /* hierarchical_net_identifier */ hierarchical_identifier bracket_constant_expression_list K_LBRACKET range_expression K_RBRACKET %prec HIGH
//| K_LBRACE net_lvalue_list K_RBRACE;

//variable_lvalue:
///* hierarchical_variable_identifier */ hierarchical_identifier
//| /* hierarchical_variable_identifier */ hierarchical_identifier bracket_expression_list K_LBRACKET range_expression K_RBRACKET
//| K_LBRACE variable_lvalue_list K_RBRACE;

//net_lvalue_list:
//net_lvalue
//| net_lvalue_list K_COMMA net_lvalue;

//variable_lvalue_list:
//variable_lvalue
//| variable_lvalue_list K_COMMA variable_lvalue;

//lvalue_list:
//lvalue
//| lvalue_list K_COMMA lvalue;


lvalue:
hierarchical_identifier
{
    yydebug("lvalue: /* hierarchical_variable_identifier */ hierarchical_identifier");
    RULE_BREAK_MACRO $$ = $1;
}
//| /* hierarchical_variable_identifier */ hierarchical_identifier bracket_range_expression_list %prec HIGH
//{
//    yydebug("lvalue: /* hierarchical_variable_identifier */ hierarchical_identifier bracket_range_expression_list");
//    yyerror("lvalue: /* hierarchical_variable_identifier */ hierarchical_identifier bracket_range_expression_list is not supported");
//}
//| K_LBRACE /* lvalue_list */ comma_expression_list K_RBRACE
| concatenation
{
    yydebug("lvalue: concatenation");
    RULE_BREAK_MACRO $$ = parserInstance->parse_Concatenation( $1 );
};




/* -----------------------------------------------------------------------
 *  EXPRESSIONS - OPERATORS
 * -----------------------------------------------------------------------
 *
 *  In order to resolve conflicts and ambiguities, we define two productions that 
 *  covers binary operators. One of these productions generates the sub-set 
 *  of binary operators that can be also used as unary operator.
 *  Finally, we define a third production that generates the remaining unary operators.
 *
 */

/*  NOTE 4:
 * 
 * 
 *  unary_module_path_operator ::=
 *  K_EXCL | K_TILDE | K_AMPERSAND | '~&' | K_BAR | '~|' | K_CAP | '~^' | '^~'
 *
 *  binary_module_path_operator ::=
 *  '==' | '!=' | '&&' | '||' |' &' | K_BAR | K_CAP | '^~' | '~^'
 * 
 *  See production module_path_expression.
 **/ 

/*  NOTE 5:
 * 
 * 
 *  unary_operator:
 *  + | - | ! | ~ | & | K_NAND | | | K_NOR | ^ | K_NXOR| K_NXOR
 *
 *  binary_operator:
 *  + | - | * | / | % | == | != | === | !== | && | || | ** | < | <= | > | >= 
 *  | & | | | ^ | ^~ | ~^ | >> | << | >>> | <<<
 *
 **/

//unary_operator:
//unary_op_set_1
//{
//    return $1;
//}
//| unary_binary_op_set
//{
//    return $1;
//};

//binary_operator:
//unary_binary_op_set
//{
//    return $1;
//}
//| binary_op_set_1
//{
//    return $1;
//};

//unary_op_set_1:
//K_EXCL
//{    $$ = op_not;   }
//| K_TILDE
//{    $$ = op_bnot;  }
//| K_NAND
//{    
//    yydebug("unary_op_set_1: K_NAND.");
//    yyerror("unary_op_set_1: K_NAND is not supported.");
//}
//| K_NOR
//{    
//    yydebug("unary_op_set_1: K_NOR.");
//    yyerror("unary_op_set_1: K_NOR is not supported.");
//};


///*
// * Operators which can be used either as unary or as binary operators
// * 
// */
//unary_binary_op_set:
//K_PLUS     {    $$ = op_plus;  }
//| K_MINUS   {    $$ = op_minus; }
//| K_AMPERSAND   {    $$ = op_band;  }
//| K_BAR   {    $$ = op_bor;   }
//| K_CAP   {    $$ = op_bxor;  }
//| K_NXOR
//{
//    /*  ~^ and ^~   */
//    yydebug("unary_binary_op_set: K_NXOR.");
//    yyerror("unary_binary_op_set: K_NXOR is not supported.");
//};


//binary_op_set_1:
//K_STAR      {    $$ = op_mult;  }
//| K_SLASH   {    $$ = op_div;   }
//| K_PERC    {    $$ = op_mod;   }
//| K_EQEQ    {    $$ = op_eq;    }
//| K_NE      {    $$ = op_neq;   }
//| K_CEQ     {    $$ = op_case_eq;    }
//| K_CNE     {    $$ = op_case_neq;   }
//| K_LAND    {    $$ = op_and;   }
//| K_LOR     {    $$ = op_or;    }
//| K_LT      {    $$ = op_lt;    }
//| K_LE      {    $$ = op_le;    }
//| K_GT      {    $$ = op_gt;    }
//| K_GE      {    $$ = op_ge;    }
//| K_RS      {    $$ = op_srl;   }
//| K_RSS     {    $$ = op_sra;   }
//| K_LS      {    $$ = op_sll;   }
//| K_POW     {    $$ = op_pow;   };
///*
// * NOTE 6:
// * 
// * | '<<<'      Functionally, <<< is the same as <<.
// * 
// **/ 





/* -----------------------------------------------------------------------
 *  EXPRESSIONS - NUMBERS
 * -----------------------------------------------------------------------
 */


/*
 * real_number:
 * unsigned_number K_DOT unsigned_number
 * | unsigned_number dot_unsigned_number_opt exp sign_opt unsigned_number
 * | unsigned_number [ . unsigned_number ] scale_factor
 */
real_number:
REALTIME
{
    yydebug("real_number: REALTIME");
    RULE_BREAK_MACRO $$ = parserInstance->parse_RealTime( $1 );
};


unsigned_number:
DEC_NUMBER
{
    yydebug("unsigned_number: DEC_NUMBER");
    RULE_BREAK_MACRO $$ = parserInstance->parse_UnsignedNumber( $1 );
};


/*
 *  NOTE 7:
 * 
 * number ::= decimal_number | octal_number | binary_number | hex_number | real_number
 *  
 **/
number:
BASED_NUMBER
{
    yydebug("number: BASED_NUMBER");
    RULE_BREAK_MACRO $$ = parserInstance->parse_BasedNumber( $1 );
}
| DEC_NUMBER BASED_NUMBER
{
    yydebug("number: DEC_NUMBER BASED_NUMBER");
    RULE_BREAK_MACRO $$ = parserInstance->parse_DecBasedNumber( $1, $2 );
}
| DEC_NUMBER
{
    yydebug("number: DEC_NUMBER");
    RULE_BREAK_MACRO $$ = parserInstance->parse_DecNumber( $1 );
}
| REALTIME
{
    yydebug("number: REALTIME");
    RULE_BREAK_MACRO $$ = parserInstance->parse_RealTime( $1 );
};








/* -----------------------------------------------------------------------
 *  GENERAL - ATTRIBUTES
 * -----------------------------------------------------------------------
 */

attribute_instance:
//K_LPAREN K_STAR attr_spec_list K_STAR K_RPAREN
K_PSTAR attr_spec_list K_STARP
{
    yydebug("attribute_instance: K_PSTAR attr_spec_list K_STARP");
    // Attributes are ignored
};


attribute_instance_list:
/* empty */
{
    yydebug("attribute_instance_list: /* empty */");
}
| attribute_instance_list_no_empty
{
    yydebug("attribute_instance_list: attribute_instance_list_no_empty");
    // Attributes are ignored
};

attribute_instance_list_no_empty:
attribute_instance
{
    yydebug("attribute_instance_list_no_empty: attribute_instance");
    // Attributes are ignored
}
| attribute_instance_list_no_empty attribute_instance
{
    yydebug("attribute_instance_list_no_empty: attribute_instance_list_no_empty attribute_instance");
    // Attributes are ignored
};


attr_spec:
/* attr_name */ IDENTIFIER eq_constant_expression_opt
{
    yydebug("attr_spec: /* attr_name */ IDENTIFIER eq_constant_expression_opt");
	RULE_BREAK_MACRO
    free($1);
    delete $2;
    yywarning("Attributes are ignored.", nullptr);
}
| K_integer /* attr_name */ IDENTIFIER eq_constant_expression_opt
{
    yydebug("attr_spec: K_integer /* attr_name */ IDENTIFIER eq_constant_expression_opt");
    RULE_BREAK_MACRO
    free($2);
    delete $3;
    yywarning("Attributes are ignored.", nullptr);
}
;

attr_spec_list:
attr_spec
{
    yydebug("attr_spec_list: attr_spec_list_comma");
    // Attributes are ignored
}
| attr_spec_list K_COMMA
{
    yydebug("attr_spec_list: attr_spec_list K_COMMA");
    // Attributes are ignored
}
| attr_spec_list K_SEMICOLON
{
    yydebug("attr_spec_list: attr_spec_list K_SEMICOLON");
    // Attributes are ignored
}
| attr_spec_list K_COMMA attr_spec
{
    yydebug("attr_spec_list: attr_spec_list K_COMMA attr_spec");
    // Attributes are ignored
}
| attr_spec_list K_SEMICOLON attr_spec
{
    yydebug("attr_spec_list: attr_spec_list K_SEMICOLON attr_spec");
    // Attributes are ignored
};

/* -----------------------------------------------------------------------
 *  GENERAL - IDENTIFIERS
 * -----------------------------------------------------------------------
 */


/* hierarchical_identifier ::= { IDENTIFIER [ K_LBRACKET constant_expression K_RBRACKET ] . } IDENTIFIER */
hierarchical_identifier:
hierarchical_identifier_item
{
    yydebug("hierarchical_identifier: hierarchical_identifier_item");
    RULE_BREAK_MACRO $$ = $1;
}
| hierarchical_identifier K_DOT hierarchical_identifier_item
{
    yydebug("hierarchical_identifier: hierarchical_identifier K_DOT hierarchical_identifier_item");
    RULE_BREAK_MACRO $$ = parserInstance->parse_HierarchicalIdentifier( $1, $3 );
};

hierarchical_identifier_item:
IDENTIFIER
{
    yydebug("hierarchical_identifier_item: IDENTIFIER");
    RULE_BREAK_MACRO $$ = parserInstance->parse_HierarchicalIdentifierItem( $1 );
}
// ** VERILOG_AMS ** -->
// NOTE: see 'nature_attribute_identifier' rule
| K_abstol
{
    yydebug("hierarchical_identifier_item: K_abstol");
    yyerror("hierarchical_identifier_item: K_abstol is not supported");
}
| K_access
{
    yydebug("hierarchical_identifier_item: K_access");
    yyerror("hierarchical_identifier_item: K_access is not supported");
}
| K_ddt_nature
{
    yydebug("hierarchical_identifier_item: K_ddt_nature");
    yyerror("hierarchical_identifier_item: K_ddt_nature is not supported");
}
| K_idt_nature
{
    yydebug("hierarchical_identifier_item: K_idt_nature");
    yyerror("hierarchical_identifier_item: K_idt_nature is not supported");
}
| K_units
{
    yydebug("hierarchical_identifier_item: K_units");
    yyerror("hierarchical_identifier_item: K_units is not supported");
}
// <-- ** VERILOG_AMS **
| IDENTIFIER bracket_range_expression_list
{
    yydebug("hierarchical_identifier_item: IDENTIFIER bracket_range_expression_list");
    RULE_BREAK_MACRO $$ = parserInstance->parse_PrimaryListOfMemberOrSlice( $1, $2 );
};


identifier_opt:
/* empty */
{
    yydebug("identifier_opt: /* empty */");
    RULE_BREAK_MACRO $$ = nullptr;
}
| IDENTIFIER
{
    yydebug("identifier_opt: IDENTIFIER");
    RULE_BREAK_MACRO
    $$ = new Identifier( $1 );
    free($1);
};

// ** VERILOG_AMS ** -->
analog_reference:
IDENTIFIER
{
    yydebug("analog_reference: IDENTIFIER");
    RULE_BREAK_MACRO
    $$ = new Identifier($1);
    parserInstance->setCodeInfo($$);
    free($1);
}
| IDENTIFIER K_LBRACKET /* constant_expression */ expression K_RBRACKET
{
    yydebug("analog_reference: IDENTIFIER K_LBRACKET /* constant_expression */ expression K_RBRACKET");
    yyerror("analog_reference: IDENTIFIER K_LBRACKET /* constant_expression */ expression K_RBRACKET is not supported");
};

nature_attribute_identifier:
K_abstol
{
    yydebug("nature_attribute_identifier: K_abstol");
    RULE_BREAK_MACRO $$ = new Identifier("abstol");
    parserInstance->setCodeInfo($$);

}
| K_access
{
    yydebug("nature_attribute_identifier: K_access");
    RULE_BREAK_MACRO $$ = new Identifier("access");
    parserInstance->setCodeInfo($$);
}
| K_ddt_nature
{
    yydebug("nature_attribute_identifier: K_ddt_nature");
    RULE_BREAK_MACRO $$ = new Identifier("ddt_nature");
    parserInstance->setCodeInfo($$);
}
| K_idt_nature
{
    yydebug("nature_attribute_identifier: K_idt_nature");
    RULE_BREAK_MACRO $$ = new Identifier("idt_nature");
    parserInstance->setCodeInfo($$);
}
| K_units
{
    yydebug("nature_attribute_identifier: K_units");
    RULE_BREAK_MACRO $$ = new Identifier("units");
    parserInstance->setCodeInfo($$);
}
| IDENTIFIER
{
    yydebug("nature_attribute_identifier: IDENTIFIER");
    RULE_BREAK_MACRO $$ = new Identifier($1);
    parserInstance->setCodeInfo($$);
    free($1);
};
// <-- ** VERILOG_AMS **

/* -----------------------------------------------------------------------
 *  OPTIONAL KEYWORDS
 * -----------------------------------------------------------------------
 */

K_signed_opt:
/* empty */
{
    RULE_BREAK_MACRO $$ = false;
}
| K_signed
{
    yydebug("K_signed_opt: K_signed");
    RULE_BREAK_MACRO $$ = true;
};

K_automatic_opt:
/* empty */
{    
    RULE_BREAK_MACRO $$ = false;
}
| K_automatic
{    
    yydebug("K_automatic_opt: K_automatic");
    RULE_BREAK_MACRO $$ = true;
};

K_reg_opt:
/* empty */
{
    RULE_BREAK_MACRO $$ = false;
}
| K_reg
{   
    yydebug("K_reg_opt: K_reg");
    RULE_BREAK_MACRO $$ = true;
};


%%



#ifdef YYSTACK_ALLOC_MAXIMUM
#endif
#ifdef yyerrok
#endif
#ifdef YYNRULES
#endif
#ifdef YYTOKENTYPE
#endif
#ifdef YYNSTATES
#endif
#ifdef YYSIZE_MAXIMUM
#endif
#ifdef YYLSP_NEEDED
#endif
#ifdef YYRHSLOC
#endif
#ifdef YYRECOVERING
#endif
#ifdef YYFAIL
#endif
#ifdef YYBISON_VERSION
#endif
#ifdef YYBISON
#endif
#ifdef YYNNTS
#endif
#ifdef YYERROR
#endif
#ifdef YYSTYPE_IS_DECLARED
#endif
#ifdef YYBACKUP
#endif
#ifdef YYSKELETON_NAME
#endif
#ifdef YY_LOCATION_PRINT
#endif
#ifdef YYLLOC_DEFAULT
#endif
#ifdef YYERRCODE
#endif
#ifdef K_TRIGGER
#endif
#ifdef K_SG
#endif
#ifdef K_Shold
#endif
#ifdef K_LOR
#endif
#ifdef K_specparam
#endif
#ifdef K_triand
#endif
#ifdef K_rpmos
#endif
#ifdef K_endfunction
#endif
#ifdef K_nand
#endif
#ifdef K_pmos
#endif
#ifdef K_casez
#endif
#ifdef K_LE
#endif
#ifdef K_STARP
#endif
#ifdef K_Sattribute
#endif
#ifdef K_PO_NEG
#endif
#ifdef K_buf
#endif
#ifdef K_case
#endif
#ifdef K_xor
#endif
#ifdef K_module
#endif
#ifdef K_task
#endif
#ifdef K_primitive
#endif
#ifdef K_Swidth
#endif
#ifdef K_repeat
#endif
#ifdef K_tranif0
#endif
#ifdef K_tranif1
#endif
#ifdef K_supply1
#endif
#ifdef less_than_K_else
#endif
#ifdef K_output
#endif
#ifdef K_signed
#endif
#ifdef K_time
#endif
#ifdef SYSTEM_IDENTIFIER
#endif
#ifdef K_weak0
#endif
#ifdef K_large
#endif
#ifdef K_specify
#endif
#ifdef K_join
#endif
#ifdef UNARY_PREC
#endif
#ifdef K_reg
#endif
#ifdef K_define
#endif
#ifdef K_NOR
#endif
#ifdef K_Speriod
#endif
#ifdef K_inout
#endif
#ifdef K_wire
#endif
#ifdef K_real
#endif
#ifdef K_NXOR
#endif
#ifdef K_default
#endif
#ifdef REALTIME
#endif
#ifdef K_trireg
#endif
#ifdef K_localparam
#endif
#ifdef K_realtime
#endif
#ifdef K_supply0
#endif
#ifdef K_notif1
#endif
#ifdef K_release
#endif
#ifdef K_PO_POS
#endif
#ifdef K_highz0
#endif
#ifdef K_highz1
#endif
#ifdef K_defparam
#endif
#ifdef K_disable
#endif
#ifdef K_tran
#endif
#ifdef K_assign
#endif
#ifdef PATHPULSE_IDENTIFIER
#endif
#ifdef K_tri0
#endif
#ifdef K_tri1
#endif
#ifdef K_fork
#endif
#ifdef K_parameter
#endif
#ifdef K_event
#endif
#ifdef K_vectored
#endif
#ifdef STRING
#endif
#ifdef K_endspecify
#endif
#ifdef BASED_NUMBER
#endif
#ifdef K_end
#endif
#ifdef K_forever
#endif
#ifdef K_rtranif1
#endif
#ifdef K_LAND
#endif
#ifdef K_deassign
#endif
#ifdef K_Srecrem
#endif
#ifdef K_tri
#endif
#ifdef K_integer
#endif
#ifdef K_initial
#endif
#ifdef K_bufif0
#endif
#ifdef K_bufif1
#endif
#ifdef K_endtable
#endif
#ifdef K_posedge
#endif
#ifdef K_xnor
#endif
#ifdef K_EG
#endif
#ifdef K_EQEQ
#endif
#ifdef K_GE
#endif
#ifdef K_for
#endif
#ifdef K_LS
#endif
#ifdef K_NE
#endif
#ifdef K_wait
#endif
#ifdef K_RS
#endif
#ifdef K_always
#endif
#ifdef K_wand
#endif
#ifdef K_rnmos
#endif
#ifdef K_endcase
#endif
#ifdef K_macromodule
#endif
#ifdef K_casex
#endif
#ifdef K_nmos
#endif
#ifdef K_if
#endif
#ifdef K_rcmos
#endif
#ifdef K_input
#endif
#ifdef K_or
#endif
#ifdef K_nor
#endif
#ifdef K_not
#endif
#ifdef K_endmodule
#endif
#ifdef K_cmos
#endif
#ifdef yyclearin
#endif
#ifdef K_CEQ
#endif
#ifdef IDENTIFIER
#endif
#ifdef K_table
#endif
#ifdef K_endtask
#endif
#ifdef K_trior
#endif
#ifdef K_CNE
#endif
#ifdef K_pullup
#endif
#ifdef K_strong0
#endif
#ifdef K_strong1
#endif
#ifdef K_PSTAR
#endif
#ifdef K_PSTARP
#endif
#ifdef K_Ssetup
#endif
#ifdef K_small
#endif
#ifdef K_endprimitive
#endif
#ifdef K_begin
#endif
#ifdef K_Ssetuphold
#endif
#ifdef K_pulldown
#endif
#ifdef K_RSS
#endif
#ifdef K_edge
#endif
#ifdef K_pull0
#endif
#ifdef K_pull1
#endif
#ifdef K_weak1
#endif
#ifdef K_rtran
#endif
#ifdef K_while
#endif
#ifdef yystype
#endif
#ifdef K_medium
#endif
#ifdef K_notif0
#endif
#ifdef YYPULL
#endif
#ifdef DEC_NUMBER
#endif
#ifdef SCALAR_CONSTANT
#endif
#ifdef K_NAND
#endif
#ifdef YYPURE
#endif
#ifdef YYPUSH
#endif
#ifdef K_negedge
#endif
#ifdef K_force
#endif
#ifdef K_and
#endif
#ifdef K_scalared
#endif
#ifdef K_rtranif0
#endif
#ifdef K_TAND
#endif
#ifdef K_wor
#endif
#ifdef K_else
#endif
#ifdef K_function
#endif
#ifdef K_Srecovery
#endif
#ifdef K_include
#endif
#ifdef K_automatic
#endif
#ifdef K_pulsestyle_ondetect
#endif
#ifdef K_instance
#endif
#ifdef K_showcancelled
#endif
#ifdef K_cell
#endif
#ifdef K_Sremoval
#endif
#ifdef K_endconfig
#endif
#ifdef K_Sfullskew
#endif
#ifdef K_ATSTAR
#endif
#ifdef K_config
#endif
#ifdef K_incdir
#endif
#ifdef K_genvar
#endif
#ifdef K_unsigned
#endif
#ifdef K_pathpulse
#endif
#ifdef K_Snochange
#endif
#ifdef K_endgenerate
#endif
#ifdef K_POW
#endif
#ifdef K_design
#endif
#ifdef K_uwire
#endif
#ifdef K_generate
#endif
#ifdef K_use
#endif
#ifdef K_pulsestyle_onevent
#endif
#ifdef K_Sskew
#endif
#ifdef K_ifnone
#endif
#ifdef K_noshowcancelled
#endif
#ifdef K_Stimeskew
#endif
#ifdef K_library
#endif
#ifdef K_liblist
#endif
#ifdef LOW
#endif
#ifdef MEDIUM1
#endif
#ifdef MEDIUM2
#endif
#ifdef MEDIUM3
#endif
#ifdef MEDIUM4
#endif
#ifdef MEDIUM5
#endif
#ifdef MEDIUM6
#endif
#ifdef HIGH
#endif
#ifdef YYTABLE_NINF
#endif
#ifdef YYLTYPE_IS_TRIVIAL
#endif
#ifdef YYPACT_NINF
#endif
#ifdef K_RBRACKET
#endif
#ifdef K_AMPERSAND
#endif
#ifdef K_LPAREN
#endif
#ifdef K_SEMICOLON
#endif
#ifdef K_MINUS
#endif
#ifdef K_LBRACE
#endif
#ifdef K_COLON
#endif
#ifdef K_RPAREN
#endif
#ifdef K_STAR
#endif
#ifdef K_RBRACE
#endif
#ifdef K_LBRACKET
#endif
#ifdef K_BAR
#endif
#ifdef K_AT
#endif
#ifdef K_LT
#endif
#ifdef K_SLASH
#endif
#ifdef K_PERC
#endif
#ifdef K_QUEST
#endif
#ifdef K_GT
#endif
#ifdef K_CAP
#endif
#ifdef K_PLUS
#endif
#ifdef K_EQ
#endif
#ifdef K_DOT
#endif
#ifdef K_COMMA
#endif
#ifdef K_SHARP
#endif
#ifdef K_TILDE
#endif
#ifdef K_EXCL
#endif
// *** VERILOG-AMS ***
#ifdef K_above
#endif
#ifdef K_abs
#endif
#ifdef K_absdelay
#endif
#ifdef K_abstol
#endif
#ifdef K_access
#endif
#ifdef K_acos
#endif
#ifdef K_acosh
#endif
#ifdef K_ac_stim
#endif
#ifdef K_aliasparam
#endif
#ifdef K_analog
#endif
#ifdef K_analysis
#endif
#ifdef K_asin
#endif
#ifdef K_asinh
#endif
#ifdef K_atan
#endif
#ifdef K_atan2
#endif
#ifdef K_atanh
#endif
#ifdef K_branch
#endif
#ifdef K_ceil
#endif
#ifdef K_connect
#endif
#ifdef K_connectmodule
#endif
#ifdef K_connectrules
#endif
#ifdef K_continuous
#endif
#ifdef K_cos
#endif
#ifdef K_cosh
#endif
#ifdef K_cross
#endif
#ifdef K_ddt
#endif
#ifdef K_ddt_nature
#endif
#ifdef K_ddx
#endif
#ifdef K_discipline
#endif
#ifdef K_discrete
#endif
#ifdef K_domain
#endif
#ifdef K_driver_update
#endif
#ifdef K_endconnectrules
#endif
#ifdef K_enddiscipline
#endif
#ifdef K_endnature
#endif
#ifdef K_endparamset
#endif
#ifdef K_exclude
#endif
#ifdef K_exp
#endif
#ifdef K_final_step
#endif
#ifdef K_flicker_noise
#endif
#ifdef K_floor
#endif
#ifdef K_flow
#endif
#ifdef K_from
#endif
#ifdef K_ground
#endif
#ifdef K_hypot
#endif
#ifdef K_idt
#endif
#ifdef K_idtmod
#endif
#ifdef K_idt_nature
#endif
#ifdef K_inf
#endif
#ifdef K_initial_step
#endif
#ifdef K_laplace_nd
#endif
#ifdef K_laplace_np
#endif
#ifdef K_laplace_zd
#endif
#ifdef K_laplace_zp
#endif
#ifdef K_last_crossing
#endif
#ifdef K_limexp
#endif
#ifdef K_ln
#endif
#ifdef K_log
#endif
#ifdef K_max
#endif
#ifdef K_merged
#endif
#ifdef K_min
#endif
#ifdef K_nature
#endif
#ifdef K_net_resolution
#endif
#ifdef K_noise_table
#endif
#ifdef K_paramset
#endif
#ifdef K_potential
#endif
#ifdef K_pow
#endif
#ifdef K_resolveto
#endif
#ifdef K_sin
#endif
#ifdef K_sinh
#endif
#ifdef K_slew
#endif
#ifdef K_split
#endif
#ifdef K_sqrt
#endif
#ifdef K_string
#endif
#ifdef K_tan
#endif
#ifdef K_tanh
#endif
#ifdef K_timer
#endif
#ifdef K_transition
#endif
#ifdef K_units
#endif
#ifdef K_white_noise
#endif
#ifdef K_zi_zp
#endif
#ifdef K_zi_nd
#endif
#ifdef K_zi_np
#endif
#ifdef K_zi_zd
#endif
#ifdef zi_zp
#endif
#ifdef K_QUOTE
#endif
#ifdef K_CONTRIB
#endif
#ifdef K_wreal
#endif
#ifdef K_absdelta
#endif
